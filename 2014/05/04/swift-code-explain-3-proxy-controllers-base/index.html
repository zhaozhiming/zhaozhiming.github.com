<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>swift源码详解（三）——proxy/controllers/base.py - Hacker and Geeker&#39;s Way</title>
    <meta name="author" content="">
    
	<meta name="description" content="swift源码详解"> <!-- TODO: truncate -->
	<meta name="keywords" content="swift">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Hacker and Geeker&#39;s Way" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='/stylesheets/font.css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Amethysta+One' rel='stylesheet' type='text/css'>
	  <script src="/javascripts/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-100485541-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Hacker and Geeker&#39;s Way
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  <!-- GitHub -->
  <li>
  <a target="_blank" rel="noopener" href="https://github.com/zhaozhiming" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.twitter.com/kingzzm" class="twitter" title="Twitter"></a>
  </li>
  
  
  <!-- LinkedIn -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.linkedin.com/in/zhaozhiming" class="linkedin" title="LinkedIn"></a>
  </li>
  
  
  
  
  
  <!-- Stackoverflow -->
  <li>
  <a target="_blank" rel="noopener" href="http://stackoverflow.com/users/1954315/zhaozhiming" class="stackoverflow" title="Stackoverflow"></a>
  </li>
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about/index.html">About</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://zhaozhiming.github.io" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>


<div id="toload">
<!-- begin toload -->
    <div id="content">
        <div class="inner">
<article class="post">
	<h2 class="title">swift源码详解（三）——proxy/controllers/base.py</h2>
    <div class="meta">
        <div class="date">Published on: <time datetime="2014-05-04T13:36:00.000Z" itemprop="datePublished">5月 4, 2014</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/swift/">swift</a>
</div>
    </div>
	<div class="entry-content"><h2 id="回swift代码结构目录"><a href="#回swift代码结构目录" class="headerlink" title="回swift代码结构目录"></a><a href="http://zhaozhiming.github.io/2014/04/19/swift-code-explain-total/">回swift代码结构目录</a></h2><h3 id="update-headers"><a href="#update-headers" class="headerlink" title="update_headers"></a>update_headers</h3><span id="more"></span>  
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_headers</span>(<span class="params">response, headers</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Helper function to update headers in the response.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param response: swob.Response object</span></span><br><span class="line"><span class="string">    :param headers: dictionary headers</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(headers, <span class="string">&#x27;items&#x27;</span>):</span><br><span class="line">        headers = headers.items()</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> headers:</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;etag&#x27;</span>:</span><br><span class="line">            response.headers[name] = value.replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;content-length&#x27;</span>, <span class="string">&#x27;content-type&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;connection&#x27;</span>, <span class="string">&#x27;x-put-timestamp&#x27;</span>, <span class="string">&#x27;x-delete-after&#x27;</span>):</span><br><span class="line">            response.headers[name] = value</span><br></pre></td></tr></table></figure>  
<ul>
<li>更新response的header。</li>
<li>查看headers中是否’items’属性，有的话给headers赋值。</li>
<li>遍历headers中的每个header,如果是’etag’，则去除值中的双引号，并写到response的header中，如果header不是特殊的header，则写到response的header中。</li>
</ul>
<h3 id="source-key"><a href="#source-key" class="headerlink" title="source_key"></a>source_key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">source_key</span>(<span class="params">resp</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Provide the timestamp of the swift http response as a floating</span></span><br><span class="line"><span class="string">    point value.  Used as a sort key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param resp: bufferedhttp response object</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(resp.getheader(<span class="string">&#x27;x-put-timestamp&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">                 resp.getheader(<span class="string">&#x27;x-timestamp&#x27;</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure>  
<ul>
<li>依次获取response中的header’x-put-timestamp’和’x-timestamp’的值，如果有值则返回，没有则返回0。</li>
</ul>
<h3 id="delay-denial"><a href="#delay-denial" class="headerlink" title="delay_denial"></a>delay_denial</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delay_denial</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decorator to declare which methods should have any swift.authorize call</span></span><br><span class="line"><span class="string">    delayed. This is so the method can load the Request object up with</span></span><br><span class="line"><span class="string">    additional information that may be needed by the authorization system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param func: function for which authorization will be delayed</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    func.delay_denial = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">*a, **kw</span>):</span><br><span class="line">        <span class="keyword">return</span> func(*a, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br></pre></td></tr></table></figure>  
<ul>
<li>方法标签，标识了该标签的方法表示与swift.authorize有关，会延迟认证。</li>
</ul>
<h3 id="get-account-memcache-key"><a href="#get-account-memcache-key" class="headerlink" title="get_account_memcache_key"></a>get_account_memcache_key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_account_memcache_key</span>(<span class="params">account</span>):</span><br><span class="line">    cache_key, env_key = _get_cache_key(account, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> cache_key</span><br></pre></td></tr></table></figure>  
<ul>
<li>获取account的缓存key。</li>
</ul>
<h3 id="get-container-memcache-key"><a href="#get-container-memcache-key" class="headerlink" title="get_container_memcache_key"></a>get_container_memcache_key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_container_memcache_key</span>(<span class="params">account, container</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> container:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;container not provided&quot;</span>)</span><br><span class="line">    cache_key, env_key = _get_cache_key(account, container)</span><br><span class="line">    <span class="keyword">return</span> cache_key</span><br></pre></td></tr></table></figure>  
<ul>
<li>获取container的缓存key。</li>
</ul>
<h3 id="prep-headers-to-info"><a href="#prep-headers-to-info" class="headerlink" title="_prep_headers_to_info"></a>_prep_headers_to_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_prep_headers_to_info</span>(<span class="params">headers, server_type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Helper method that iterates once over a dict of headers,</span></span><br><span class="line"><span class="string">    converting all keys to lower case and separating</span></span><br><span class="line"><span class="string">    into subsets containing user metadata, system metadata</span></span><br><span class="line"><span class="string">    and other headers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    meta = &#123;&#125;</span><br><span class="line">    sysmeta = &#123;&#125;</span><br><span class="line">    other = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">dict</span>(headers).iteritems():</span><br><span class="line">        lkey = key.lower()</span><br><span class="line">        <span class="keyword">if</span> is_user_meta(server_type, lkey):</span><br><span class="line">            meta[strip_user_meta_prefix(server_type, lkey)] = val</span><br><span class="line">        <span class="keyword">elif</span> is_sys_meta(server_type, lkey):</span><br><span class="line">            sysmeta[strip_sys_meta_prefix(server_type, lkey)] = val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            other[lkey] = val</span><br><span class="line">    <span class="keyword">return</span> other, meta, sysmeta</span><br></pre></td></tr></table></figure>  
<ul>
<li>将header根据server_type进行分类，以x-<em>-meta开头的为用户信息类，以x-</em>-sysmeta开头的为系统信息类，其他的为other类。</li>
</ul>
<h3 id="headers-to-account-info"><a href="#headers-to-account-info" class="headerlink" title="headers_to_account_info"></a>headers_to_account_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">headers_to_account_info</span>(<span class="params">headers, status_int=HTTP_OK</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct a cacheable dict of account info based on response headers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    headers, meta, sysmeta = _prep_headers_to_info(headers, <span class="string">&#x27;account&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>: status_int,</span><br><span class="line">        <span class="comment"># &#x27;container_count&#x27; anomaly:</span></span><br><span class="line">        <span class="comment"># Previous code sometimes expects an int sometimes a string</span></span><br><span class="line">        <span class="comment"># Current code aligns to str and None, yet translates to int in</span></span><br><span class="line">        <span class="comment"># deprecated functions as needed</span></span><br><span class="line">        <span class="string">&#x27;container_count&#x27;</span>: headers.get(<span class="string">&#x27;x-account-container-count&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;total_object_count&#x27;</span>: headers.get(<span class="string">&#x27;x-account-object-count&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;bytes&#x27;</span>: headers.get(<span class="string">&#x27;x-account-bytes-used&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;meta&#x27;</span>: meta,</span><br><span class="line">        <span class="string">&#x27;sysmeta&#x27;</span>: sysmeta</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  
<ul>
<li>将account的header进行分类，返回包含account信息的字典。</li>
</ul>
<h3 id="headers-to-container-info"><a href="#headers-to-container-info" class="headerlink" title="headers_to_container_info"></a>headers_to_container_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">headers_to_container_info</span>(<span class="params">headers, status_int=HTTP_OK</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct a cacheable dict of container info based on response headers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    headers, meta, sysmeta = _prep_headers_to_info(headers, <span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>: status_int,</span><br><span class="line">        <span class="string">&#x27;read_acl&#x27;</span>: headers.get(<span class="string">&#x27;x-container-read&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;write_acl&#x27;</span>: headers.get(<span class="string">&#x27;x-container-write&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;sync_key&#x27;</span>: headers.get(<span class="string">&#x27;x-container-sync-key&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;object_count&#x27;</span>: headers.get(<span class="string">&#x27;x-container-object-count&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;bytes&#x27;</span>: headers.get(<span class="string">&#x27;x-container-bytes-used&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;versions&#x27;</span>: headers.get(<span class="string">&#x27;x-versions-location&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;cors&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;allow_origin&#x27;</span>: meta.get(<span class="string">&#x27;access-control-allow-origin&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;expose_headers&#x27;</span>: meta.get(<span class="string">&#x27;access-control-expose-headers&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;max_age&#x27;</span>: meta.get(<span class="string">&#x27;access-control-max-age&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;meta&#x27;</span>: meta,</span><br><span class="line">        <span class="string">&#x27;sysmeta&#x27;</span>: sysmeta</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  
<ul>
<li>将container的header进行分类，返回包含container信息的字典。</li>
</ul>
<h3 id="headers-to-object-info"><a href="#headers-to-object-info" class="headerlink" title="headers_to_object_info"></a>headers_to_object_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">headers_to_object_info</span>(<span class="params">headers, status_int=HTTP_OK</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct a cacheable dict of object info based on response headers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    headers, meta, sysmeta = _prep_headers_to_info(headers, <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">    info = &#123;<span class="string">&#x27;status&#x27;</span>: status_int,</span><br><span class="line">            <span class="string">&#x27;length&#x27;</span>: headers.get(<span class="string">&#x27;content-length&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: headers.get(<span class="string">&#x27;content-type&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;etag&#x27;</span>: headers.get(<span class="string">&#x27;etag&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;meta&#x27;</span>: meta</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure>  
<ul>
<li>将object的header进行分类，返回包含object信息的字典。</li>
</ul>
<h3 id="cors-validation"><a href="#cors-validation" class="headerlink" title="cors_validation"></a>cors_validation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cors_validation</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decorator to check if the request is a CORS request and if so, if it&#x27;s</span></span><br><span class="line"><span class="string">    valid.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param func: function to check</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">*a, **kw</span>):</span><br><span class="line">        controller = a[<span class="number">0</span>]</span><br><span class="line">        req = a[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The logic here was interpreted from</span></span><br><span class="line">        <span class="comment">#    http://www.w3.org/TR/cors/#resource-requests</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Is this a CORS request?</span></span><br><span class="line">        req_origin = req.headers.get(<span class="string">&#x27;Origin&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> req_origin:</span><br><span class="line">            <span class="comment"># Yes, this is a CORS request so test if the origin is allowed</span></span><br><span class="line">            container_info = \</span><br><span class="line">                controller.container_info(controller.account_name,</span><br><span class="line">                                          controller.container_name, req)</span><br><span class="line">            cors_info = container_info.get(<span class="string">&#x27;cors&#x27;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Call through to the decorated method</span></span><br><span class="line">            resp = func(*a, **kw)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> controller.app.strict_cors_mode <span class="keyword">and</span> \</span><br><span class="line">                    <span class="keyword">not</span> controller.is_origin_allowed(cors_info, req_origin):</span><br><span class="line">                <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>  
<ul>
<li>方法标签，对CORS请求进行验证。</li>
<li>先判断该请求是否是一个跨域资源共享（CORS）请求，是的话先获取container的信息，再根据container信息获取cors信息。</li>
<li>如果controller的cors mode存在就判断原请求是否被允许，允许的话返回response。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Expose,</span></span><br><span class="line"><span class="comment">#  - simple response headers,</span></span><br><span class="line"><span class="comment">#    http://www.w3.org/TR/cors/#simple-response-header</span></span><br><span class="line"><span class="comment">#  - swift specific: etag, x-timestamp, x-trans-id</span></span><br><span class="line"><span class="comment">#  - user metadata headers</span></span><br><span class="line"><span class="comment">#  - headers provided by the user in</span></span><br><span class="line"><span class="comment">#    x-container-meta-access-control-expose-headers</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> resp.headers:</span><br><span class="line">    expose_headers = [</span><br><span class="line">        <span class="string">&#x27;cache-control&#x27;</span>, <span class="string">&#x27;content-language&#x27;</span>, <span class="string">&#x27;content-type&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;expires&#x27;</span>, <span class="string">&#x27;last-modified&#x27;</span>, <span class="string">&#x27;pragma&#x27;</span>, <span class="string">&#x27;etag&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;x-timestamp&#x27;</span>, <span class="string">&#x27;x-trans-id&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> header <span class="keyword">in</span> resp.headers:</span><br><span class="line">        <span class="keyword">if</span> header.startswith(<span class="string">&#x27;X-Container-Meta&#x27;</span>) <span class="keyword">or</span> \</span><br><span class="line">                header.startswith(<span class="string">&#x27;X-Object-Meta&#x27;</span>):</span><br><span class="line">            expose_headers.append(header.lower())</span><br><span class="line">    <span class="keyword">if</span> cors_info.get(<span class="string">&#x27;expose_headers&#x27;</span>):</span><br><span class="line">        expose_headers.extend(</span><br><span class="line">            [header_line.strip()</span><br><span class="line">             <span class="keyword">for</span> header_line <span class="keyword">in</span></span><br><span class="line">             cors_info[<span class="string">&#x27;expose_headers&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">             <span class="keyword">if</span> header_line.strip()])</span><br><span class="line">    resp.headers[<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>] = \</span><br><span class="line">        <span class="string">&#x27;, &#x27;</span>.join(expose_headers)</span><br></pre></td></tr></table></figure>  
<ul>
<li>方法标签，对CORS请求进行验证。</li>
<li>先判断该请求是否是一个跨域资源共享（CORS）请求，是的话先获取container的信息，再根据container信息获取cors信息。</li>
<li>根据controller的cors mode判断cors请求是否被允许，是的话返回response。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment"># The user agent won&#x27;t process the response if the Allow-Origin</span></span><br><span class="line">        <span class="comment"># header isn&#x27;t included</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> resp.headers:</span><br><span class="line">            <span class="keyword">if</span> cors_info[<span class="string">&#x27;allow_origin&#x27;</span>] <span class="keyword">and</span> \</span><br><span class="line">                    cors_info[<span class="string">&#x27;allow_origin&#x27;</span>].strip() == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                resp.headers[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                resp.headers[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = req_origin</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> 	resp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Not a CORS request so make the call as normal</span></span><br><span class="line">        <span class="keyword">return</span> func(*a, **kw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrapped</span><br></pre></td></tr></table></figure>  
<ul>
<li>如果response里面不包含’Access-Control-Allow-Origin’ header，则加上该header。</li>
</ul>
<h3 id="get-object-info"><a href="#get-object-info" class="headerlink" title="get_object_info"></a>get_object_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_object_info</span>(<span class="params">env, app, path=<span class="literal">None</span>, swift_source=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the info structure for an object, based on env and app.</span></span><br><span class="line"><span class="string">    This is useful to middlewares.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. note::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This call bypasses auth. Success does not imply that the request has</span></span><br><span class="line"><span class="string">        authorization to the object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    (version, account, container, obj) = \</span><br><span class="line">        split_path(path <span class="keyword">or</span> env[<span class="string">&#x27;PATH_INFO&#x27;</span>], <span class="number">4</span>, <span class="number">4</span>, <span class="literal">True</span>)</span><br><span class="line">    info = _get_object_info(app, env, account, container, obj,</span><br><span class="line">                            swift_source=swift_source)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">        info = headers_to_object_info(&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure>  
<ul>
<li>根据env和app获取object的结构信息。</li>
</ul>
<h3 id="get-container-info"><a href="#get-container-info" class="headerlink" title="get_container_info"></a>get_container_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_container_info</span>(<span class="params">env, app, swift_source=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the info structure for a container, based on env and app.</span></span><br><span class="line"><span class="string">    This is useful to middlewares.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. note::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This call bypasses auth. Success does not imply that the request has</span></span><br><span class="line"><span class="string">        authorization to the container.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    (version, account, container, unused) = \</span><br><span class="line">        split_path(env[<span class="string">&#x27;PATH_INFO&#x27;</span>], <span class="number">3</span>, <span class="number">4</span>, <span class="literal">True</span>)</span><br><span class="line">    info = get_info(app, env, account, container, ret_not_found=<span class="literal">True</span>,</span><br><span class="line">                    swift_source=swift_source)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">        info = headers_to_container_info(&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure>  
<ul>
<li>根据env和app获取container的结构信息。</li>
</ul>
<h3 id="get-account-info"><a href="#get-account-info" class="headerlink" title="get_account_info"></a>get_account_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_account_info</span>(<span class="params">env, app, swift_source=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the info structure for an account, based on env and app.</span></span><br><span class="line"><span class="string">    This is useful to middlewares.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. note::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This call bypasses auth. Success does not imply that the request has</span></span><br><span class="line"><span class="string">        authorization to the account.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    (version, account, _junk, _junk) = \</span><br><span class="line">        split_path(env[<span class="string">&#x27;PATH_INFO&#x27;</span>], <span class="number">2</span>, <span class="number">4</span>, <span class="literal">True</span>)</span><br><span class="line">    info = get_info(app, env, account, ret_not_found=<span class="literal">True</span>,</span><br><span class="line">                    swift_source=swift_source)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">        info = headers_to_account_info(&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> info.get(<span class="string">&#x27;container_count&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        info[<span class="string">&#x27;container_count&#x27;</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        info[<span class="string">&#x27;container_count&#x27;</span>] = <span class="built_in">int</span>(info[<span class="string">&#x27;container_count&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure>  
<ul>
<li>根据env和app获取account的结构信息。</li>
</ul>
<h3 id="get-cache-key"><a href="#get-cache-key" class="headerlink" title="_get_cache_key"></a>_get_cache_key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_cache_key</span>(<span class="params">account, container</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the keys for both memcache (cache_key) and env (env_key)</span></span><br><span class="line"><span class="string">    where info about accounts and containers is cached</span></span><br><span class="line"><span class="string">    :param   account: The name of the account</span></span><br><span class="line"><span class="string">    :param container: The name of the container (or None if account)</span></span><br><span class="line"><span class="string">    :returns a tuple of (cache_key, env_key)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> container:</span><br><span class="line">        cache_key = <span class="string">&#x27;container/%s/%s&#x27;</span> % (account, container)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache_key = <span class="string">&#x27;account/%s&#x27;</span> % account</span><br><span class="line">    <span class="comment"># Use a unique environment cache key per account and one container.</span></span><br><span class="line">    <span class="comment"># This allows caching both account and container and ensures that when we</span></span><br><span class="line">    <span class="comment"># copy this env to form a new request, it won&#x27;t accidentally reuse the</span></span><br><span class="line">    <span class="comment"># old container or account info</span></span><br><span class="line">    env_key = <span class="string">&#x27;swift.%s&#x27;</span> % cache_key</span><br><span class="line">    <span class="keyword">return</span> cache_key, env_key</span><br></pre></td></tr></table></figure>  
<ul>
<li>获取account和container的缓存key，account是’account&#x2F;account名’，container是’container&#x2F;account名&#x2F;container名’，还有env_key，值为’swift.缓存key’。</li>
</ul>
<h3 id="get-object-env-key"><a href="#get-object-env-key" class="headerlink" title="get_object_env_key"></a>get_object_env_key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_object_env_key</span>(<span class="params">account, container, obj</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the keys for env (env_key) where info about object is cached</span></span><br><span class="line"><span class="string">    :param   account: The name of the account</span></span><br><span class="line"><span class="string">    :param container: The name of the container</span></span><br><span class="line"><span class="string">    :param obj: The name of the object</span></span><br><span class="line"><span class="string">    :returns a string env_key</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    env_key = <span class="string">&#x27;swift.object/%s/%s/%s&#x27;</span> % (account,</span><br><span class="line">                                         container, obj)</span><br><span class="line">    <span class="keyword">return</span> env_key</span><br></pre></td></tr></table></figure>  
<ul>
<li>得到object的env_key，值为’swift.object&#x2F;account名&#x2F;container名&#x2F;object名。</li>
</ul>
<h3 id="set-info-cache"><a href="#set-info-cache" class="headerlink" title="set_info_cache"></a>set_info_cache</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_set_info_cache</span>(<span class="params">app, env, account, container, resp</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Cache info in both memcache and env.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Caching is used to avoid unnecessary calls to account &amp; container servers.</span></span><br><span class="line"><span class="string">    This is a private function that is being called by GETorHEAD_base and</span></span><br><span class="line"><span class="string">    by clear_info_cache.</span></span><br><span class="line"><span class="string">    Any attempt to GET or HEAD from the container/account server should use</span></span><br><span class="line"><span class="string">    the GETorHEAD_base interface which would than set the cache.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param  app: the application object</span></span><br><span class="line"><span class="string">    :param  account: the unquoted account name</span></span><br><span class="line"><span class="string">    :param  container: the unquoted container name or None</span></span><br><span class="line"><span class="string">    :param resp: the response received or None if info cache should be cleared</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> container:</span><br><span class="line">        cache_time = app.recheck_container_existence</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache_time = app.recheck_account_existence</span><br><span class="line">    cache_key, env_key = _get_cache_key(account, container)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp:</span><br><span class="line">        <span class="keyword">if</span> resp.status_int == HTTP_NOT_FOUND:</span><br><span class="line">            cache_time *= <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> is_success(resp.status_int):</span><br><span class="line">            cache_time = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache_time = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Next actually set both memcache and the env chache</span></span><br><span class="line">    memcache = <span class="built_in">getattr</span>(app, <span class="string">&#x27;memcache&#x27;</span>, <span class="literal">None</span>) <span class="keyword">or</span> env.get(<span class="string">&#x27;swift.cache&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cache_time:</span><br><span class="line">        env.pop(env_key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> memcache:</span><br><span class="line">            memcache.delete(cache_key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> container:</span><br><span class="line">        info = headers_to_container_info(resp.headers, resp.status_int)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        info = headers_to_account_info(resp.headers, resp.status_int)</span><br><span class="line">    <span class="keyword">if</span> memcache:</span><br><span class="line">        memcache.<span class="built_in">set</span>(cache_key, info, time=cache_time)</span><br><span class="line">    env[env_key] = info</span><br></pre></td></tr></table></figure>  
<ul>
<li>信息在缓存和env都各存一份，缓存一般用来避免对account和container没必要的调用，这是一个私有方法，主要被GETorHEAD_base和clear_info_cache方法调用。如果想通过HEAD和GET获取container&#x2F;account信息，建议使用GETorHEAD_base方法，因为该方法会设置缓存信息。</li>
<li>检查container和account是否存在，再通过account和container获取缓存key。</li>
<li>根据response状态码设置缓存时间，如果缓存时间设置为None，则在env和缓存中移除cache_key缓存信息。</li>
<li>最后在缓存和env中设置container或account的info信息。</li>
</ul>
<h3 id="set-object-info-cache"><a href="#set-object-info-cache" class="headerlink" title="_set_object_info_cache"></a>_set_object_info_cache</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_set_object_info_cache</span>(<span class="params">app, env, account, container, obj, resp</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Cache object info env. Do not cache object informations in</span></span><br><span class="line"><span class="string">    memcache. This is an intentional omission as it would lead</span></span><br><span class="line"><span class="string">    to cache pressure. This is a per-request cache.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Caching is used to avoid unnecessary calls to object servers.</span></span><br><span class="line"><span class="string">    This is a private function that is being called by GETorHEAD_base.</span></span><br><span class="line"><span class="string">    Any attempt to GET or HEAD from the object server should use</span></span><br><span class="line"><span class="string">    the GETorHEAD_base interface which would then set the cache.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param  app: the application object</span></span><br><span class="line"><span class="string">    :param  account: the unquoted account name</span></span><br><span class="line"><span class="string">    :param  container: the unquoted container name or None</span></span><br><span class="line"><span class="string">    :param  object: the unquoted object name or None</span></span><br><span class="line"><span class="string">    :param resp: the response received or None if info cache should be cleared</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    env_key = get_object_env_key(account, container, obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp:</span><br><span class="line">        env.pop(env_key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    info = headers_to_object_info(resp.headers, resp.status_int)</span><br><span class="line">    env[env_key] = info</span><br></pre></td></tr></table></figure>  
<ul>
<li>object的信息只缓存在env中，没有缓存在memcache中是因为缓存起来的话会对缓存造成压力，这是前一次请求的缓存。缓存为了避免那些对object没必要的调用，这是一个私有方法，主要被GETorHEAD_base和clear_info_cache方法调用。如果想通过HEAD和GET获取container&#x2F;account信息，建议使用GETorHEAD_base方法，因为该方法会设置缓存信息。</li>
<li>先获取object的env_key，如果response没有则在env中移除env_key的信息，最后在env中添加object的info信息。</li>
</ul>
<h3 id="clear-info-cache"><a href="#clear-info-cache" class="headerlink" title="clear_info_cache"></a>clear_info_cache</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clear_info_cache</span>(<span class="params">app, env, account, container=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Clear the cached info in both memcache and env</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param  app: the application object</span></span><br><span class="line"><span class="string">    :param  account: the account name</span></span><br><span class="line"><span class="string">    :param  container: the containr name or None if setting info for containers</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _set_info_cache(app, env, account, container, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>  
<ul>
<li>在memcache和env中清除account或container的缓存信息。</li>
</ul>
<h3 id="get-info-cache"><a href="#get-info-cache" class="headerlink" title="_get_info_cache"></a>_get_info_cache</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_info_cache</span>(<span class="params">app, env, account, container=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the cached info from env or memcache (if used) in that order</span></span><br><span class="line"><span class="string">    Used for both account and container info</span></span><br><span class="line"><span class="string">    A private function used by get_info</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param  app: the application object</span></span><br><span class="line"><span class="string">    :param  env: the environment used by the current request</span></span><br><span class="line"><span class="string">    :returns the cached info or None if not cached</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    cache_key, env_key = _get_cache_key(account, container)</span><br><span class="line">    <span class="keyword">if</span> env_key <span class="keyword">in</span> env:</span><br><span class="line">        <span class="keyword">return</span> env[env_key]</span><br><span class="line">    memcache = <span class="built_in">getattr</span>(app, <span class="string">&#x27;memcache&#x27;</span>, <span class="literal">None</span>) <span class="keyword">or</span> env.get(<span class="string">&#x27;swift.cache&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> memcache:</span><br><span class="line">        info = memcache.get(cache_key)</span><br><span class="line">        <span class="keyword">if</span> info:</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> info:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(info[key], unicode):</span><br><span class="line">                    info[key] = info[key].encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            env[env_key] = info</span><br><span class="line">        <span class="keyword">return</span> info</span><br><span class="line">    <span class="keyword">return</span> Noner, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>  
<ul>
<li>私有方法，被get_info调用，在env和memcache中获取account和container信息，顺序是先env再memcache。</li>
<li>获取env_key和cache_keyi，如果env_key在env中存在，则返回env中的值。</li>
<li>如果env中没有，再从memcache中获取信息，将获取到的信息放到env中。</li>
</ul>
<h3 id="prepare-pre-auth-info-request"><a href="#prepare-pre-auth-info-request" class="headerlink" title="_prepare_pre_auth_info_request"></a>_prepare_pre_auth_info_request</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_prepare_pre_auth_info_request</span>(<span class="params">env, path, swift_source</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Prepares a pre authed request to obtain info using a HEAD.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param env: the environment used by the current request</span></span><br><span class="line"><span class="string">    :param path: The unquoted request path</span></span><br><span class="line"><span class="string">    :param swift_source: value for swift.source in WSGI environment</span></span><br><span class="line"><span class="string">    :returns: the pre authed request</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Set the env for the pre_authed call without a query string</span></span><br><span class="line">    newenv = make_pre_authed_env(env, <span class="string">&#x27;HEAD&#x27;</span>, path, agent=<span class="string">&#x27;Swift&#x27;</span>,</span><br><span class="line">                                 query_string=<span class="string">&#x27;&#x27;</span>, swift_source=swift_source)</span><br><span class="line">    <span class="comment"># This is a sub request for container metadata- drop the Origin header from</span></span><br><span class="line">    <span class="comment"># the request so the it is not treated as a CORS request.</span></span><br><span class="line">    newenv.pop(<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># Note that Request.blank expects quoted path</span></span><br><span class="line">    <span class="keyword">return</span> Request.blank(quote(path), environ=newenv)</span><br></pre></td></tr></table></figure>  
<ul>
<li>准备一个做过认证的HEAD请求来获取信息。</li>
</ul>
<h3 id="get-info"><a href="#get-info" class="headerlink" title="get_info"></a>get_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>(<span class="params">app, env, account, container=<span class="literal">None</span>, ret_not_found=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">             swift_source=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the info about accounts or containers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note: This call bypasses auth. Success does not imply that the</span></span><br><span class="line"><span class="string">          request has authorization to the info.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param app: the application object</span></span><br><span class="line"><span class="string">    :param env: the environment used by the current request</span></span><br><span class="line"><span class="string">    :param account: The unquoted name of the account</span></span><br><span class="line"><span class="string">    :param container: The unquoted name of the container (or None if account)</span></span><br><span class="line"><span class="string">    :returns: the cached info or None if cannot be retrieved</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    info = _get_info_cache(app, env, account, container)</span><br><span class="line">    <span class="keyword">if</span> info:</span><br><span class="line">        <span class="keyword">if</span> ret_not_found <span class="keyword">or</span> is_success(info[<span class="string">&#x27;status&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> info</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Not in cache, let&#x27;s try the account servers</span></span><br><span class="line">    path = <span class="string">&#x27;/v1/%s&#x27;</span> % account</span><br><span class="line">    <span class="keyword">if</span> container:</span><br><span class="line">        <span class="comment"># Stop and check if we have an account?</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> get_info(app, env, account):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        path += <span class="string">&#x27;/&#x27;</span> + container</span><br><span class="line"></span><br><span class="line">    req = _prepare_pre_auth_info_request(</span><br><span class="line">        env, path, (swift_source <span class="keyword">or</span> <span class="string">&#x27;GET_INFO&#x27;</span>))</span><br><span class="line">    <span class="comment"># Whenever we do a GET/HEAD, the GETorHEAD_base will set the info in</span></span><br><span class="line">    <span class="comment"># the environment under environ[env_key] and in memcache. We will</span></span><br><span class="line">    <span class="comment"># pick the one from environ[env_key] and use it to set the caller env</span></span><br><span class="line">    resp = req.get_response(app)</span><br><span class="line">    cache_key, env_key = _get_cache_key(account, container)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = resp.environ[env_key]</span><br><span class="line">        env[env_key] = info</span><br><span class="line">        <span class="keyword">if</span> ret_not_found <span class="keyword">or</span> is_success(info[<span class="string">&#x27;status&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> info</span><br><span class="line">    <span class="keyword">except</span> (KeyError, AttributeError):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>从缓存中获取info信息，如果缓存中有且状态是success，则返回info。如果缓存没有，则发起1个不用认证的请求获取account和container的info信息。</li>
</ul>
<h3 id="get-object-info-1"><a href="#get-object-info-1" class="headerlink" title="_get_object_info"></a>_get_object_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_object_info</span>(<span class="params">app, env, account, container, obj, swift_source=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get the info about object</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note: This call bypasses auth. Success does not imply that the</span></span><br><span class="line"><span class="string">          request has authorization to the info.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param app: the application object</span></span><br><span class="line"><span class="string">    :param env: the environment used by the current request</span></span><br><span class="line"><span class="string">    :param account: The unquoted name of the account</span></span><br><span class="line"><span class="string">    :param container: The unquoted name of the container</span></span><br><span class="line"><span class="string">    :param obj: The unquoted name of the object</span></span><br><span class="line"><span class="string">    :returns: the cached info or None if cannot be retrieved</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    env_key = get_object_env_key(account, container, obj)</span><br><span class="line">    info = env.get(env_key)</span><br><span class="line">    <span class="keyword">if</span> info:</span><br><span class="line">        <span class="keyword">return</span> info</span><br><span class="line">    <span class="comment"># Not in cached, let&#x27;s try the object servers</span></span><br><span class="line">    path = <span class="string">&#x27;/v1/%s/%s/%s&#x27;</span> % (account, container, obj)</span><br><span class="line">    req = _prepare_pre_auth_info_request(env, path, swift_source)</span><br><span class="line">    <span class="comment"># Whenever we do a GET/HEAD, the GETorHEAD_base will set the info in</span></span><br><span class="line">    <span class="comment"># the environment under environ[env_key]. We will</span></span><br><span class="line">    <span class="comment"># pick the one from environ[env_key] and use it to set the caller env</span></span><br><span class="line">    resp = req.get_response(app)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = resp.environ[env_key]</span><br><span class="line">        env[env_key] = info</span><br><span class="line">        <span class="keyword">return</span> info</span><br><span class="line">    <span class="keyword">except</span> (KeyError, AttributeError):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>先从env中获取object的info信息，如果没有则发起请求不认证的请求重新获取。</li>
</ul>
<h3 id="close-swift-conn"><a href="#close-swift-conn" class="headerlink" title="close_swift_conn"></a>close_swift_conn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close_swift_conn</span>(<span class="params">src</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Force close the http connection to the backend.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param src: the response from the backend</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Since the backends set &quot;Connection: close&quot; in their response</span></span><br><span class="line">        <span class="comment"># headers, the response object (src) is solely responsible for the</span></span><br><span class="line">        <span class="comment"># socket. The connection object (src.swift_conn) has no references</span></span><br><span class="line">        <span class="comment"># to the socket, so calling its close() method does nothing, and</span></span><br><span class="line">        <span class="comment"># therefore we don&#x27;t do it.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Also, since calling the response&#x27;s close() method might not</span></span><br><span class="line">        <span class="comment"># close the underlying socket but only decrement some</span></span><br><span class="line">        <span class="comment"># reference-counter, we have a special method here that really,</span></span><br><span class="line">        <span class="comment"># really kills the underlying socket with a close() syscall.</span></span><br><span class="line">        src.nuke_from_orbit()  <span class="comment"># it&#x27;s the only way to be sure</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>关闭swift连接，用了很底层的一个关闭socket连接的方法。</li>
</ul>
<h2 id="GetOrHeadHandler类"><a href="#GetOrHeadHandler类" class="headerlink" title="GetOrHeadHandler类"></a>GetOrHeadHandler类</h2><h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app, req, server_type, ring, partition, path,</span></span><br><span class="line"><span class="params">                backend_headers</span>):</span><br><span class="line">       <span class="variable language_">self</span>.app = app</span><br><span class="line">       <span class="variable language_">self</span>.ring = ring</span><br><span class="line">       <span class="variable language_">self</span>.server_type = server_type</span><br><span class="line">       <span class="variable language_">self</span>.partition = partition</span><br><span class="line">       <span class="variable language_">self</span>.path = path</span><br><span class="line">       <span class="variable language_">self</span>.backend_headers = backend_headers</span><br><span class="line">       <span class="variable language_">self</span>.used_nodes = []</span><br><span class="line">       <span class="variable language_">self</span>.used_source_etag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># stuff from request</span></span><br><span class="line">       <span class="variable language_">self</span>.req_method = req.method</span><br><span class="line">       <span class="variable language_">self</span>.req_path = req.path</span><br><span class="line">       <span class="variable language_">self</span>.req_query_string = req.query_string</span><br><span class="line">       <span class="variable language_">self</span>.newest = config_true_value(req.headers.get(<span class="string">&#x27;x-newest&#x27;</span>, <span class="string">&#x27;f&#x27;</span>))</span><br><span class="line"></span><br><span class="line">       <span class="comment"># populated when finding source</span></span><br><span class="line">       <span class="variable language_">self</span>.statuses = []</span><br><span class="line">       <span class="variable language_">self</span>.reasons = []</span><br><span class="line">       <span class="variable language_">self</span>.bodies = []</span><br><span class="line">       <span class="variable language_">self</span>.source_headers = []</span><br></pre></td></tr></table></figure>  
<ul>
<li>GetOrHeadHandler类的初始化方法。</li>
</ul>
<h3 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast_forward"></a>fast_forward</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fast_forward</span>(<span class="params">self, num_bytes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Will skip num_bytes into the current ranges.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :params num_bytes: the number of bytes that have already been read on</span></span><br><span class="line"><span class="string">                       this request. This will change the Range header</span></span><br><span class="line"><span class="string">                       so that the next req will start where it left off.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :raises NotImplementedError: if this is a multirange request</span></span><br><span class="line"><span class="string">    :raises ValueError: if invalid range header</span></span><br><span class="line"><span class="string">    :raises HTTPRequestedRangeNotSatisfiable: if begin + num_bytes</span></span><br><span class="line"><span class="string">                                              &gt; end of range</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;Range&#x27;</span> <span class="keyword">in</span> <span class="variable language_">self</span>.backend_headers:</span><br><span class="line">        req_range = Range(<span class="variable language_">self</span>.backend_headers[<span class="string">&#x27;Range&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(req_range.ranges) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line">        begin, end = req_range.ranges.pop()</span><br><span class="line">        <span class="keyword">if</span> begin <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># this is a -50 range req (last 50 bytes of file)</span></span><br><span class="line">            end -= num_bytes</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            begin += num_bytes</span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">and</span> begin &gt; end:</span><br><span class="line">            <span class="keyword">raise</span> HTTPRequestedRangeNotSatisfiable()</span><br><span class="line">        req_range.ranges = [(begin, end)]</span><br><span class="line">        <span class="variable language_">self</span>.backend_headers[<span class="string">&#x27;Range&#x27;</span>] = <span class="built_in">str</span>(req_range)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.backend_headers[<span class="string">&#x27;Range&#x27;</span>] = <span class="string">&#x27;bytes=%d-&#x27;</span> % num_bytes</span><br></pre></td></tr></table></figure>  
<ul>
<li>先判断Range是否在后台进程的header中，如果没有，则在后台进程header中增加Range，值为’bytes&#x3D;’加num_bytes。  </li>
<li>如果有，先创建一个Range对象，判断如果Range对象的ranges如果大于1,则报NotImplementedError的异常。  </li>
<li>从rangs中取到开始和结束字节数，先检查两个字节数是否正确，不正确抛异常，正确的话将其重新放入到后台进程header中。</li>
</ul>
<h3 id="is-good-source"><a href="#is-good-source" class="headerlink" title="is_good_source"></a>is_good_source</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_good_source</span>(<span class="params">self, src</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Indicates whether or not the request made to the backend found</span></span><br><span class="line"><span class="string">    what it was looking for.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param src: the response from the backend</span></span><br><span class="line"><span class="string">    :returns: True if found, False if not</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.server_type == <span class="string">&#x27;Object&#x27;</span> <span class="keyword">and</span> src.status == <span class="number">416</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> is_success(src.status) <span class="keyword">or</span> is_redirection(src.status)</span><br></pre></td></tr></table></figure>  
<ul>
<li>如果是一个Object请求，并且返回状态码是416，则返回True，否则返回状态码是否200～399。</li>
</ul>
<h3 id="make-app-iter"><a href="#make-app-iter" class="headerlink" title="_make_app_iter"></a>_make_app_iter</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_make_app_iter</span>(<span class="params">self, req, node, source</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns an iterator over the contents of the source (via its read</span></span><br><span class="line"><span class="string">    func).  There is also quite a bit of cleanup to ensure garbage</span></span><br><span class="line"><span class="string">    collection works and the underlying socket of the source is closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param req: incoming request object</span></span><br><span class="line"><span class="string">    :param source: The httplib.Response object this iterator should read</span></span><br><span class="line"><span class="string">                   from.</span></span><br><span class="line"><span class="string">    :param node: The node the source is reading from, for logging purposes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nchunks = <span class="number">0</span></span><br><span class="line">        bytes_read_from_source = <span class="number">0</span></span><br><span class="line">        node_timeout = <span class="variable language_">self</span>.app.node_timeout</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.server_type == <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">            node_timeout = <span class="variable language_">self</span>.app.recoverable_node_timeout</span><br></pre></td></tr></table></figure>  
<ul>
<li>初始化本地变量，如果是object请求，则将节点超时时间设置为object的recoverable_node_timeout。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> ChunkReadTimeout(node_timeout):</span><br><span class="line">            chunk = source.read(<span class="variable language_">self</span>.app.object_chunk_size)</span><br><span class="line">            nchunks += <span class="number">1</span></span><br><span class="line">            bytes_read_from_source += <span class="built_in">len</span>(chunk)</span><br><span class="line">    <span class="keyword">except</span> ChunkReadTimeout:</span><br><span class="line">        exc_type, exc_value, exc_traceback = exc_info()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.newest <span class="keyword">or</span> <span class="variable language_">self</span>.server_type != <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> exc_type, exc_value, exc_traceback</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>.fast_forward(bytes_read_from_source)</span><br><span class="line">        <span class="keyword">except</span> (NotImplementedError, HTTPException, ValueError):</span><br><span class="line">            <span class="keyword">raise</span> exc_type, exc_value, exc_traceback</span><br><span class="line">        new_source, new_node = <span class="variable language_">self</span>._get_source_and_node()</span><br><span class="line">        <span class="keyword">if</span> new_source:</span><br><span class="line">            <span class="variable language_">self</span>.app.exception_occurred(</span><br><span class="line">                node, _(<span class="string">&#x27;Object&#x27;</span>),</span><br><span class="line">                _(<span class="string">&#x27;Trying to read during GET (retrying)&#x27;</span>))</span><br><span class="line">            <span class="comment"># Close-out the connection as best as possible.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">getattr</span>(source, <span class="string">&#x27;swift_conn&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">                close_swift_conn(source)</span><br><span class="line">            source = new_source</span><br><span class="line">            node = new_node</span><br><span class="line">            bytes_read_from_source = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> exc_type, exc_value, exc_traceback</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">with</span> ChunkWriteTimeout(<span class="variable language_">self</span>.app.client_timeout):</span><br><span class="line">        <span class="keyword">yield</span> chunk                        </span><br></pre></td></tr></table></figure>  
<ul>
<li>通过一个无限循环，不断读取response的数据，累加读取的块数大小和字节总长度。</li>
<li>如果读取数据超时，则处理异常，如果请求不是Object则抛出最近的异常信息。</li>
<li>记录已读的字节范围，错误抛异常。</li>
<li>获取新的source和节点，如果source存在的话，则创建一个异常并关闭连接重新初始化，否则抛出异常。</li>
<li>如果读取不到数据，则跳出循环。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment"># This is for fairness; if the network is outpacing the CPU,</span></span><br><span class="line">        <span class="comment"># we&#x27;ll always be able to read and write data without</span></span><br><span class="line">        <span class="comment"># encountering an EWOULDBLOCK, and so eventlet will not switch</span></span><br><span class="line">        <span class="comment"># greenthreads on its own. We do it manually so that clients</span></span><br><span class="line">        <span class="comment"># don&#x27;t starve.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># The number 5 here was chosen by making stuff up. It&#x27;s not</span></span><br><span class="line">        <span class="comment"># every single chunk, but it&#x27;s not too big either, so it seemed</span></span><br><span class="line">        <span class="comment"># like it would probably be an okay choice.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Note that we may trampoline to other greenthreads more often</span></span><br><span class="line">        <span class="comment"># than once every 5 chunks, depending on how blocking our</span></span><br><span class="line">        <span class="comment"># network IO is; the explicit sleep here simply provides a</span></span><br><span class="line">        <span class="comment"># lower bound on the rate of trampolining.</span></span><br><span class="line">        <span class="keyword">if</span> nchunks % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ChunkReadTimeout:</span><br><span class="line">    <span class="variable language_">self</span>.app.exception_occurred(node, _(<span class="string">&#x27;Object&#x27;</span>),</span><br><span class="line">                                _(<span class="string">&#x27;Trying to read during GET&#x27;</span>))</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">except</span> ChunkWriteTimeout:</span><br><span class="line">    <span class="variable language_">self</span>.app.logger.warn(</span><br><span class="line">        _(<span class="string">&#x27;Client did not read from proxy within %ss&#x27;</span>) %</span><br><span class="line">        <span class="variable language_">self</span>.app.client_timeout)</span><br><span class="line">    <span class="variable language_">self</span>.app.logger.increment(<span class="string">&#x27;client_timeouts&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> GeneratorExit:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> req.environ.get(<span class="string">&#x27;swift.non_client_disconnect&#x27;</span>):</span><br><span class="line">        <span class="variable language_">self</span>.app.logger.warn(_(<span class="string">&#x27;Client disconnected on read&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="variable language_">self</span>.app.logger.exception(_(<span class="string">&#x27;Trying to send to client&#x27;</span>))</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># Close-out the connection as best as possible.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(source, <span class="string">&#x27;swift_conn&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">        close_swift_conn(source)</span><br></pre></td></tr></table></figure>  
<ul>
<li>每读取5个字节块，休眠一次。</li>
<li>读取数据超时抛异常。</li>
<li>写入数据超时记日志。</li>
<li>抛出各种异常后关闭连接。</li>
</ul>
<h3 id="get-source-and-node"><a href="#get-source-and-node" class="headerlink" title="_get_source_and_node"></a>_get_source_and_node</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_source_and_node</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.statuses = []</span><br><span class="line">    <span class="variable language_">self</span>.reasons = []</span><br><span class="line">    <span class="variable language_">self</span>.bodies = []</span><br><span class="line">    <span class="variable language_">self</span>.source_headers = []</span><br><span class="line">    sources = []</span><br><span class="line"></span><br><span class="line">    node_timeout = <span class="variable language_">self</span>.app.node_timeout</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.server_type == <span class="string">&#x27;Object&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.newest:</span><br><span class="line">        node_timeout = <span class="variable language_">self</span>.app.recoverable_node_timeout</span><br></pre></td></tr></table></figure>  
<ul>
<li>初始化本地变量，设置node_timeout时间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> <span class="variable language_">self</span>.app.iter_nodes(<span class="variable language_">self</span>.ring, <span class="variable language_">self</span>.partition):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> <span class="variable language_">self</span>.used_nodes:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    start_node_timing = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> ConnectionTimeout(<span class="variable language_">self</span>.app.conn_timeout):</span><br><span class="line">            conn = http_connect(</span><br><span class="line">                node[<span class="string">&#x27;ip&#x27;</span>], node[<span class="string">&#x27;port&#x27;</span>], node[<span class="string">&#x27;device&#x27;</span>],</span><br><span class="line">                <span class="variable language_">self</span>.partition, <span class="variable language_">self</span>.req_method, <span class="variable language_">self</span>.path,</span><br><span class="line">                headers=<span class="variable language_">self</span>.backend_headers,</span><br><span class="line">                query_string=<span class="variable language_">self</span>.req_query_string)</span><br><span class="line">        <span class="variable language_">self</span>.app.set_node_timing(node, time.time() - start_node_timing)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> Timeout(node_timeout):</span><br><span class="line">            possible_source = conn.getresponse()</span><br><span class="line">            <span class="comment"># See <span class="doctag">NOTE:</span> swift_conn at top of file about this.</span></span><br><span class="line">            possible_source.swift_conn = conn</span><br><span class="line">    <span class="keyword">except</span> (Exception, Timeout):</span><br><span class="line">        <span class="variable language_">self</span>.app.exception_occurred(</span><br><span class="line">            node, <span class="variable language_">self</span>.server_type,</span><br><span class="line">            _(<span class="string">&#x27;Trying to %(method)s %(path)s&#x27;</span>) %</span><br><span class="line">            &#123;<span class="string">&#x27;method&#x27;</span>: <span class="variable language_">self</span>.req_method, <span class="string">&#x27;path&#x27;</span>: <span class="variable language_">self</span>.req_path&#125;)</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>循环取节点，如果节点已经被使用了，则跳过该节点，否则封装http连接，设置节点时间。</li>
<li>获取请求结果，如果超时，则抛异常，跳出此次循环。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.is_good_source(possible_source):</span><br><span class="line">    <span class="comment"># 404 if we know we don&#x27;t have a synced copy</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">float</span>(possible_source.getheader(<span class="string">&#x27;X-PUT-Timestamp&#x27;</span>, <span class="number">1</span>)):</span><br><span class="line">        <span class="variable language_">self</span>.statuses.append(HTTP_NOT_FOUND)</span><br><span class="line">        <span class="variable language_">self</span>.reasons.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.bodies.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.source_headers.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        close_swift_conn(possible_source)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.used_source_etag:</span><br><span class="line">            src_headers = <span class="built_in">dict</span>(</span><br><span class="line">                (k.lower(), v) <span class="keyword">for</span> k, v <span class="keyword">in</span></span><br><span class="line">                possible_source.getheaders())</span><br><span class="line">            <span class="keyword">if</span> src_headers.get(<span class="string">&#x27;etag&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip(<span class="string">&#x27;&quot;&#x27;</span>) != \</span><br><span class="line">                    <span class="variable language_">self</span>.used_source_etag:</span><br><span class="line">                <span class="variable language_">self</span>.statuses.append(HTTP_NOT_FOUND)</span><br><span class="line">                <span class="variable language_">self</span>.reasons.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="variable language_">self</span>.bodies.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="variable language_">self</span>.source_headers.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.statuses.append(possible_source.status)</span><br><span class="line">        <span class="variable language_">self</span>.reasons.append(possible_source.reason)</span><br><span class="line">        <span class="variable language_">self</span>.bodies.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.source_headers.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        sources.append((possible_source, node))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.newest:  <span class="comment"># one good source is enough</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>如果返回结果合理，则判断返回结果中的PUT时间是否存在，不存在证明还没有同步，则返回404并关闭连接。</li>
<li>如果时间存在，则继续判断已用etag是否存在，存在的话从返回结果中取出etag值与之比较，不相等就返回404并关闭连接。</li>
<li>已用etag不存在，则将返回结果设置到自身属性中，并判断是否最新，是则跳出循环，取一个good source就足够了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.statuses.append(possible_source.status)</span><br><span class="line">        <span class="variable language_">self</span>.reasons.append(possible_source.reason)</span><br><span class="line">        <span class="variable language_">self</span>.bodies.append(possible_source.read())</span><br><span class="line">        <span class="variable language_">self</span>.source_headers.append(possible_source.getheaders())</span><br><span class="line">        <span class="keyword">if</span> possible_source.status == HTTP_INSUFFICIENT_STORAGE:</span><br><span class="line">            <span class="variable language_">self</span>.app.error_limit(node, _(<span class="string">&#x27;ERROR Insufficient Storage&#x27;</span>))</span><br><span class="line">        <span class="keyword">elif</span> is_server_error(possible_source.status):</span><br><span class="line">            <span class="variable language_">self</span>.app.error_occurred(</span><br><span class="line">                node, _(<span class="string">&#x27;ERROR %(status)d %(body)s &#x27;</span></span><br><span class="line">                        <span class="string">&#x27;From %(type)s Server&#x27;</span>) %</span><br><span class="line">                &#123;<span class="string">&#x27;status&#x27;</span>: possible_source.status,</span><br><span class="line">                 <span class="string">&#x27;body&#x27;</span>: <span class="variable language_">self</span>.bodies[-<span class="number">1</span>][:<span class="number">1024</span>],</span><br><span class="line">                 <span class="string">&#x27;type&#x27;</span>: <span class="variable language_">self</span>.server_type&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sources:</span><br><span class="line">    sources.sort(key=<span class="keyword">lambda</span> s: source_key(s[<span class="number">0</span>]))</span><br><span class="line">    source, node = sources.pop()</span><br><span class="line">    <span class="keyword">for</span> src, _junk <span class="keyword">in</span> sources:</span><br><span class="line">        close_swift_conn(src)</span><br><span class="line">    <span class="variable language_">self</span>.used_nodes.append(node)</span><br><span class="line">    src_headers = <span class="built_in">dict</span>(</span><br><span class="line">        (k.lower(), v) <span class="keyword">for</span> k, v <span class="keyword">in</span></span><br><span class="line">        possible_source.getheaders())</span><br><span class="line">    <span class="variable language_">self</span>.used_source_etag = src_headers.get(<span class="string">&#x27;etag&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> source, node</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>如果返回结果不是一个good source，则将返回结果信息设置到自身属性，如果返回状态是507,则将节点加入到错误列表，如果返回状态是其他500以上的数字，则抛出异常。</li>
<li>循环结束后，如果取到了source，则先将sources进行排序然后取第一个，接着关闭剩下的source。</li>
<li>添加节点到已用节点，设置易用etag，返回结果，如果取不到source，则返回空。</li>
</ul>
<h3 id="get-working-response"><a href="#get-working-response" class="headerlink" title="get_working_response"></a>get_working_response</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_working_response</span>(<span class="params">self, req</span>):</span><br><span class="line">    source, node = <span class="variable language_">self</span>._get_source_and_node()</span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> source:</span><br><span class="line">        res = Response(request=req)</span><br><span class="line">        <span class="keyword">if</span> req.method == <span class="string">&#x27;GET&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">                source.status <span class="keyword">in</span> (HTTP_OK, HTTP_PARTIAL_CONTENT):</span><br><span class="line">            res.app_iter = <span class="variable language_">self</span>._make_app_iter(req, node, source)</span><br><span class="line">            <span class="comment"># See <span class="doctag">NOTE:</span> swift_conn at top of file about this.</span></span><br><span class="line">            res.swift_conn = source.swift_conn</span><br><span class="line">        res.status = source.status</span><br><span class="line">        update_headers(res, source.getheaders())</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res.environ:</span><br><span class="line">            res.environ = &#123;&#125;</span><br><span class="line">        res.environ[<span class="string">&#x27;swift_x_timestamp&#x27;</span>] = \</span><br><span class="line">            source.getheader(<span class="string">&#x27;x-timestamp&#x27;</span>)</span><br><span class="line">        res.accept_ranges = <span class="string">&#x27;bytes&#x27;</span></span><br><span class="line">        res.content_length = source.getheader(<span class="string">&#x27;Content-Length&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> source.getheader(<span class="string">&#x27;Content-Type&#x27;</span>):</span><br><span class="line">            res.charset = <span class="literal">None</span></span><br><span class="line">            res.content_type = source.getheader(<span class="string">&#x27;Content-Type&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>先获取source和node，如果有的话，则根据req参数封装response，如果请求是’GET’并且source的状态是200或206,则设置response的app_iter和conn。</li>
<li>将source的状态码和header设置进response，再分别根据source的内容设置返回的response的值。</li>
</ul>
<h2 id="Controller类"><a href="#Controller类" class="headerlink" title="Controller类"></a>Controller类</h2><h3 id="init方法-1"><a href="#init方法-1" class="headerlink" title="init方法"></a>init方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Base WSGI controller class for the proxy&quot;&quot;&quot;</span></span><br><span class="line">server_type = <span class="string">&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure these are all lowercase</span></span><br><span class="line">pass_through_headers = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Creates a controller attached to an application instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param app: the application instance</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>.account_name = <span class="literal">None</span></span><br><span class="line">    <span class="variable language_">self</span>.app = app</span><br><span class="line">    <span class="variable language_">self</span>.trans_id = <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    <span class="variable language_">self</span>._allowed_methods = <span class="literal">None</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>设置类型为base，初始化方法，创建controller时使用。</li>
</ul>
<h3 id="allowed-methods"><a href="#allowed-methods" class="headerlink" title="allowed_methods"></a>allowed_methods</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allowed_methods</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._allowed_methods <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._allowed_methods = <span class="built_in">set</span>()</span><br><span class="line">        all_methods = inspect.getmembers(<span class="variable language_">self</span>, predicate=inspect.ismethod)</span><br><span class="line">        <span class="keyword">for</span> name, m <span class="keyword">in</span> all_methods:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">getattr</span>(m, <span class="string">&#x27;publicly_accessible&#x27;</span>, <span class="literal">False</span>):</span><br><span class="line">                <span class="variable language_">self</span>._allowed_methods.add(name)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._allowed_methods</span><br></pre></td></tr></table></figure>  
<ul>
<li>类属性变量allowed_methods的初始化方法。</li>
</ul>
<h3 id="transfer-headers"><a href="#transfer-headers" class="headerlink" title="transfer_headers"></a>transfer_headers</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transfer_headers</span>(<span class="params">self, src_headers, dst_headers</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Transfer legal headers from an original client request to dictionary</span></span><br><span class="line"><span class="string">    that will be used as headers by the backend request</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param src_headers: A dictionary of the original client request headers</span></span><br><span class="line"><span class="string">    :param dst_headers: A dictionary of the backend request headers</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    st = <span class="variable language_">self</span>.server_type.lower()</span><br><span class="line"></span><br><span class="line">    x_remove = <span class="string">&#x27;x-remove-%s-meta-&#x27;</span> % st</span><br><span class="line">    dst_headers.update((k.lower().replace(<span class="string">&#x27;-remove&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">1</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                       <span class="keyword">for</span> k <span class="keyword">in</span> src_headers</span><br><span class="line">                       <span class="keyword">if</span> k.lower().startswith(x_remove) <span class="keyword">or</span></span><br><span class="line">                       k.lower() <span class="keyword">in</span> <span class="variable language_">self</span>._x_remove_headers())</span><br><span class="line"></span><br><span class="line">    dst_headers.update((k.lower(), v)</span><br><span class="line">                       <span class="keyword">for</span> k, v <span class="keyword">in</span> src_headers.iteritems()</span><br><span class="line">                       <span class="keyword">if</span> k.lower() <span class="keyword">in</span> <span class="variable language_">self</span>.pass_through_headers <span class="keyword">or</span></span><br><span class="line">                       is_sys_or_user_meta(st, k))</span><br></pre></td></tr></table></figure>  
<ul>
<li>将一个原始客户端请求的遗留header转换为新的header，给后台进程使用。</li>
</ul>
<h3 id="transfer-headers-1"><a href="#transfer-headers-1" class="headerlink" title="transfer_headers"></a>transfer_headers</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_request_headers</span>(<span class="params">self, orig_req=<span class="literal">None</span>, additional=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                             transfer=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create a list of headers to be used in backend requets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param orig_req: the original request sent by the client to the proxy</span></span><br><span class="line"><span class="string">    :param additional: additional headers to send to the backend</span></span><br><span class="line"><span class="string">    :param transfer: If True, transfer headers from original client request</span></span><br><span class="line"><span class="string">    :returns: a dictionary of headers</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Use the additional headers first so they don&#x27;t overwrite the headers</span></span><br><span class="line">    <span class="comment"># we require.</span></span><br><span class="line">    headers = HeaderKeyDict(additional) <span class="keyword">if</span> additional <span class="keyword">else</span> HeaderKeyDict()</span><br><span class="line">    <span class="keyword">if</span> transfer:</span><br><span class="line">        <span class="variable language_">self</span>.transfer_headers(orig_req.headers, headers)</span><br><span class="line">    headers.setdefault(<span class="string">&#x27;x-timestamp&#x27;</span>, normalize_timestamp(time.time()))</span><br><span class="line">    <span class="keyword">if</span> orig_req:</span><br><span class="line">        referer = orig_req.as_referer()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        referer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    headers[<span class="string">&#x27;x-trans-id&#x27;</span>] = <span class="variable language_">self</span>.trans_id</span><br><span class="line">    headers[<span class="string">&#x27;connection&#x27;</span>] = <span class="string">&#x27;close&#x27;</span></span><br><span class="line">    headers[<span class="string">&#x27;user-agent&#x27;</span>] = <span class="string">&#x27;proxy-server %s&#x27;</span> % os.getpid()</span><br><span class="line">    headers[<span class="string">&#x27;referer&#x27;</span>] = referer</span><br><span class="line">    <span class="keyword">return</span> headers</span><br></pre></td></tr></table></figure>  
<ul>
<li>生成一组headers为后台进程使用。</li>
</ul>
<h3 id="account-info"><a href="#account-info" class="headerlink" title="account_info"></a>account_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account_info</span>(<span class="params">self, account, req=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get account information, and also verify that the account exists.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param account: name of the account to get the info for</span></span><br><span class="line"><span class="string">    :param req: caller&#x27;s HTTP request context object (optional)</span></span><br><span class="line"><span class="string">    :returns: tuple of (account partition, account nodes, container_count)</span></span><br><span class="line"><span class="string">              or (None, None, None) if it does not exist</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    partition, nodes = <span class="variable language_">self</span>.app.account_ring.get_nodes(account)</span><br><span class="line">    <span class="keyword">if</span> req:</span><br><span class="line">        env = <span class="built_in">getattr</span>(req, <span class="string">&#x27;environ&#x27;</span>, &#123;&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env = &#123;&#125;</span><br><span class="line">    info = get_info(<span class="variable language_">self</span>.app, env, account)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> info.get(<span class="string">&#x27;container_count&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        container_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        container_count = <span class="built_in">int</span>(info[<span class="string">&#x27;container_count&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> partition, nodes, container_count</span><br></pre></td></tr></table></figure>  
<ul>
<li>获取account信息，正常返回分区号，节点和容器数量，获取不到返回3个None。</li>
</ul>
<h3 id="account-info-1"><a href="#account-info-1" class="headerlink" title="account_info"></a>account_info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">container_info</span>(<span class="params">self, account, container, req=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get container information and thusly verify container existence.</span></span><br><span class="line"><span class="string">    This will also verify account existence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param account: account name for the container</span></span><br><span class="line"><span class="string">    :param container: container name to look up</span></span><br><span class="line"><span class="string">    :param req: caller&#x27;s HTTP request context object (optional)</span></span><br><span class="line"><span class="string">    :returns: dict containing at least container partition (&#x27;partition&#x27;),</span></span><br><span class="line"><span class="string">              container nodes (&#x27;containers&#x27;), container read</span></span><br><span class="line"><span class="string">              acl (&#x27;read_acl&#x27;), container write acl (&#x27;write_acl&#x27;),</span></span><br><span class="line"><span class="string">              and container sync key (&#x27;sync_key&#x27;).</span></span><br><span class="line"><span class="string">              Values are set to None if the container does not exist.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    part, nodes = <span class="variable language_">self</span>.app.container_ring.get_nodes(account, container)</span><br><span class="line">    <span class="keyword">if</span> req:</span><br><span class="line">        env = <span class="built_in">getattr</span>(req, <span class="string">&#x27;environ&#x27;</span>, &#123;&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env = &#123;&#125;</span><br><span class="line">    info = get_info(<span class="variable language_">self</span>.app, env, account, container)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">        info = headers_to_container_info(&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">        info[<span class="string">&#x27;partition&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">        info[<span class="string">&#x27;nodes&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        info[<span class="string">&#x27;partition&#x27;</span>] = part</span><br><span class="line">        info[<span class="string">&#x27;nodes&#x27;</span>] = nodes</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure>  
<ul>
<li>获取container信息，会顺便校验container是否存在，也会校验account是否存在。</li>
</ul>
<h3 id="make-request-私有方法"><a href="#make-request-私有方法" class="headerlink" title="make_request(私有方法)"></a>make_request(私有方法)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_make_request</span>(<span class="params">self, nodes, part, method, path, headers, query,</span></span><br><span class="line"><span class="params">                  logger_thread_locals</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Iterates over the given node iterator, sending an HTTP request to one</span></span><br><span class="line"><span class="string">    node at a time.  The first non-informational, non-server-error</span></span><br><span class="line"><span class="string">    response is returned.  If no non-informational, non-server-error</span></span><br><span class="line"><span class="string">    response is received from any of the nodes, returns None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param nodes: an iterator of the backend server and handoff servers</span></span><br><span class="line"><span class="string">    :param part: the partition number</span></span><br><span class="line"><span class="string">    :param method: the method to send to the backend</span></span><br><span class="line"><span class="string">    :param path: the path to send to the backend</span></span><br><span class="line"><span class="string">                 (full path ends up being /&lt;$device&gt;/&lt;$part&gt;/&lt;$path&gt;)</span></span><br><span class="line"><span class="string">    :param headers: a list of dicts, where each dict represents one</span></span><br><span class="line"><span class="string">                    backend request that should be made.</span></span><br><span class="line"><span class="string">    :param query: query string to send to the backend.</span></span><br><span class="line"><span class="string">    :param logger_thread_locals: The thread local values to be set on the</span></span><br><span class="line"><span class="string">                                 self.app.logger to retain transaction</span></span><br><span class="line"><span class="string">                                 logging information.</span></span><br><span class="line"><span class="string">    :returns: a swob.Response object, or None if no responses were received</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>.app.logger.thread_locals = logger_thread_locals</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            start_node_timing = time.time()</span><br><span class="line">            <span class="keyword">with</span> ConnectionTimeout(<span class="variable language_">self</span>.app.conn_timeout):</span><br><span class="line">                conn = http_connect(node[<span class="string">&#x27;ip&#x27;</span>], node[<span class="string">&#x27;port&#x27;</span>],</span><br><span class="line">                                    node[<span class="string">&#x27;device&#x27;</span>], part, method, path,</span><br><span class="line">                                    headers=headers, query_string=query)</span><br><span class="line">                conn.node = node</span><br><span class="line">            <span class="variable language_">self</span>.app.set_node_timing(node, time.time() - start_node_timing)</span><br><span class="line">            <span class="keyword">with</span> Timeout(<span class="variable language_">self</span>.app.node_timeout):</span><br><span class="line">                resp = conn.getresponse()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_informational(resp.status) <span class="keyword">and</span> \</span><br><span class="line">                        <span class="keyword">not</span> is_server_error(resp.status):</span><br><span class="line">                    <span class="keyword">return</span> resp.status, resp.reason, resp.getheaders(), \</span><br><span class="line">                        resp.read()</span><br><span class="line">                <span class="keyword">elif</span> resp.status == HTTP_INSUFFICIENT_STORAGE:</span><br><span class="line">                    <span class="variable language_">self</span>.app.error_limit(node,</span><br><span class="line">                                         _(<span class="string">&#x27;ERROR Insufficient Storage&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> (Exception, Timeout):</span><br><span class="line">            <span class="variable language_">self</span>.app.exception_occurred(</span><br><span class="line">                node, <span class="variable language_">self</span>.server_type,</span><br><span class="line">                _(<span class="string">&#x27;Trying to %(method)s %(path)s&#x27;</span>) %</span><br><span class="line">                &#123;<span class="string">&#x27;method&#x27;</span>: method, <span class="string">&#x27;path&#x27;</span>: path&#125;)</span><br></pre></td></tr></table></figure>  
<ul>
<li>遍历每个节点，根据节点信息发起请求，如果请求不是100+和500+，则返回请求结果。</li>
<li>如果请求状态码为507，则加入node到异常node列表。</li>
<li>其他异常抛出异常信息。</li>
</ul>
<h3 id="make-requests"><a href="#make-requests" class="headerlink" title="make_requests"></a>make_requests</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_requests</span>(<span class="params">self, req, ring, part, method, path, headers,</span></span><br><span class="line"><span class="params">                  query_string=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Sends an HTTP request to multiple nodes and aggregates the results.</span></span><br><span class="line"><span class="string">    It attempts the primary nodes concurrently, then iterates over the</span></span><br><span class="line"><span class="string">    handoff nodes as needed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param req: a request sent by the client</span></span><br><span class="line"><span class="string">    :param ring: the ring used for finding backend servers</span></span><br><span class="line"><span class="string">    :param part: the partition number</span></span><br><span class="line"><span class="string">    :param method: the method to send to the backend</span></span><br><span class="line"><span class="string">    :param path: the path to send to the backend</span></span><br><span class="line"><span class="string">                 (full path ends up being  /&lt;$device&gt;/&lt;$part&gt;/&lt;$path&gt;)</span></span><br><span class="line"><span class="string">    :param headers: a list of dicts, where each dict represents one</span></span><br><span class="line"><span class="string">                    backend request that should be made.</span></span><br><span class="line"><span class="string">    :param query_string: optional query string to send to the backend</span></span><br><span class="line"><span class="string">    :returns: a swob.Response object</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    start_nodes = ring.get_part_nodes(part)</span><br><span class="line">    nodes = GreenthreadSafeIterator(<span class="variable language_">self</span>.app.iter_nodes(ring, part))</span><br><span class="line">    pile = GreenAsyncPile(<span class="built_in">len</span>(start_nodes))</span><br><span class="line">    <span class="keyword">for</span> head <span class="keyword">in</span> headers:</span><br><span class="line">        pile.spawn(<span class="variable language_">self</span>._make_request, nodes, part, method, path,</span><br><span class="line">                   head, query_string, <span class="variable language_">self</span>.app.logger.thread_locals)</span><br><span class="line">    response = []</span><br><span class="line">    statuses = []</span><br><span class="line">    <span class="keyword">for</span> resp <span class="keyword">in</span> pile:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> resp:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        response.append(resp)</span><br><span class="line">        statuses.append(resp[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.have_quorum(statuses, <span class="built_in">len</span>(start_nodes)):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># give any pending requests *some* chance to finish</span></span><br><span class="line">    pile.waitall(<span class="variable language_">self</span>.app.post_quorum_timeout)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(response) &lt; <span class="built_in">len</span>(start_nodes):</span><br><span class="line">        response.append((HTTP_SERVICE_UNAVAILABLE, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    statuses, reasons, resp_headers, bodies = <span class="built_in">zip</span>(*response)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.best_response(req, statuses, reasons, bodies,</span><br><span class="line">                              <span class="string">&#x27;%s %s&#x27;</span> % (<span class="variable language_">self</span>.server_type, req.method),</span><br><span class="line">                              headers=resp_headers)</span><br></pre></td></tr></table></figure>  
<ul>
<li>先通过partition获取node节点，再根据节点个数创建线程发起每个节点请求。</li>
<li>获取每个线程的返回结果，将状态码和响应结果记录保存到列表中，如果状态码列表个数超过节点的一半，则跳出循环。</li>
<li>将剩下的response设置为503，最后通过best_response方法获取response。</li>
</ul>
<h3 id="have-quorum"><a href="#have-quorum" class="headerlink" title="have_quorum"></a>have_quorum</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">have_quorum</span>(<span class="params">self, statuses, node_count</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a list of statuses from several requests, determine if</span></span><br><span class="line"><span class="string">    a quorum response can already be decided.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param statuses: list of statuses returned</span></span><br><span class="line"><span class="string">    :param node_count: number of nodes being queried (basically ring count)</span></span><br><span class="line"><span class="string">    :returns: True or False, depending on if quorum is established</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    quorum = quorum_size(node_count)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(statuses) &gt;= quorum:</span><br><span class="line">        <span class="keyword">for</span> hundred <span class="keyword">in</span> (HTTP_OK, HTTP_MULTIPLE_CHOICES, HTTP_BAD_REQUEST):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> s <span class="keyword">in</span> statuses</span><br><span class="line">                   <span class="keyword">if</span> hundred &lt;= s &lt; hundred + <span class="number">100</span>) &gt;= quorum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>  
<ul>
<li>通过节点个数和一组状态码判断响应是否已经满足限额。</li>
</ul>
<h3 id="best-response"><a href="#best-response" class="headerlink" title="best_response"></a>best_response</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">best_response</span>(<span class="params">self, req, statuses, reasons, bodies, server_type,</span></span><br><span class="line"><span class="params">                  etag=<span class="literal">None</span>, headers=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a list of responses from several servers, choose the best to</span></span><br><span class="line"><span class="string">    return to the API.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param req: swob.Request object</span></span><br><span class="line"><span class="string">    :param statuses: list of statuses returned</span></span><br><span class="line"><span class="string">    :param reasons: list of reasons for each status</span></span><br><span class="line"><span class="string">    :param bodies: bodies of each response</span></span><br><span class="line"><span class="string">    :param server_type: type of server the responses came from</span></span><br><span class="line"><span class="string">    :param etag: etag</span></span><br><span class="line"><span class="string">    :param headers: headers of each response</span></span><br><span class="line"><span class="string">    :returns: swob.Response object with the correct status, body, etc. set</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    resp = Response(request=req)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(statuses):</span><br><span class="line">        <span class="keyword">for</span> hundred <span class="keyword">in</span> (HTTP_OK, HTTP_MULTIPLE_CHOICES, HTTP_BAD_REQUEST):</span><br><span class="line">            hstatuses = \</span><br><span class="line">                [s <span class="keyword">for</span> s <span class="keyword">in</span> statuses <span class="keyword">if</span> hundred &lt;= s &lt; hundred + <span class="number">100</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hstatuses) &gt;= quorum_size(<span class="built_in">len</span>(statuses)):</span><br><span class="line">                status = <span class="built_in">max</span>(hstatuses)</span><br><span class="line">                status_index = statuses.index(status)</span><br><span class="line">                resp.status = <span class="string">&#x27;%s %s&#x27;</span> % (status, reasons[status_index])</span><br><span class="line">                resp.body = bodies[status_index]</span><br><span class="line">                <span class="keyword">if</span> headers:</span><br><span class="line">                    update_headers(resp, headers[status_index])</span><br><span class="line">                <span class="keyword">if</span> etag:</span><br><span class="line">                    resp.headers[<span class="string">&#x27;etag&#x27;</span>] = etag.strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> resp</span><br><span class="line">    <span class="variable language_">self</span>.app.logger.error(_(<span class="string">&#x27;%(type)s returning 503 for %(statuses)s&#x27;</span>),</span><br><span class="line">                          &#123;<span class="string">&#x27;type&#x27;</span>: server_type, <span class="string">&#x27;statuses&#x27;</span>: statuses&#125;)</span><br><span class="line">    resp.status = <span class="string">&#x27;503 Internal Server Error&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>  
<ul>
<li>给定一组response，返回最佳的response。</li>
<li>比如副本数是3,response列表是[201,201,503],则返回201。</li>
</ul>
<h3 id="autocreate-account"><a href="#autocreate-account" class="headerlink" title="autocreate_account"></a>autocreate_account</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">autocreate_account</span>(<span class="params">self, env, account</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Autocreate an account</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param env: the environment of the request leading to this autocreate</span></span><br><span class="line"><span class="string">    :param account: the unquoted account name</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    partition, nodes = <span class="variable language_">self</span>.app.account_ring.get_nodes(account)</span><br><span class="line">    path = <span class="string">&#x27;/%s&#x27;</span> % account</span><br><span class="line">    headers = &#123;<span class="string">&#x27;X-Timestamp&#x27;</span>: normalize_timestamp(time.time()),</span><br><span class="line">               <span class="string">&#x27;X-Trans-Id&#x27;</span>: <span class="variable language_">self</span>.trans_id,</span><br><span class="line">               <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>&#125;</span><br><span class="line">    resp = <span class="variable language_">self</span>.make_requests(Request.blank(<span class="string">&#x27;/v1&#x27;</span> + path),</span><br><span class="line">                              <span class="variable language_">self</span>.app.account_ring, partition, <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">                              path, [headers] * <span class="built_in">len</span>(nodes))</span><br><span class="line">    <span class="keyword">if</span> is_success(resp.status_int):</span><br><span class="line">        <span class="variable language_">self</span>.app.logger.info(<span class="string">&#x27;autocreate account %r&#x27;</span> % path)</span><br><span class="line">        clear_info_cache(<span class="variable language_">self</span>.app, env, account)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.app.logger.warning(<span class="string">&#x27;Could not autocreate account %r&#x27;</span> % path)</span><br></pre></td></tr></table></figure>  
<ul>
<li>发起一个PUT请求自动创建account，创建失败记录警告信息。</li>
</ul>
<h3 id="GETorHEAD-base"><a href="#GETorHEAD-base" class="headerlink" title="GETorHEAD_base"></a>GETorHEAD_base</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GETorHEAD_base</span>(<span class="params">self, req, server_type, ring, partition, path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Base handler for HTTP GET or HEAD requests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param req: swob.Request object</span></span><br><span class="line"><span class="string">    :param server_type: server type used in logging</span></span><br><span class="line"><span class="string">    :param ring: the ring to obtain nodes from</span></span><br><span class="line"><span class="string">    :param partition: partition</span></span><br><span class="line"><span class="string">    :param path: path for the request</span></span><br><span class="line"><span class="string">    :returns: swob.Response object</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    backend_headers = <span class="variable language_">self</span>.generate_request_headers(</span><br><span class="line">        req, additional=req.headers)</span><br><span class="line"></span><br><span class="line">    handler = GetOrHeadHandler(<span class="variable language_">self</span>.app, req, <span class="variable language_">self</span>.server_type, ring,</span><br><span class="line">                               partition, path, backend_headers)</span><br><span class="line">    res = handler.get_working_response(req)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">        res = <span class="variable language_">self</span>.best_response(</span><br><span class="line">            req, handler.statuses, handler.reasons, handler.bodies,</span><br><span class="line">            <span class="string">&#x27;%s %s&#x27;</span> % (server_type, req.method),</span><br><span class="line">            headers=handler.source_headers)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (vrs, account, container) = req.split_path(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        _set_info_cache(<span class="variable language_">self</span>.app, req.environ, account, container, res)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (vrs, account, container, obj) = req.split_path(<span class="number">4</span>, <span class="number">4</span>, <span class="literal">True</span>)</span><br><span class="line">        _set_object_info_cache(<span class="variable language_">self</span>.app, req.environ, account,</span><br><span class="line">                               container, obj, res)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>  
<ul>
<li>基类controller的get或head请求处理方法，首先构造header和handler发起一个http请求。</li>
<li>如果请求没有响应，则调用best_response方法取到response。</li>
<li>如果请求有响应，则根据request分割出account、container和object信息，设置到缓存中，最后返回response。</li>
</ul>
<h3 id="is-origin-allowed"><a href="#is-origin-allowed" class="headerlink" title="is_origin_allowed"></a>is_origin_allowed</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_origin_allowed</span>(<span class="params">self, cors_info, origin</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Is the given Origin allowed to make requests to this resource</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param cors_info: the resource&#x27;s CORS related metadata headers</span></span><br><span class="line"><span class="string">    :param origin: the origin making the request</span></span><br><span class="line"><span class="string">    :return: True or False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    allowed_origins = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">if</span> cors_info.get(<span class="string">&#x27;allow_origin&#x27;</span>):</span><br><span class="line">        allowed_origins.update(</span><br><span class="line">            [a.strip()</span><br><span class="line">             <span class="keyword">for</span> a <span class="keyword">in</span> cors_info[<span class="string">&#x27;allow_origin&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">             <span class="keyword">if</span> a.strip()])</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.app.cors_allow_origin:</span><br><span class="line">        allowed_origins.update(<span class="variable language_">self</span>.app.cors_allow_origin)</span><br><span class="line">    <span class="keyword">return</span> origin <span class="keyword">in</span> allowed_origins <span class="keyword">or</span> <span class="string">&#x27;*&#x27;</span> <span class="keyword">in</span> allowed_origins</span><br></pre></td></tr></table></figure>  
<ul>
<li>判断该请求方法是否允许发起请求，先从header中获取’allow_origin’的值，如果有的花，更新允许访问列表。</li>
<li>如果原请求方法在允许访问列表中，或者允许访问列表中有’*’，则返回True。</li>
</ul>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@public</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OPTIONS</span>(<span class="params">self, req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Base handler for OPTIONS requests</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param req: swob.Request object</span></span><br><span class="line"><span class="string">    :returns: swob.Response object</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Prepare the default response</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Allow&#x27;</span>: <span class="string">&#x27;, &#x27;</span>.join(<span class="variable language_">self</span>.allowed_methods)&#125;</span><br><span class="line">    resp = Response(status=<span class="number">200</span>, request=req, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If this isn&#x27;t a CORS pre-flight request then return now</span></span><br><span class="line">    req_origin_value = req.headers.get(<span class="string">&#x27;Origin&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> req_origin_value:</span><br><span class="line">        <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>  
<ul>
<li>options请求的基本handler，准备一个默认的response，如果不是一个CORS请求，则返回默认的response。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a CORS preflight request so check it&#x27;s allowed</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    container_info = \</span><br><span class="line">        <span class="variable language_">self</span>.container_info(<span class="variable language_">self</span>.account_name,</span><br><span class="line">                            <span class="variable language_">self</span>.container_name, req)</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="comment"># This should only happen for requests to the Account. A future</span></span><br><span class="line">    <span class="comment"># change could allow CORS requests to the Account level as well.</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line">cors = container_info.get(<span class="string">&#x27;cors&#x27;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># If the CORS origin isn&#x27;t allowed return a 401</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_origin_allowed(cors, req_origin_value) <span class="keyword">or</span> (</span><br><span class="line">        req.headers.get(<span class="string">&#x27;Access-Control-Request-Method&#x27;</span>) <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">        <span class="variable language_">self</span>.allowed_methods):</span><br><span class="line">    resp.status = HTTP_UNAUTHORIZED</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>  
<ul>
<li>如果对account进行操作的CORS请求，则返回默认reponse，否则获取container信息。</li>
<li>如果CORS请求不允许，则返回401。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow all headers requested in the request. The CORS</span></span><br><span class="line"><span class="comment"># specification does leave the door open for this, as mentioned in</span></span><br><span class="line"><span class="comment"># http://www.w3.org/TR/cors/#resource-preflight-requests</span></span><br><span class="line"><span class="comment"># Note: Since the list of headers can be unbounded</span></span><br><span class="line"><span class="comment"># simply returning headers can be enough.</span></span><br><span class="line">allow_headers = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">if</span> req.headers.get(<span class="string">&#x27;Access-Control-Request-Headers&#x27;</span>):</span><br><span class="line">    allow_headers.update(</span><br><span class="line">        list_from_csv(req.headers[<span class="string">&#x27;Access-Control-Request-Headers&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Populate the response with the CORS preflight headers</span></span><br><span class="line"><span class="keyword">if</span> cors.get(<span class="string">&#x27;allow_origin&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip() == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    headers[<span class="string">&#x27;access-control-allow-origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    headers[<span class="string">&#x27;access-control-allow-origin&#x27;</span>] = req_origin_value</span><br><span class="line"><span class="keyword">if</span> cors.get(<span class="string">&#x27;max_age&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    headers[<span class="string">&#x27;access-control-max-age&#x27;</span>] = cors.get(<span class="string">&#x27;max_age&#x27;</span>)</span><br><span class="line">headers[<span class="string">&#x27;access-control-allow-methods&#x27;</span>] = \</span><br><span class="line">    <span class="string">&#x27;, &#x27;</span>.join(<span class="variable language_">self</span>.allowed_methods)</span><br><span class="line"><span class="keyword">if</span> allow_headers:</span><br><span class="line">    headers[<span class="string">&#x27;access-control-allow-headers&#x27;</span>] = <span class="string">&#x27;, &#x27;</span>.join(allow_headers)</span><br><span class="line">resp.headers = headers</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>  
<ul>
<li>在response的header中增加相关header，分别有’access-control-allow-origin’,’access-control-max-age’,’access-control-allow-methods’和’access-control-allow-headers’。</li>
</ul>
</div>

</article>
<section id="appreciates">
  <center>
	<h2>赞赏</h2>
    <div class="post-footer">
      <div>
	    <h4>如果文章对您有所帮助，可以捐赠我喝杯咖啡😌，捐赠方式：</h4>
        <div class="digital-wallet">
          <h6>BTC 地址：3LYgSyf7ddMALwGWPQr3PY4wzjsTDdg1oV</h6>
          <h6>ETH 地址：0x0C9b27c89A61aadb0aEC24CA8949910Cbf77Aa73</h6>
        </div>
        <div class="wechat_appreciates">
          <img src="/images/wechat_appreciates.png" alt="qrcode" width="250" >
        </div>
      </div>
      <div>
	    <h4>文章已同步更新公众号，欢迎关注</h4>
        <div class="wechat_appreciates">
          <img src="/images/wxgzh_qrcode.jpg" alt="qrcode" width="250" >
        </div>
      </div>
    </div>
  </center>
</section>



    
      <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = 'https://zhaozhiming.github.io/2014/05/04/swift-code-explain-3-proxy-controllers-base/';
            this.page.identifier = 'https://zhaozhiming.github.io/2014/05/04/swift-code-explain-3-proxy-controllers-base/';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//zhaozhiming.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

</div>

    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2025

    赵芝明
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5608723650603289" crossorigin="anonymous"></script>
</body>
</html>
