<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>LangChain Agent 原理解析 - Hacker and Geeker&#39;s Way</title>
    <meta name="author" content="">
    
	<meta name="description" content="LangChain Agent 原理解析"> <!-- TODO: truncate -->
	<meta name="keywords" content="langchain, agent">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Hacker and Geeker&#39;s Way" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='/stylesheets/font.css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Amethysta+One' rel='stylesheet' type='text/css'>
	  <script src="/javascripts/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-100485541-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Hacker and Geeker&#39;s Way
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  <!-- GitHub -->
  <li>
  <a target="_blank" rel="noopener" href="https://github.com/zhaozhiming" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.twitter.com/kingzzm" class="twitter" title="Twitter"></a>
  </li>
  
  
  <!-- LinkedIn -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.linkedin.com/in/zhaozhiming" class="linkedin" title="LinkedIn"></a>
  </li>
  
  
  
  
  
  <!-- Stackoverflow -->
  <li>
  <a target="_blank" rel="noopener" href="http://stackoverflow.com/users/1954315/zhaozhiming" class="stackoverflow" title="Stackoverflow"></a>
  </li>
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about/index.html">About</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://zhaozhiming.github.io" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>


<div id="toload">
<!-- begin toload -->
    <div id="content">
        <div class="inner">
<article class="post">
	<h2 class="title">LangChain Agent 原理解析</h2>
    <div class="meta">
        <div class="date">Published on: <time datetime="2023-09-06T11:53:31.000Z" itemprop="datePublished">9月 6, 2023</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/langchain/">langchain</a> <a href="/tags/agent/">agent</a>
</div>
    </div>
	<div class="entry-content"><img src="/images/post/2023/09/langchain-agent.png" class="" width="400" height="300">

<p>LangChain 是一个基于 LLM（大型语言模型）的编程框架，旨在帮助开发人员使用 LLM 构建端到端的应用程序。它提供了一套工具、组件和接口，可以简化创建由 LLM 和聊天模型提供支持的应用程序的过程。LangChain 由几大组件构成，包括 Models，Prompts，Chains，Memory 和 Agent 等，而 Agent 是其中重要的组成部分，如果把 LLM 比做大脑的话，那 Agent 就是给大脑加上手和脚。今天就来带大家重点了解一下 Agent 以及它的工作原理。</p>
<span id="more"></span>

<h2 id="什么是-LangChain-Agent"><a href="#什么是-LangChain-Agent" class="headerlink" title="什么是 LangChain Agent"></a>什么是 LangChain Agent</h2><p>在 LangChain 中，Agent 是一个代理，接收用户的输入，采取相应的行动然后返回行动的结果。 Agent 可以看作是一个自带路由消费 Chains 的代理，基于 MRKL 和 ReAct 的基本原理，Agent 可以使用工具和自然语言处理问题。官方也提供了对应的 Agent，包括 OpenAI Functions Agent、Plan-and-execute Agent、Self Ask With Search 类 AutoGPT 的 Agent 等。 Agent 的作用是代表用户或其他系统完成任务，例如数据收集、数据处理、决策支持等。 Agent 可以是自主的，具备一定程度的智能和自适应性，以便在不同的情境中执行任务。我们今天主要了解基于 <strong>ReAct</strong> 原理来实现的 Agent。</p>
<h2 id="ReAct"><a href="#ReAct" class="headerlink" title="ReAct"></a>ReAct</h2><p>ReAct 是一个结合了推理和行动的语言模型。虽然 LLM 在语言理解和交互决策制定方面展现出了令人印象深刻的能力，但它们的推理（例如链式思考提示）和行动（例如行动计划生成）的能力主要被视为两个独立的主题。ReAct 的目标是探索如何使用 LLM 以交错的方式生成推理痕迹和特定任务的行动，从而在两者之间实现更大的协同作用。</p>
<p>想象一下，你有一个智能助手机器人，名叫小明。你给小明一个任务：去厨房为你做一杯咖啡。小明不仅要完成这个任务，还要告诉你他是如何一步步完成的。</p>
<p><strong>没有 ReAct 的小明：</strong></p>
<ol>
<li>小明直接跑到厨房。</li>
<li>你听到了一些声音，但不知道小明在做什么。</li>
<li>过了一会儿，小明回来给你一杯咖啡。</li>
</ol>
<p>这样的问题是，你不知道小明是怎么做咖啡的，他是否加了糖或奶，或者他是否在过程中遇到了任何问题。</p>
<p><strong>有 ReAct 的小明：</strong></p>
<ol>
<li>小明告诉你：“我现在去厨房。”</li>
<li>小明再说：“我找到了咖啡粉和咖啡机。”</li>
<li>“我现在开始煮咖啡。”</li>
<li>“咖啡煮好了，我要加点糖和奶。”</li>
<li>“好了，咖啡做好了，我现在给你拿过去。”</li>
</ol>
<p>这次，你完全知道小明是怎么做咖啡的，知道他的每一个步骤和决策。</p>
<p>ReAct 就是这样的原理。它不仅执行任务（行动），还会告诉你它是如何思考和决策的（推理）。这样，你不仅知道任务完成了，还知道为什么这样做，如果有问题，也更容易找出原因。</p>
<p>更多关于 ReAct 的内容可以查看<a target="_blank" rel="noopener" href="https://react-lm.github.io/">这篇文章</a>。</p>
<h2 id="自定义-LLM-Agent"><a href="#自定义-LLM-Agent" class="headerlink" title="自定义 LLM Agent"></a>自定义 LLM Agent</h2><p>LangChain 在官方网站上提供了关于如何<a target="_blank" rel="noopener" href="https://python.langchain.com/docs/modules/agents/how_to/custom_llm_agent">创建自定义 LLM Agent</a>的例子，在官网的示例中，我们除了看到自定义 LLM Agent 外，还有一个自定义 Agent，这两者的区别就是自定义 LLM Agent 使用了 LLM 来解析用户输入，判断使用何种工具，而自定义 Agent 则是直接自行判断工具的使用，这种方式只能用于简单的场景，而自定义 LLM Agent 可以用于更复杂的场景。</p>
<p>在官方示例中，对其实现原理做了一些简单的描述，介绍了其组成部分和流程等，但如果是刚开始了解 Agent 的同学看起来可能会一知半解，所以我们今天主要结合其中的示例代码来了解自定义 LLM Agent 的实现原理。</p>
<h2 id="提示词模板"><a href="#提示词模板" class="headerlink" title="提示词模板"></a>提示词模板</h2><p>要实现 Agent，我们需要先定义一套基于 ReAct 的提示词模板，示例中的 Agent 就是基于 ReAct 原理来实现的，为了方便理解，我们将官方的英文提示词模板换成中文和去掉一些没必要的内容，修改后的提示词模板内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">&quot;&quot;&quot;尽你所能回答以下问题，你可以使用以下工具：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;tools&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请按照以下格式：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题：你必须回答的输入问题</span></span><br><span class="line"><span class="string">思考：你应该始终考虑该怎么做</span></span><br><span class="line"><span class="string">行动：要采取的行动，应该是[&#123;tool_names&#125;]中的一个</span></span><br><span class="line"><span class="string">行动输入：行动的输入</span></span><br><span class="line"><span class="string">观察：行动的结果</span></span><br><span class="line"><span class="string"><span class="meta">... </span>(这个思考/行动/行动输入/观察可以重复N次)</span></span><br><span class="line"><span class="string">思考：我现在知道最终答案了</span></span><br><span class="line"><span class="string">最终答案：对原始输入问题的最终答案</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">开始吧！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题：&#123;input&#125;</span></span><br><span class="line"><span class="string">&#123;agent_scratchpad&#125;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>简单介绍一下这个提示词模板，首先提示词模板中会引用到一些工具，可以看到模板中有 2 个变量：<code>tools</code>和<code>tool_names</code>，tools 变量是一个列表，包含了所有的工具，列表中的每个元素包含了工具的名称和描述，而 tool_names 变量是工具名称的列表，传入具体的工具后，会生成对应的工具列表，比如我们有如下 2 个工具，解析后如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">尽你所能回答以下问题，你可以使用以下工具：</span><br><span class="line"></span><br><span class="line">search: 实时联网搜索的工具</span><br><span class="line">math: 数学计算的工具</span><br><span class="line"></span><br><span class="line">请按照以下格式：</span><br><span class="line">......</span><br><span class="line">行动：要采取的行动，应该是[search, math]中的一个</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这样 LLM 在执行任务时就知道要使用哪些工具，以及在提取信息时可以提取到正确的工具名。</p>
<p>模板中下面的<code>思考/行动/行动输入/观察</code>就是标准的 ReAct 流程，思考是指思考如何解决问题，行动是具体的工具，行动输入是工具用到的参数，观察是工具执行完成后得到的结果，这个流程可以重复多次，直到最终得到最终答案。</p>
<p>模板最后还有 2 个变量：<code>input</code>和<code>agent_scratchpad</code>，input 是用户输入的问题，agent_scratchpad 是之前的思考过程（下面解析代码时会讲），包括了思考、行动、行动输入和观察等，这个变量在 Agent 执行过程中会被更新，代入具体的值后，模板会生成如下的提示词：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">问题：北京的天气怎么样</span><br><span class="line">思考: 我们需要通过 search 工具查找北京天气。</span><br><span class="line">行动: search</span><br><span class="line">行动输入: <span class="string">&quot;北京天气&quot;</span></span><br><span class="line">观察: 6日（今天）. 多云转晴. 32/22℃. &lt;3级</span><br><span class="line">思考:</span><br></pre></td></tr></table></figure>

<p>从问题下面一句到最后结束就是<code>agent_scratchpad</code>的值。</p>
<h2 id="构造提示词"><a href="#构造提示词" class="headerlink" title="构造提示词"></a>构造提示词</h2><p>准备好提示词模板后，我们就可以构造提示词了，构造提示词的官方示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set up a prompt template</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPromptTemplate</span>(<span class="title class_ inherited__">StringPromptTemplate</span>):</span><br><span class="line">    <span class="comment"># The template to use</span></span><br><span class="line">    template: <span class="built_in">str</span></span><br><span class="line">    <span class="comment"># The list of tools available</span></span><br><span class="line">    tools: <span class="type">List</span>[Tool]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">format</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># Get the intermediate steps (AgentAction, Observation tuples)</span></span><br><span class="line">        <span class="comment"># Format them in a particular way</span></span><br><span class="line">        intermediate_steps = kwargs.pop(<span class="string">&quot;intermediate_steps&quot;</span>)</span><br><span class="line">        thoughts = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> action, observation <span class="keyword">in</span> intermediate_steps:</span><br><span class="line">            thoughts += action.log</span><br><span class="line">            thoughts += <span class="string">f&quot;\nObservation: <span class="subst">&#123;observation&#125;</span>\nThought: &quot;</span></span><br><span class="line">        <span class="comment"># Set the agent_scratchpad variable to that value</span></span><br><span class="line">        kwargs[<span class="string">&quot;agent_scratchpad&quot;</span>] = thoughts</span><br><span class="line">        <span class="comment"># Create a tools variable from the list of tools provided</span></span><br><span class="line">        kwargs[<span class="string">&quot;tools&quot;</span>] = <span class="string">&quot;\n&quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;tool.name&#125;</span>: <span class="subst">&#123;tool.description&#125;</span>&quot;</span> <span class="keyword">for</span> tool <span class="keyword">in</span> <span class="variable language_">self</span>.tools])</span><br><span class="line">        <span class="comment"># Create a list of tool names for the tools provided</span></span><br><span class="line">        kwargs[<span class="string">&quot;tool_names&quot;</span>] = <span class="string">&quot;, &quot;</span>.join([tool.name <span class="keyword">for</span> tool <span class="keyword">in</span> <span class="variable language_">self</span>.tools])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.template.<span class="built_in">format</span>(**kwargs)</span><br><span class="line"></span><br><span class="line">prompt = CustomPromptTemplate(</span><br><span class="line">    template=template,</span><br><span class="line">    tools=tools,</span><br><span class="line">    <span class="comment"># This omits the `agent_scratchpad`, `tools`, and `tool_names` variables because those are generated dynamically</span></span><br><span class="line">    <span class="comment"># This includes the `intermediate_steps` variable because that is needed</span></span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>, <span class="string">&quot;intermediate_steps&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>首先我们需要定义一个类，继承自<code>StringPromptTemplate</code>，然后实现<code>format</code>方法，这个方法的作用是将提示词模板中的变量代入具体的值，然后返回提示词。其中<code>intermediate_steps</code>是中间 Agent 思考的步骤，每个步骤是一个元组，包含了<code>AgentAction</code>（行为和行为输入）和<code>Observation</code>（观察）的值，这个变量不会直接传递到 LLM，所以它不会在提示词中出现，但提示词模板会将它转换为<code>agent_scratchpad</code>变量，这个变量也就是我们在上面提到的<code>agent_scratchpad</code>，这个变量的值是 Agent 思考的过程，包括了思考、行动、行动输入和观察等。</p>
<p>format 方法最后会设置模板中的<code>tools</code>和<code>tool_names</code>变量，这两个变量的值是提示词模板中的工具列表，这个列表是根据<code>tools</code>变量生成的，包含了所有的工具，列表中的每个元素包含了工具的名称和描述，而<code>tool_names</code>变量是工具名称的列表。</p>
<p>最后我们需要创建一个<code>CustomPromptTemplate</code>对象，传入提示词模板和工具列表，这个对象就是我们最终要传入 LLM 的提示词。</p>
<h2 id="工具解析"><a href="#工具解析" class="headerlink" title="工具解析"></a>工具解析</h2><p>接下来是输出结果的解析，其中分为 2 个部分，一个是工具的解析，一个是结果的解析，我们来看下官方的示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomOutputParser</span>(<span class="title class_ inherited__">AgentOutputParser</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, llm_output: <span class="built_in">str</span></span>) -&gt; <span class="type">Union</span>[AgentAction, AgentFinish]:</span><br><span class="line">        <span class="comment"># 暂时不看结果解析的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Parse out the action and action input</span></span><br><span class="line">        regex = <span class="string">r&quot;Action\s*\d*\s*:(.*?)\nAction\s*\d*\s*Input\s*\d*\s*:[\s]*(.*)&quot;</span></span><br><span class="line">        <span class="keyword">match</span> = re.search(regex, llm_output, re.DOTALL)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">            <span class="keyword">raise</span> OutputParserException(<span class="string">f&quot;Could not parse LLM output: `<span class="subst">&#123;llm_output&#125;</span>`&quot;</span>)</span><br><span class="line">        action = <span class="keyword">match</span>.group(<span class="number">1</span>).strip()</span><br><span class="line">        action_input = <span class="keyword">match</span>.group(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># Return the action and action input</span></span><br><span class="line">        <span class="keyword">return</span> AgentAction(tool=action, tool_input=action_input.strip(<span class="string">&quot; &quot;</span>).strip(<span class="string">&#x27;&quot;&#x27;</span>), log=llm_output)</span><br></pre></td></tr></table></figure>

<p><code>parse</code> 方法前半部分是关于结果解析的，我们待会再讲，我们先看后面的代码，这是对工具的解析。</p>
<p>代码使用了一个正则表达式来解析 LLM 关于思考过程的输出结果，一般思考过程的输出结果是这样的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思考: 我们需要通过 search 工具查找北京天气。</span><br><span class="line">行动: search</span><br><span class="line">行动输入: <span class="string">&quot;北京天气&quot;</span></span><br></pre></td></tr></table></figure>

<p>根据我们的提示词模板，LLM 会智能地返回我们制定好的格式，有思考、行动、行动输入几项内容，我们主要通过这个正则表达式来获取到<code>行动</code>和<code>行动输入</code>这两项的值（也就是工具名称和工具所需参数），这样 Agent 就知道该如何使用工具了。可以看到代码中 action（工具）获取的是正则结果中的第一个分组的值，而 action_input（工具参数）获取的是第二个分组的值。最后将这 2 个值封装成一个 AgentAction 对象返回。</p>
<p>但需要注意的是，虽然我们设置好了提示词模板，但如果 LLM 不够<strong>智能</strong>的话，返回的结果可能会和我们预期的不一样，比如 LLM 可能返回这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思考: 我们需要通过 search 工具查找北京天气。</span><br><span class="line">行动: 我需要使用search工具来查询</span><br><span class="line">行动输入: <span class="string">&quot;北京天气&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到行动的值不是我们预期的 search，而是一句话，这样通过正则表达式获取的工具名就是<code>我需要使用search工具来查询</code>，然后 Agent 会拿这个工具名去匹配工具，然后去调用，发现没有这个工具，就会报错。所以如果我们发现 LLM 有时候返回的结果不符合我们预期时，我们需要通过其他方式来解析出工具的名称，比如去掉一些无用的内容，只保留工具名称，这样才能保证 Agent 能够正常使用工具。</p>
<h2 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析"></a>结果解析</h2><p>我们再说下结果的解析，就是上面代码中 <code>parse</code>方法的前半部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomOutputParser</span>(<span class="title class_ inherited__">AgentOutputParser</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, llm_output: <span class="built_in">str</span></span>) -&gt; <span class="type">Union</span>[AgentAction, AgentFinish]:</span><br><span class="line">        <span class="comment"># Check if Agent should finish</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Final Answer:&quot;</span> <span class="keyword">in</span> llm_output:</span><br><span class="line">            <span class="keyword">return</span> AgentFinish(</span><br><span class="line">                <span class="comment"># Return values is generally always a dictionary with a single `output` key</span></span><br><span class="line">                <span class="comment"># It is not recommended to try anything else at the moment :)</span></span><br><span class="line">                return_values=&#123;<span class="string">&quot;output&quot;</span>: llm_output.split(<span class="string">&quot;Final Answer:&quot;</span>)[-<span class="number">1</span>].strip()&#125;,</span><br><span class="line">                log=llm_output,</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>

<p>示例代码中判断 LLM 的输出是否有包含<code>最终答案:</code>，如果有的话，就说明 LLM 已经得到了最终的答案，这时就可以返回最终的答案了，这个格式也是我们在提示词模板中定义的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">思考：我现在知道最终答案了</span></span><br><span class="line"><span class="string">最终答案：对原始输入问题的最终答案</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个最终的答案是 LLM 输出结果中的最后一句话，我们可以通过<code>split</code>方法来获取到最后一句话，然后返回一个<code>ActionFinish</code>对象，这个对象包含了最终的答案，解析出来的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思考过程</span></span><br><span class="line">思考：我现在知道最终答案了</span><br><span class="line">最终答案: 北京的天气情况如下：6日（今天）多云转晴，温度在32/22℃，风力小于3级</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终结果</span></span><br><span class="line">北京的天气情况如下：6日（今天）多云转晴，温度在32/22℃，风力小于3级</span><br></pre></td></tr></table></figure>

<p>跟工具解析一样，我们在结果解析时也需要注意 LLM 返回的结果是否符合我们预期，比如有时候 LLM 会输出这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思考：我现在知道最终答案了</span><br><span class="line">北京的天气情况如下：6日（今天）多云转晴，温度在32/22℃，风力小于3级</span><br></pre></td></tr></table></figure>

<p>可以看到 LLM 的输出没有包含<code>最终结果:</code>关键字，这样示例代码中的 if 逻辑就不生效了，会导致解析逻辑进到工具解析那一部分去，然后引发错误。所以我们在解析结果时，要提高我们解析程序的健壮性，以满足不同的 LLM 输出结果，或者调整我们的提示词模板，让 LLM 返回的结果更加准确。</p>
<h2 id="中断提示"><a href="#中断提示" class="headerlink" title="中断提示"></a>中断提示</h2><p>最后一步是创建 Agent，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">llm = OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># LLM chain consisting of the LLM and a prompt</span></span><br><span class="line">llm_chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line"></span><br><span class="line">tool_names = [tool.name <span class="keyword">for</span> tool <span class="keyword">in</span> tools]</span><br><span class="line">agent = LLMSingleActionAgent(</span><br><span class="line">    llm_chain=llm_chain,</span><br><span class="line">    output_parser=output_parser,</span><br><span class="line">    stop=[<span class="string">&quot;\nObservation:&quot;</span>],</span><br><span class="line">    allowed_tools=tool_names</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里重点关注的是 Agent 中的<code>stop</code>参数，我们知道一般 LLM 都会长篇大论，说一大堆废话，我们希望 LLM 在返回了我们需要的信息后就停止输出，这里就需要用到<code>stop</code>参数，这个参数是一个列表，列表中的每个元素都是一个字符串，代表了 LLM 输出中的某一句话，当 LLM 输出中包含了这句话时，LLM 就会停止输出，这样我们就可以只获取到我们需要的信息了，这里我们使用<code>观察</code>关键字来停止 LLM 的输出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自定义 LLM Agent 的示例代码我们已经介绍完了，最后我们再讲下来 Agent 中使用的 LLM。在官方示例中，LLM 用的是 OpenAI，也就是<code>gpt-3.5</code>这个模型，但如果想达到更好的效果的话，推荐使用 OpenAI 的<code>gpt-4</code>模型，它是目前最好的 LLM，如果使用的 LLM 比较差，就容易出现刚才我们提到 LLM 返回的结果不符合我们预期的情况。</p>
<p>有人希望通过一些开源的 LLM 来实现 ReAct Agent，但实际开发过程中会发现开源低参数（比如一些 6B、7B 的 LLM）的 LLM 对于提示词的理解会非常差，根本不会按照提示词模板的格式来输出，这样就会导致我们的 Agent 无法正常工作，所以如果想要实现一个好的 Agent，还是需要使用好的 LLM，目前看来使用<code>gpt-3.5</code>模型是最低要求。</p>
<p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>
</div>

</article>
<section id="appreciates">
  <center>
	<h2>赞赏</h2>
    <div class="post-footer">
      <div>
	    <h4>如果文章对您有所帮助，可以捐赠我喝杯咖啡😌，捐赠方式：</h4>
        <div class="digital-wallet">
          <h6>BTC 地址：3LYgSyf7ddMALwGWPQr3PY4wzjsTDdg1oV</h6>
          <h6>ETH 地址：0x0C9b27c89A61aadb0aEC24CA8949910Cbf77Aa73</h6>
        </div>
        <div class="wechat_appreciates">
          <img src="/images/wechat_appreciates.png" alt="qrcode" width="250" >
        </div>
      </div>
      <div>
	    <h4>文章已同步更新公众号，欢迎关注</h4>
        <div class="wechat_appreciates">
          <img src="/images/wxgzh_qrcode.jpg" alt="qrcode" width="250" >
        </div>
      </div>
    </div>
  </center>
</section>



    
      <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = 'https://zhaozhiming.github.io/2023/09/06/langchain-agent-implementation-principle/';
            this.page.identifier = 'https://zhaozhiming.github.io/2023/09/06/langchain-agent-implementation-principle/';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//zhaozhiming.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

</div>

    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2024

    赵芝明
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5608723650603289" crossorigin="anonymous"></script>
</body>
</html>
