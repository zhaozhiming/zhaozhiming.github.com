<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>高级 RAG 检索策略之查询路由 - Hacker and Geeker&#39;s Way</title>
    <meta name="author" content="">
    
	<meta name="description" content="介绍 RAG 检索策略中的查询路由，以及如何在检索时使用"> <!-- TODO: truncate -->
	<meta name="keywords" content="rag, llamaindex, router, semantic-router">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Hacker and Geeker&#39;s Way" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='/stylesheets/font.css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Amethysta+One' rel='stylesheet' type='text/css'>
	  <script src="/javascripts/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-100485541-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Hacker and Geeker&#39;s Way
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  <!-- GitHub -->
  <li>
  <a target="_blank" rel="noopener" href="https://github.com/zhaozhiming" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.twitter.com/kingzzm" class="twitter" title="Twitter"></a>
  </li>
  
  
  <!-- LinkedIn -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.linkedin.com/in/zhaozhiming" class="linkedin" title="LinkedIn"></a>
  </li>
  
  
  
  
  
  <!-- Stackoverflow -->
  <li>
  <a target="_blank" rel="noopener" href="http://stackoverflow.com/users/1954315/zhaozhiming" class="stackoverflow" title="Stackoverflow"></a>
  </li>
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about/index.html">About</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://zhaozhiming.github.io" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>


<div id="toload">
<!-- begin toload -->
    <div id="content">
        <div class="inner">
<article class="post">
	<h2 class="title">高级 RAG 检索策略之查询路由</h2>
    <div class="meta">
        <div class="date">Published on: <time datetime="2024-08-06T01:10:16.000Z" itemprop="datePublished">8月 6, 2024</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/llamaindex/">llamaindex</a> <a href="/tags/rag/">rag</a> <a href="/tags/router/">router</a> <a href="/tags/semantic-router/">semantic-router</a>
</div>
    </div>
	<div class="entry-content"><img src="/images/post/2024/08/rag-query-router.jpg" class="" width="400" height="300">

<p>之前介绍 Self-RAG 的时候提到了其中的按需检索功能，就是根据用户的问题来判断是否需要进行文档检索，如果不需要检索的话则直接返回 LLM（大语言模型）生成的结果，这样不仅可以提升系统的性能，还可以提高用户的体验。在 Self-RAG 中按需检索是通过特殊训练后的 LLM 来实现的，但是在高级 RAG（Retrieval Augmented Generation）检索中我们可以使用<strong>查询路由</strong>来实现这个功能，借助查询路由我们可以轻松实现类似代码中的 If&#x2F;Else 功能。今天我们就来介绍查询路由的原理以及实现方式，并通过代码示例来了解查询路由在实际项目中的使用。</p>
<span id="more"></span>

<h2 id="查询路由"><a href="#查询路由" class="headerlink" title="查询路由"></a>查询路由</h2><p>查询路由是 RAG 中的一种智能查询分发功能，能够根据用户输入的语义内容，从多个选项中选择最合适的处理方式或数据源。查询路由能够显著提高 RAG 检索的相关性和效率，适用于各种复杂的信息检索场景，如将用户查询分发到不同的知识库。查询路由的灵活性和智能性使其成为构建高效 RAG 系统的关键组件。</p>
<img src="/images/post/2024/08/rag-router-flow.png" class="" width="1000" height="600">

<h3 id="查询路由的类型"><a href="#查询路由的类型" class="headerlink" title="查询路由的类型"></a>查询路由的类型</h3><p>根据查询路由的实现原理我们可以将其分为两种类型：</p>
<ul>
<li>LLM Router：通过构建有效的提示词来让 LLM 判断用户问题的意图，现有的实现有 LlamaIndex Router 等。</li>
<li>Embedding Router: 通过 Embedding 模型将用户问题转为向量，然后通过相似性检索来判断用户问题的意图，现有的实现有 Semantic Router 等。</li>
</ul>
<p>下面我们就来了解这两种查询路由具体的实现原理。</p>
<h2 id="LLM-Router"><a href="#LLM-Router" class="headerlink" title="LLM Router"></a>LLM Router</h2><p>使用 LLM 来判断用户的意图目前是 RAG 中一种常见的路由方法，首先在提示词中列出问题的所有类别，然后让 LLM 将问题进行分类，最后根据分类结果来选择相应的处理方式。</p>
<p>LLM 应用框架 <a target="_blank" rel="noopener" href="https://www.llamaindex.ai/">LlamaIndex</a> 使用的就是 LLM Router。在 LlamaIndex 中有几种查询路由的实现，比如路由检索器 <code>RouterRetriever</code>、路由查询引擎 <code>RouterQueryEngine</code>、流水线路由模块 <code>RouterComponent</code>，它们的实现原理基本一致，初始化时需要一个选择器和一个工具组件列表，通过选择器来得到工具组件序号，然后根据序号来选择相应的工具组件，最后执行工具组件的处理逻辑。以 <code>RouterQueryEngine</code> 为例，其示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> RouterQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.core.selectors <span class="keyword">import</span> LLMSingleSelector</span><br><span class="line"><span class="keyword">from</span> llama_index.core.tools <span class="keyword">import</span> QueryEngineTool</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize tools</span></span><br><span class="line">list_tool = QueryEngineTool.from_defaults(</span><br><span class="line">    query_engine=list_query_engine,</span><br><span class="line">    description=<span class="string">&quot;Useful for summarization questions related to the data source&quot;</span>,</span><br><span class="line">)</span><br><span class="line">vector_tool = QueryEngineTool.from_defaults(</span><br><span class="line">    query_engine=vector_query_engine,</span><br><span class="line">    description=<span class="string">&quot;Useful for retrieving specific context related to the data source&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize router query engine (single selection, llm)</span></span><br><span class="line">query_engine = RouterQueryEngine(</span><br><span class="line">    selector=LLMSingleSelector.from_defaults(),</span><br><span class="line">    query_engine_tools=[</span><br><span class="line">        list_tool,</span><br><span class="line">        vector_tool,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line">query_engine.query(<span class="string">&quot;&lt;query&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>首先我们构建 2 个工具 <code>list_tool</code> 和 <code>vector_tool</code>，分别用于总结问题和向量查询，<code>list_tool</code>使用 <code>SummaryIndex</code>来构建检索引擎，<code>vector_tool</code>使用 <code>VectorStoreIndex</code> 来构建检索引擎</li>
<li>然后初始化 <code>RouterQueryEngine</code>，传入选择器和工具列表</li>
<li>这里的选择器是 <code>LLMSingleSelector</code>，该选择器使用 LLM 判断用户问题意图并返回单个选择结果</li>
<li>最后调用 <code>query_engine.query</code> 方法传入用户问题，<code>RouterQueryEngine</code> 根据问题选择相应的工具并执行</li>
</ul>
<p>下面是 LlamaIndex Router 的流程图：</p>
<img src="/images/post/2024/08/llamaindex-router-flow.png" class="" width="400" height="600">

<ul>
<li>首先选择器根据用户问题得到选择结果</li>
<li>对选择结果进行数据提取，得到工具组件序号</li>
<li>根据序号选择工具列表中的组件并执行</li>
</ul>
<p>在 LlamaIndex 中选择器有 4 种，如下图所示：</p>
<img src="/images/post/2024/08/llamaindex-selector.png" class="" width="1000" height="600">

<p>这 4 种选择器都是通过 LLM 来判断用户问题的意图，按选择结果可以分为单个结果选择器和多个结果选择器，单个结果选择器只返回一个选择结果，多个结果选择器返回多个选择结果，然后会将多个结果合并为一个最终结果。</p>
<p>按解析结果可以分为文本结果选择器和对象结果选择器，文本结果选择器使用的是 LLM 的 completion API 来生成文本类型的选择结果，格式为：<code>&lt;index&gt;. &lt;reason&gt;</code>，<code>index</code>为选择结果的序号，<code>reason</code>为选择结果的原因。对象结果选择器使用的是 LLM 的 Function Calling API，将选择结果解析成一个 Python 对象，默认的对象为 <code>SingleSelection</code>，其定义如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleSelection</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A single selection of a choice.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    index: <span class="built_in">int</span></span><br><span class="line">    reason: <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<p>2 种解析结果示例如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Text selector</span></span><br><span class="line">2. Useful <span class="keyword">for</span> questions related to oranges</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object selector</span></span><br><span class="line">SingleSelection(index=2, reason=<span class="string">&quot;Useful for questions related to oranges&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用文本结果选择器得到选择结果后，还需要进行额外处理，比如提取出结果中的序号，而使用对象结果选择器则不需要额外处理，可以直接使用对象的属性得到结果。</p>
<p>我们再来看下选择器的提示词模板：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_SINGLE_SELECT_PROMPT_TMPL = (</span><br><span class="line">    <span class="string">&quot;Some choices are given below. It is provided in a numbered list &quot;</span></span><br><span class="line">    <span class="string">&quot;(1 to &#123;num_choices&#125;), &quot;</span></span><br><span class="line">    <span class="string">&quot;where each item in the list corresponds to a summary.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;context_list&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;\n---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Using only the choices above and not prior knowledge, return &quot;</span></span><br><span class="line">    <span class="string">&quot;the choice that is most relevant to the question: &#x27;&#123;query_str&#125;&#x27;\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>这是 <code>LLMSingleSelector</code> 的默认提示词模板</li>
<li><code>&#123;num_choices&#125;</code> 为选择结果的数量</li>
<li><code>&#123;context_list&#125;</code> 为工具组件列表的文本描述，包括序号和描述</li>
<li><code>&#123;query_str&#125;</code> 为用户问题</li>
</ul>
<p>使用 LLM Router 的一个关键就是构建有效的提示词，如果使用的 LLM 足够强大，那么提示词不用很清晰也能达到我们想要的效果，但如果 LLM 不够强大，那么提示词需要不断调整才能得到满意的结果。笔者在使用 LlamaIndex Router 的过程中发现，在选择 OpenAI <code>gpt-3.5-turbo</code> 模型的情况下，使用 <code>LLMSingleSelector</code> 选择器时偶尔会出现解析失败的情况，而使用 <code>PydanticSingleSelector</code> 选择器则比较稳定。</p>
<p>最后得到选择结果的序号后就可以通过该序号来选择工具组件了，下面是 <code>RouterQueryEngine</code> 的代码片段：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RouterQueryEngine</span>(<span class="title class_ inherited__">BaseQueryEngine</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_query</span>(<span class="params">self, query_bundle: QueryBundle</span>) -&gt; RESPONSE_TYPE:</span><br><span class="line">        ......</span><br><span class="line">        result = <span class="variable language_">self</span>._selector.select(<span class="variable language_">self</span>._metadatas, query_bundle)</span><br><span class="line">        selected_query_engine = <span class="variable language_">self</span>._query_engines[result.ind]</span><br><span class="line">        final_response = selected_query_engine.query(query_bundle)</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RouterQueryEngine</code> 的 <code>_query</code> 方法中首先通过选择器得到选择结果</li>
<li>然后根据选择结果的序号在 <code>_query_engines</code> 中选择相应的检索引擎</li>
<li>最后调用检索引擎的 <code>query</code> 方法生成最终结果</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：方法简单，易于实现</li>
<li>缺点：需要一个比较强大的 LLM 才能正确判断用户问题的意图，如果要将选择结果解析为对象还需要 LLM 具备 Function Calling 的能力</li>
</ul>
<h2 id="Embedding-Router"><a href="#Embedding-Router" class="headerlink" title="Embedding Router"></a>Embedding Router</h2><p>查询路由的另外一种实现方式是使用 Embedding 模型将用户问题进行向量化，然后通过向量相似性来将用户问题进行分类，得到分类结果后再选择相应的处理方式。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/aurelio-labs/semantic-router">Semantic Router</a> 是基于该原理实现的一个路由工具，它旨在提供超快的 AI 决策能力，通过语义向量进行快速决策，以提高 LLM 应用和 AI Agent 的效率。 Semantic Router 使用非常简单，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> semantic_router <span class="keyword">import</span> Route</span><br><span class="line"><span class="keyword">from</span> semantic_router.encoders <span class="keyword">import</span> CohereEncoder, OpenAIEncoder</span><br><span class="line"><span class="keyword">from</span> semantic_router.layer <span class="keyword">import</span> RouteLayer</span><br><span class="line"></span><br><span class="line"><span class="comment"># we could use this as a guide for our chatbot to avoid political conversations</span></span><br><span class="line">politics = Route(</span><br><span class="line">    name=<span class="string">&quot;politics&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;isn&#x27;t politics the best thing ever&quot;</span>,</span><br><span class="line">        <span class="string">&quot;why don&#x27;t you tell me about your political opinions&quot;</span>,</span><br><span class="line">        <span class="string">&quot;don&#x27;t you just love the president&quot;</span>,</span><br><span class="line">        <span class="string">&quot;they&#x27;re going to destroy this country!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;they will save the country!&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this could be used as an indicator to our chatbot to switch to a more</span></span><br><span class="line"><span class="comment"># conversational prompt</span></span><br><span class="line">chitchat = Route(</span><br><span class="line">    name=<span class="string">&quot;chitchat&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;how&#x27;s the weather today?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;how are things going?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lovely weather today&quot;</span>,</span><br><span class="line">        <span class="string">&quot;the weather is horrendous&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let&#x27;s go to the chippy&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we place both of our decisions together into single list</span></span><br><span class="line">routes = [politics, chitchat]</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenAI Encoder</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&quot;&lt;YOUR_API_KEY&gt;&quot;</span></span><br><span class="line">encoder = OpenAIEncoder()</span><br><span class="line"></span><br><span class="line">rl = RouteLayer(encoder=encoder, routes=routes)</span><br><span class="line"></span><br><span class="line">rl(<span class="string">&quot;don&#x27;t you love politics?&quot;</span>).name</span><br><span class="line"><span class="comment"># politics</span></span><br><span class="line">rl(<span class="string">&quot;how&#x27;s the weather today?&quot;</span>).name</span><br><span class="line"><span class="comment"># chitchat</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先定义 2 个 Route，分别是 <code>politics</code> 和 <code>chitchat</code>，每个 Route 包含多个示例语句</li>
<li>然后创建一个 Encoder，这里使用的是 OpenAI 的 Encoder，利用 OpenAI 的 Embedding 模型来生成向量</li>
<li>最后创建一个 RouteLayer，传入 Encoder 和 Route 列表</li>
<li>调用 RouteLayer 方法传入用户问题，得到分类结果，<strong>注意</strong>：并不是每一个用户问题都会得到一个预设的分类结果，如果用户问题不在预设的分类中，那么分类结果可能为空</li>
</ul>
<p>OpenAI Encoder 默认使用的是 <code>text-embedding-3-small</code> Embedding 模型，它比 OpenAI 之前的 <code>text-embedding-ada-002</code> Embedding 模型效果更好且价格更便宜。同时 Semantic Router 还支持其他 Encoder，比如 Huggingface Encoder，它默认使用的是 <a target="_blank" rel="noopener" href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2">sentence-transformers&#x2F;all-MiniLM-L6-v2</a> Embedding 模型，这是一个句子转换模型，它将句子和段落映射到一个 384 维度的向量空间，可用于分类或语义搜索等任务。</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：只需要使用 Embedding 模型，相比 LLM Router 效率更高，消耗资源更少</li>
<li>缺点：需要提前录入一些示例语句，如果示例语句不够多或者不够全面，分类效果可能不太好</li>
</ul>
<h2 id="查询路由实践"><a href="#查询路由实践" class="headerlink" title="查询路由实践"></a>查询路由实践</h2><p>下面我们结合 LlamaIndex 和 Semantic Router 来实现一个查询路由，该路由会将用户的问题分发到不同的工具组件中，这些工具组件包括：使用 LLM 和用户进行闲聊，使用 RAG 流程检索文档并生成答案，以及使用 Bing 搜索引擎进行网络搜索。</p>
<img src="/images/post/2024/08/rag-router-practice.png" class="" width="1000" height="600">

<p>首先我们定义一个与 LLM 闲聊的工具组件，这里我们使用 LlamaIndex 的 <a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/examples/pipeline/query_pipeline/">Pipeline</a> 功能来构建一个查询流水线，更多的查询流水线功能可以参考我之前的<a href="https://zhaozhiming.github.io/2024/06/08/rag-module-pipeline/">这篇文章</a>，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.llms.openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> QueryPipeline, InputComponent</span><br><span class="line"></span><br><span class="line">llm = OpenAI(model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>, system_prompt=<span class="string">&quot;You are a helpful assistant.&quot;</span>)</span><br><span class="line">chitchat_p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">chitchat_p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;llm&quot;</span>: llm,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">chitchat_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;llm&quot;</span>)</span><br><span class="line">output = chitchat_p.run(<span class="built_in">input</span>=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Output: <span class="subst">&#123;output&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Output: assistant: Hello! How can I assist you today?</span><br></pre></td></tr></table></figure>

<ul>
<li>这里我们使用 OpenAI 的 <code>gpt-3.5-turbo</code> 模型来构建一个 LLM</li>
<li>然后使用 <code>QueryPipeline</code> 来构建一个查询流水线，添加 <code>input</code> 和 <code>llm</code> 两个模块，<code>input</code>模块是一个输入组件，默认输入参数键名称为 <code>input</code></li>
<li>接着添加两个模块的连接关系</li>
<li>最后调用 <code>run</code> 方法传入用户问题，得到回答</li>
</ul>
<p>然后我们再添加一个普通 RAG 的工具组件，同样是创建一个查询流水线，这里的测试文档还是用维基百科上的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SimpleDirectoryReader, VectorStoreIndex</span><br><span class="line"><span class="keyword">from</span> llama_index.core.response_synthesizers.tree_summarize <span class="keyword">import</span> TreeSummarize</span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">retriever = index.as_retriever(similarity_top_k=<span class="number">2</span>)</span><br><span class="line">rag_p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">rag_p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;retriever&quot;</span>: retriever,</span><br><span class="line">        <span class="string">&quot;output&quot;</span>: TreeSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rag_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;retriever&quot;</span>)</span><br><span class="line">rag_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;query_str&quot;</span>)</span><br><span class="line">rag_p.add_link(<span class="string">&quot;retriever&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;nodes&quot;</span>)</span><br><span class="line">output = rag_p.run(<span class="built_in">input</span>=<span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Output: <span class="subst">&#123;output&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Output: Tony Stark <span class="keyword">and</span> Bruce Banner.</span><br></pre></td></tr></table></figure>

<ul>
<li>前面部分是 LlamaIndex 常用的检索器构建流程，使用 <code>SimpleDirectoryReader</code> 来加载测试文档，然后使用 <code>VectorStoreIndex</code> 来构建一个检索器</li>
<li>创建一个查询流水线，添加 <code>input</code>、<code>retriever</code> 和 <code>output</code> 三个模块，<code>output</code> 模块是一个树形总结组件</li>
<li>添加三个模块的连接关系，<code>output</code>模块需要使用到 <code>input</code> 模块和 <code>retirever</code> 模块的输出结果</li>
<li>最后调用 <code>run</code> 方法传入用户问题，得到回答</li>
</ul>
<p>接下来我们再添加一个使用 Bing 搜索引擎的工具组件，同样我们使用查询流水线来进行创建，但这一次需要用到自定义模块，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">web_p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">web_p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;web_search&quot;</span>: WebSearchComponent(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">web_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;web_search&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>网络搜索工具比较简单，只有 2 个模块，<code>input</code> 和 <code>web_search</code></li>
<li>其中的 <code>WebSearchComponent</code> 是一个自定义模块，下面我们会详细介绍这个模块的实现</li>
</ul>
<p>在实现这个自定义模块之前，我们需要先在 Azure 上创建一个 Bing 搜索服务，然后获取 API Key，具体操作可以参考微软的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/bing/search-apis/bing-web-search/overview">官方文档</a>。然后安装 LlamaIndex 的 Bing 查询工具库：<code>pip install llama-index-tools-bing-search</code>，然后就可以开始实现自定义模块了，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Any</span></span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> CustomQueryComponent</span><br><span class="line"><span class="keyword">from</span> llama_index.tools.bing_search <span class="keyword">import</span> BingSearchToolSpec</span><br><span class="line"><span class="keyword">from</span> llama_index.agent.openai <span class="keyword">import</span> OpenAIAgent</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSearchComponent</span>(<span class="title class_ inherited__">CustomQueryComponent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Web search component.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate_component_inputs</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate component inputs during run_component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;input&quot;</span> <span class="keyword">in</span> <span class="built_in">input</span>, <span class="string">&quot;input is required&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_input_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Input keys dict.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;input&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_output_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run_component</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the component.&quot;&quot;&quot;</span></span><br><span class="line">        tool_spec = BingSearchToolSpec(api_key=os.getenv(<span class="string">&quot;BING_SEARCH_API_KEY&quot;</span>))</span><br><span class="line">        agent = OpenAIAgent.from_tools(tool_spec.to_tool_list())</span><br><span class="line">        question = kwargs[<span class="string">&quot;input&quot;</span>]</span><br><span class="line">        result = agent.chat(question)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>: result&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们直接看自定义组件中的核心方法 <code>_run_component</code></li>
<li>首先我们创建一个 <code>BingSearchToolSpec</code> 对象，传入 Bing 搜索引擎的 API Key，这里我们将 API Key 保存到环境变量 <code>BING_SEARCH_API_KEY</code> 中</li>
<li>这里我们使用了 LlamaIndex 的 Agent 功能，我们使用 <code>OpenAIAgent</code> 对象并传入 Bing 搜索工具</li>
<li>最后通过 <code>kwargs[&quot;input&quot;]</code> 获取用户问题并传递给 <code>agent.chat</code> 方法，得到搜索结果并返回</li>
<li>Bing 查询工具更多的用法可以参考<a target="_blank" rel="noopener" href="https://llamahub.ai/l/tools/llama-index-tools-bing-search?from=">其文档</a></li>
</ul>
<p>3 个工具组件创建之后，我们需要创建一个路由模块，我们使用 Semantic Router 来实现这个路由模块，我们先定义 Semantic Router 的几个 Route，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">chitchat = Route(</span><br><span class="line">    name=<span class="string">&quot;chitchat&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;how&#x27;s the weather today?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;how are things going?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lovely weather today&quot;</span>,</span><br><span class="line">        <span class="string">&quot;the weather is horrendous&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let&#x27;s go to the chippy&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rag = Route(</span><br><span class="line">    name=<span class="string">&quot;rag&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;What mysterious object did Loki use in his attempt to conquer Earth?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;How did Thanos achieve his plan of exterminating half of all life in the universe?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;What method did the Avengers use to reverse Thanos&#x27; actions?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Which member of the Avengers sacrificed themselves to defeat Thanos?&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">web = Route(</span><br><span class="line">    name=<span class="string">&quot;web&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;Search online for the top three countries in the 2024 Paris Olympics medal table.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Find the latest news about the U.S. presidential election.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Look up the current updates on NVIDIA’s stock performance today.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Search for what Musk said on X last month.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Find the latest AI news.&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里我们定义了 3 个 Route，分别针对 3 种不同的问题类型</li>
<li><code>chitchat</code> Route 的示例语句是一些闲聊语句，对应 <code>chitchat</code> 工具组件</li>
<li><code>rag</code> Route 的示例语句是一些关于复仇者联盟电影剧情的问题，对应 <code>rag</code> 工具组件</li>
<li><code>web</code> Route 的示例语句是一些关于网络搜索的问题， 其中有不少 <code>Search</code>、<code>Find</code> 等关键词，对应 <code>web</code> 工具组件</li>
</ul>
<p>接下来我们创建一个自定义的路由模块，使用 Semantic Router 来实现查询路由，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.base.query_pipeline.query <span class="keyword">import</span> (</span><br><span class="line">    QueryComponent,</span><br><span class="line">    QUERY_COMPONENT_TYPE,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> llama_index.core.bridge.pydantic <span class="keyword">import</span> Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemanticRouterComponent</span>(<span class="title class_ inherited__">CustomQueryComponent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Semantic router component.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    components: <span class="type">Dict</span>[<span class="built_in">str</span>, QueryComponent] = Field(</span><br><span class="line">        ..., description=<span class="string">&quot;Components (must correspond to choices)&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, components: <span class="type">Dict</span>[<span class="built_in">str</span>, QUERY_COMPONENT_TYPE]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Init.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(components=components)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate_component_inputs</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate component inputs during run_component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_input_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Input keys dict.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;input&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_output_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>, <span class="string">&quot;selection&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run_component</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.components) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No components&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> chitchat.name <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.components.keys():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No chitchat component&quot;</span>)</span><br><span class="line"></span><br><span class="line">        routes = [chitchat, rag, web]</span><br><span class="line">        encoder = OpenAIEncoder()</span><br><span class="line">        rl = RouteLayer(encoder=encoder, routes=routes)</span><br><span class="line">        question = kwargs[<span class="string">&quot;input&quot;</span>]</span><br><span class="line">        selection = rl(question).name</span><br><span class="line">        <span class="keyword">if</span> selection <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = <span class="variable language_">self</span>.components[selection].run_component(<span class="built_in">input</span>=question)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output = <span class="variable language_">self</span>.components[<span class="string">&quot;chitchat&quot;</span>].run_component(<span class="built_in">input</span>=question)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>: output, <span class="string">&quot;selection&quot;</span>: selection&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在自定义模块的构造器函数 <code>__init__</code> 中我们传入了一个字典，字典的键是 Route 的名称，值是对应的工具组件</li>
<li>在 <code>_output_keys</code> 方法中我们返回了 2 个输出键，一个是输出结果，一个是选择结果</li>
<li>在 <code>_run_component</code> 方法中我们首先对工具组件参数进行验证，确保有 <code>chitchat</code> 这个工具组件，因为我们需要将无法分类的问题分发到 <code>chitchat</code> 工具组件</li>
<li>然后我们使用 Semantic Router 来判断用户问题的意图，得到选择结果 <code>selection</code></li>
<li>再根据选择结果来选择相应的工具组件并执行</li>
<li>如果选择结果为空，则选择 <code>chitchat</code> 工具组件并执行</li>
<li>最后返回输出结果和选择结果</li>
</ul>
<p>最后我们将所有的工具组件和路由模块添加到一个单独的查询流水线中，示例代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;router&quot;</span>: SemanticRouterComponent(</span><br><span class="line">            components=&#123;</span><br><span class="line">                <span class="string">&quot;chitchat&quot;</span>: chitchat_p,</span><br><span class="line">                <span class="string">&quot;rag&quot;</span>: rag_p,</span><br><span class="line">                <span class="string">&quot;web&quot;</span>: web_p,</span><br><span class="line">            &#125;</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>新建的查询流水线只有一个模块 <code>router</code>，这个模块是我们自定义的路由模块 <code>SemanticRouterComponent</code></li>
<li>在路由模块中我们传入了 3 个之前定义的查询流水线，表示不同的用户意图执行不同的查询流水线</li>
<li>因为只有一个模块，所以无需添加连接关系</li>
</ul>
<p>下面我们来执行一下这个流水线，看看效果如何：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output = p.run(<span class="built_in">input</span>=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># Selection: chitchat</span></span><br><span class="line"><span class="comment"># Output: assistant: Hello! How can I assist you today?</span></span><br><span class="line"></span><br><span class="line">output = p.run(<span class="built_in">input</span>=<span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>)</span><br><span class="line"><span class="comment"># Selection: rag</span></span><br><span class="line"><span class="comment"># Output: Tony Stark and Bruce Banner.</span></span><br><span class="line"></span><br><span class="line">output = p.run(<span class="built_in">input</span>=<span class="string">&quot;Search online for the top three countries in the 2024 Paris Olympics medal table.&quot;</span>)</span><br><span class="line"><span class="comment"># Selection: web</span></span><br><span class="line"><span class="comment"># Output: The top three countries in the latest medal table for the 2024 Paris Olympics are as follows:</span></span><br><span class="line"><span class="comment"># 1. United States</span></span><br><span class="line"><span class="comment"># 2. China</span></span><br><span class="line"><span class="comment"># 3. Great Britain</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们的查询路由工作的很好，根据用户问题的不同意图选择了不同的工具组件，并得到了相应的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们介绍了 RAG 检索策略中的查询路由，并介绍了 LLM Router 和 Embedding Router 两种查询路由的实现原理，最后通过一个实战项目了解了查询路由在实际项目中的使用。但目前的查询路由还有很多不确定性，因此我们无法保证查询路由总能做出完全准确的决策，需要经过精心测试才能得到更加可靠的 RAG 应用程序。</p>
<p>关注我，一起学习各种人工智能和 GenAI 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>
<h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/towards-data-science/routing-in-rag-driven-applications-a685460a7220">Routing in RAG-Driven Applications</a></li>
</ul>
</div>

</article>
<section id="appreciates">
  <center>
	<h2>赞赏</h2>
    <div class="post-footer">
      <div>
	    <h4>如果文章对您有所帮助，可以捐赠我喝杯咖啡😌，捐赠方式：</h4>
        <div class="digital-wallet">
          <h6>BTC 地址：3LYgSyf7ddMALwGWPQr3PY4wzjsTDdg1oV</h6>
          <h6>ETH 地址：0x0C9b27c89A61aadb0aEC24CA8949910Cbf77Aa73</h6>
        </div>
        <div class="wechat_appreciates">
          <img src="/images/wechat_appreciates.png" alt="qrcode" width="250" >
        </div>
      </div>
      <div>
	    <h4>文章已同步更新公众号，欢迎关注</h4>
        <div class="wechat_appreciates">
          <img src="/images/wxgzh_qrcode.jpg" alt="qrcode" width="250" >
        </div>
      </div>
    </div>
  </center>
</section>



    
      <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = 'https://zhaozhiming.github.io/2024/08/06/rag-query-router/';
            this.page.identifier = 'https://zhaozhiming.github.io/2024/08/06/rag-query-router/';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//zhaozhiming.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

</div>

    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2025

    赵芝明
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5608723650603289" crossorigin="anonymous"></script>
</body>
</html>
