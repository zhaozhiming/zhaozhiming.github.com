<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>新一代的版本管理工具 Jujutsu 使用实践 - Hacker and Geeker&#39;s Way</title>
    <meta name="author" content="">
    
	<meta name="description" content="通过和 Git 的对比来介绍 Jujutsu 的基本操作和高级特性"> <!-- TODO: truncate -->
	<meta name="keywords" content="jujutsu, version control, git, mercurial, svn">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Hacker and Geeker&#39;s Way" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='/stylesheets/font.css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/font.css?family=Amethysta+One' rel='stylesheet' type='text/css'>
	  <script src="/javascripts/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-100485541-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Hacker and Geeker&#39;s Way
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  <!-- GitHub -->
  <li>
  <a target="_blank" rel="noopener" href="https://github.com/zhaozhiming" class="github" title="Github"></a>
  </li>
  
  
  
  
  <!-- Twitter -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.twitter.com/kingzzm" class="twitter" title="Twitter"></a>
  </li>
  
  
  <!-- LinkedIn -->
  <li>
  <a target="_blank" rel="noopener" href="http://www.linkedin.com/in/zhaozhiming" class="linkedin" title="LinkedIn"></a>
  </li>
  
  
  
  
  
  <!-- Stackoverflow -->
  <li>
  <a target="_blank" rel="noopener" href="http://stackoverflow.com/users/1954315/zhaozhiming" class="stackoverflow" title="Stackoverflow"></a>
  </li>
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about/index.html">About</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://zhaozhiming.github.io" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>


<div id="toload">
<!-- begin toload -->
    <div id="content">
        <div class="inner">
<article class="post">
	<h2 class="title">新一代的版本管理工具 Jujutsu 使用实践</h2>
    <div class="meta">
        <div class="date">Published on: <time datetime="2025-07-01T06:51:12.000Z" itemprop="datePublished">7月 1, 2025</time>
</div>
        <div class="tags">Tags: 

<a href="/tags/git/">git</a> <a href="/tags/jujutsu/">jujutsu</a> <a href="/tags/version-control/">version-control</a>
</div>
    </div>
	<div class="entry-content"><img src="/images/post/2025/07/jj-intro.jpg" class="" width="400" height="300">

<p>在当今软件开发领域，Git 已成为事实上的版本控制标准。虽然 Git 功能强大，但在日常使用中，我们常常会遇到一些令人头疼的情况：比如正在专注开发功能 feature 时，突然需要处理紧急 bug，不得不手忙脚乱地执行 <code>git stash</code> 保存工作；合并远端分支大量代码时，在复杂的 <code>git rebase -i</code> 操作中一步走错，整个提交历史变得混乱不堪；或者提交了一个庞大的 PR 后，被要求拆分成多个小 PR 再提交。如果这些痛点让你感同身受，那么 Jujutsu 值得你关注。这个基于 Rust 开发的新一代版本控制工具，正在改变开发者对版本管理的思维方式。本文将深入探讨 Jujutsu 在日常的开发中如何优雅地实现 Git 的操作，以及它如何通过创新的设计理念提升我们的开发效率和体验。</p>
<span id="more"></span>

<h2 id="Jujutsu-简介"><a href="#Jujutsu-简介" class="headerlink" title="Jujutsu 简介"></a>Jujutsu 简介</h2><p><a target="_blank" rel="noopener" href="https://jj-vcs.github.io/jj/latest/">Jujutsu</a>（ 以下简称 JJ） 是由前 Google 工程师 Martin von Zweigbergk 于 2019 年作为个人兴趣而发起的项目，是一个兼容 Git 的新一代分布式版本控制系统，采用 Rust 开发，目标是简化用户体验并提供更高性能。随着项目的发展，目前 JJ 已成为功能成熟、社区活跃、潜力十足的下一代版本控制系统。</p>
<p>JJ 的核心理念是<strong>每次文件修改都会自动创建一个新的 revision（修订版本）</strong>，你无需手动执行 <code>git add</code> 和 <code>git commit</code>，所有的修改都会被自动记录和保存。</p>
<p>这种设计带来了几个重要优势：首先，即使忘记提交，你也不会丢失任何工作；其次，你可以在任何时候自由地重组、拆分或合并你的修改历史；最后，冲突不会阻塞你的工作流程，你可以先完成其他任务，稍后再处理冲突。</p>
<p>更重要的是，JJ 与 Git 仓库<strong>完全兼容</strong>，你可以在现有的 Git 项目中使用 JJ，也可以随时切换回纯 Git 模式。这意味着你可以在个人工作中享受 JJ 带来的便利，同时与使用 Git 的团队成员无缝协作。</p>
<p>下面我们就来一探 JJ 的究竟吧！</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>接下来，让我们通过对比 Git 的常见工作流程，来深入了解 JJ 的使用方法。每个环节我都会先展示 Git 的操作方式，再介绍 JJ 的做法，让大家对 JJ 的用法有更直观的感受。</p>
<p>JJ 的安装和配置非常简单，可以参考<a target="_blank" rel="noopener" href="https://jj-vcs.github.io/jj/latest/install-and-setup/">官方文档</a>，JJ 的配置存储在 <code>~/.config/jj/config.toml</code> 文件中，使用 TOML 格式。你可以通过命令行修改配置，也可以直接编辑这个文件，配置示例如下：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;Your Name&quot;</span></span><br><span class="line"><span class="attr">email</span> = <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ui]</span></span><br><span class="line"><span class="attr">editor</span> = <span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="仓库创建和克隆"><a href="#仓库创建和克隆" class="headerlink" title="仓库创建和克隆"></a>仓库创建和克隆</h3><p>通常使用 JJ 集成 Git 仓库，最好的做法是使用 JJ 的 <code>jj git init --colocate</code> 命令，操作命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create new git repository</span></span><br><span class="line"><span class="built_in">mkdir</span> repo</span><br><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line">git init</span><br><span class="line">jj git init --colocate</span><br><span class="line"></span><br><span class="line"><span class="comment"># or clone remote repository</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/user/repo.git</span><br><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line">jj git init --colocate</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种是新建一个 Git 仓库，然后使用 <code>jj git init --colocate</code> 命令将 JJ 集成到 Git 仓库中</li>
<li>第二种是克隆一个远程 Git 仓库，然后使用 <code>jj git init --colocate</code> 命令将 JJ 集成到 Git 仓库中</li>
</ul>
<p>当你运行该命令时，JJ 会在 项目根目录下创建一个 <code>.jj</code> 目录，它和 <code>.git</code> 目录是可以和谐共存的，你可以随时在 Git 和 JJ 之间切换。这种设计让你可以渐进式地采用 JJ，而不用担心影响现有的 Git 工作流程。<br>如果在使用 JJ 的过程中，由于误操作导致工作区混乱，可以随时删除 <code>.jj</code> 目录，这样项目又会回复成 Git 项目，不会影响现有的 Git 工作流程。</p>
<h3 id="拉取远程代码和合并"><a href="#拉取远程代码和合并" class="headerlink" title="拉取远程代码和合并"></a>拉取远程代码和合并</h3><p>在团队协作中，同步远程代码是最常见的操作之一，让我们看看两种工具如何处理这个场景。</p>
<p><strong>Git 操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fetch remote updates</span></span><br><span class="line">git fetch origin</span><br><span class="line"><span class="comment"># merge remote main branch to current branch</span></span><br><span class="line">git merge origin/main</span><br><span class="line"><span class="comment"># or rebase from remote main branch to current branch</span></span><br><span class="line">git rebase origin/main</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于 Merge 和 Rebase 的区别：</strong> Merge 策略会保留完整的分支历史，通过创建一个新的合并提交来连接两个分支，这样历史图谱会呈现分叉结构，能够清晰地看到分支的开发过程。而 Rebase 策略则是将你的提交重新应用到目标分支之上，形成一条线性的历史记录，虽然看起来更加整洁清晰，但需要注意的是，这个过程会改写原有的提交历史。</p>
</blockquote>
<img src="/images/post/2025/07/merge-vs-rebase.png" class="" width="1000" height="600">

<p>在合并代码过程中，如果是 <code>merge</code> 方式遇到冲突，需要手动解决冲突，然后执行 <code>git add</code> 和 <code>git commit</code> 完成合并。 如果是 <code>rebase</code> 方式遇到冲突，需要手动解决冲突，然后执行 <code>git rebase --continue</code> 完成合并。</p>
<p><strong>JJ 操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fetch remote updates</span></span><br><span class="line">jj git fetch</span><br><span class="line"><span class="comment"># merge remote main branch to current branch</span></span><br><span class="line">jj new &lt;current-revision&gt; main@origin</span><br><span class="line"><span class="comment"># or rebase from remote main branch to current branch</span></span><br><span class="line">jj rebase -d main@origin</span><br></pre></td></tr></table></figure>

<p>其中 <code>current-revision</code> 是当前的 revision，可以通过 <code>jj log</code> 查看，也可以使用 <code>@</code> 符号表示当前的 revision。</p>
<blockquote>
<p><strong>什么是 Revision？</strong> 在 JJ 中，revision（修订版本）是核心概念，类似于 Git 的 commit 但更智能：你的工作副本本身就是一个 revision，文件修改会自动保存，无需手动 add&#x2F;commit，每个 revision 有稳定的 Change ID（如 <code>qzsvtxpv</code>）和可变的 Commit Hash（如 <code>e18f7532</code>）；当前工作位置用 <code>@</code> 符号标识，支持随时编辑、拆分、合并而不破坏历史完整性。这种设计让你专注代码开发，无需担心提交时机或丢失进度。</p>
</blockquote>
<p>在合并代码过程中，如果遇到冲突，JJ 会自动创建冲突标记，但与 Git 不同的是，JJ 不会阻塞你的工作，你可以继续工作，稍后再解决冲突。也可以通过 <code>jj st</code> 查看冲突文件，然后手动解决冲突。</p>
<h3 id="代码修改工作流"><a href="#代码修改工作流" class="headerlink" title="代码修改工作流"></a>代码修改工作流</h3><p>这是日常开发中最核心的部分，两种工具的差异在这里体现得最为明显，常见的代码修改工作流如下：</p>
<ul>
<li>首先修改文件</li>
<li>然后检查状态</li>
<li>然后检查差异</li>
<li>然后添加文件</li>
<li>然后提交</li>
<li>然后创建并切换到新分支</li>
<li>最后推送远程仓库</li>
</ul>
<p><strong>Git 操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. change file</span></span><br><span class="line">vim src/main.py</span><br><span class="line"><span class="comment"># 2. check status</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 3. check diff</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># 4. add file</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 5. commit</span></span><br><span class="line">git commit -m <span class="string">&quot;Update main.py with new feature&quot;</span></span><br><span class="line"><span class="comment"># 6. create and switch to new branch</span></span><br><span class="line">git checkout -b feature/awesome-feature</span><br><span class="line"><span class="comment"># 7. push to remote</span></span><br><span class="line">git push origin feature/awesome-feature</span><br></pre></td></tr></table></figure>

<p><strong>JJ 操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. create new working revision</span></span><br><span class="line">jj new</span><br><span class="line"><span class="comment"># 2. change file</span></span><br><span class="line">vim src/main.py</span><br><span class="line"><span class="comment"># 3. check status</span></span><br><span class="line">jj status</span><br><span class="line"><span class="comment"># 4. check diff</span></span><br><span class="line">jj diff</span><br><span class="line"><span class="comment"># 5. update revision description</span></span><br><span class="line">jj describe -m <span class="string">&quot;Update main.py with new feature&quot;</span></span><br><span class="line"><span class="comment"># 6. create branch to current revision</span></span><br><span class="line">jj bookmark create feature/awesome-feature</span><br><span class="line"><span class="comment"># 7. push to remote</span></span><br><span class="line">jj git push --allow-new</span><br></pre></td></tr></table></figure>

<p>这里体现了 revision 的好处，你无需再像 Git 那样手动执行 <code>git add</code>，所有修改都会自动保存到当前的工作 revision 中。另外你也无需像 Git 那样使用 <code>git stash</code> 来缓存工作，因为 JJ 的 revision 是自动保存的，你可以在任何时候回退到之前的 revision。</p>
<blockquote>
<p><strong>什么是 Bookmark？</strong> JJ 的 bookmark 与 Git 的 branch 功能上类似，但它们不会自动随工作改变移动，Git 的 branch 好比一条自动向前延伸的道路，当你 commit 时，它就自己跟着走。JJ 的 bookmark 更像是你在地图上的一个<strong>旗帜</strong>标记，当你走远了旗帜还留在原地，只有你自己去把它挪到新地点。这样做的好处是你可以随时创建和删除 bookmark，也可以随时将 bookmark 映射到不同的 revision，而不会影响工作流程。</p>
</blockquote>
<p>比如在前面提到的场景，当你提交了庞大的 PR 后（这个 PR 包含了多个 commit），被要求拆分成多个小的 PR 再提交。如果是使用 Git 的话，你需要使用 <code>git cherry-pick</code> 等复杂命令来选择不同的 commit 创建分支，然后再提交 PR。而使用 JJ 的话，你可以使用 <code>jj bookmark</code> 命令来对不同的 revision 创建不同的分支，然后分别对这些分支进行提交 PR 即可，操作相对简单很多。</p>
<img src="/images/post/2025/07/jj-big-pr.png" class="" width="1000" height="600">

<p>针对这个场景的 JJ 操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jj edit &lt;revision-id1&gt;</span><br><span class="line">jj bookmark create feature/feature-1</span><br><span class="line">jj git push</span><br><span class="line"><span class="comment"># repeat the above steps for other branches</span></span><br></pre></td></tr></table></figure>

<ul>
<li>假设要为某个 commit 创建分支，先使用 <code>jj edit</code> 命令选中该 commit</li>
<li>然后使用 <code>jj bookmark create</code> 命令创建分支</li>
<li>最后使用 <code>jj git push</code> 命令将分支推送到远程仓库</li>
<li>重复以上步骤，为其他 commit 创建分支</li>
</ul>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><p>熟悉了基本的工作流程后，让我们深入了解 JJ 的一些高级特性，这些功能将帮助你更高效地管理代码历史。</p>
<p>JJ 最强大的功能之一是灵活的 revision 操作，让你可以随时重组、拆分或合并你的修改历史。</p>
<h3 id="合并-Revision（Squash）"><a href="#合并-Revision（Squash）" class="headerlink" title="合并 Revision（Squash）"></a>合并 Revision（Squash）</h3><p><strong>Git 操作：</strong></p>
<p>在 Git 中，合并多个提交通常需要使用交互式 rebase：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git: Interactive rebase to squash commits</span></span><br><span class="line">git rebase -i HEAD~3</span><br><span class="line"><span class="comment"># Then mark commits as &#x27;squash&#x27; in the editor</span></span><br></pre></td></tr></table></figure>

<p><strong>JJ 操作：</strong></p>
<p>而在 JJ 中，这个操作更加直观：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Squash current revision into parent</span></span><br><span class="line">jj squash</span><br><span class="line"><span class="comment"># Squash specific revision into another</span></span><br><span class="line">jj squash --from &lt;revision1&gt; --into &lt;revision2&gt;</span><br></pre></td></tr></table></figure>

<p><code>jj squash</code> 命令可以将当前的 revision 合并到父 revision 中，也可以将指定的 revision 合并到另一个 revision 中。</p>
<p>假设你已经完成了 feature 的开发，这个 feature 包含了 3 个小的 revision，现在需要将多个小的 revision 合并成一个大的 revision，这种情况下你就可以使用 <code>jj squash</code> 命令进行操作，下面是操作示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">jj <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  qqymurpk your-email@example.com 2025-06-26 13:45:42 default@ 078fbfb4</span></span><br><span class="line"><span class="comment"># │  (no description set) # revision 1</span></span><br><span class="line"><span class="comment"># ○  qyxmswok your-email@example.com 2025-06-26 13:45:42 98321f9e</span></span><br><span class="line"><span class="comment"># │  (no description set) # revision 2</span></span><br><span class="line"><span class="comment"># ○  vqmpqpmu your-email@example.com 2025-06-26 13:45:42 7a515876</span></span><br><span class="line"><span class="comment"># │  (no description set) # revision3</span></span><br><span class="line"><span class="comment"># ◆  yozmsuoy your-email@example.com 2025-06-26 13:40:24 main@origin git_head() 99f00e34</span></span><br><span class="line">jj squash <span class="comment"># this will squash the revision 1 into revision 2</span></span><br><span class="line"><span class="comment"># jj squash --from qqymurpk --into qyxmswok # same effect as above</span></span><br><span class="line">jj <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  qyxmswok your-email@example.com 2025-06-26 13:45:42 98321f9e</span></span><br><span class="line"><span class="comment"># │  (no description set) # revision 2</span></span><br><span class="line"><span class="comment"># ○  vqmpqpmu your-email@example.com 2025-06-26 13:45:42 7a515876</span></span><br><span class="line"><span class="comment"># │  (no description set) # revision3</span></span><br><span class="line"><span class="comment"># ◆  yozmsuoy your-email@example.com 2025-06-26 13:40:24 main@origin git_head() 99f00e34</span></span><br><span class="line">jj squash <span class="comment"># this will squash the revision 2 into revision 3</span></span><br><span class="line"><span class="comment"># jj squash --from qyxmswok --into vqmpqpmu # same effect as above</span></span><br><span class="line">jj <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  vqmpqpmu your-email@example.com 2025-06-26 13:45:42 7a515876</span></span><br><span class="line"><span class="comment"># │  (no description set) # revision3</span></span><br><span class="line"><span class="comment"># ◆  yozmsuoy your-email@example.com 2025-06-26 13:40:24 main@origin git_head() 99f00e34</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先查看当前的 revision 历史，可以看到有 3 个 revision，当前的 revision 是 <code>@</code> 符号标识的 revision，也就是 revision 1</li>
<li>执行 <code>jj squash</code> 命令，会将 revision 1 合并到 revision 2 中</li>
<li>再次查看 revision 历史，可以看到 revision 1 已经被合并到 revision 2 中，这时当前的 revision 变成了 revision 2</li>
</ul>
<ul>
<li>然后再次执行 <code>jj squash</code> 命令，会将 revision 2 合并到 revision 3 中</li>
</ul>
<ul>
<li>再次查看 revision 历史，可以看到 revision 2 已经被合并到 revision 3 中，最终我们将这 3 个 revision 合并成了 1 个 revision</li>
</ul>
<img src="/images/post/2025/07/jj-squash.png" class="" width="1000" height="600">

<p><code>jj squash</code> 如果在合并过程中遇到冲突，JJ 会自动创建冲突标记，你可以立即处理冲突，也可以稍后再处理冲突。</p>
<p><code>jj squash</code> 命令不仅适用于合并 revision，也适用于合并 bookmark，因为 bookmark 名称可以作为 revision 的简洁别名出现在任何接受 revision 参数的命令里，这也就意味着你可以快速地使用该命令进行分支的合并。</p>
<p><code>jj squash</code> 命令还可以将某个 revision 移动到另一个 revision 的前面或后面，只需在目标 revision 前后 new 一个新的 revision，然后使用 <code>jj squash</code> 命令将当前的 revision 合并到新的 revision 中即可。</p>
<h3 id="拆分-Revision（Split）"><a href="#拆分-Revision（Split）" class="headerlink" title="拆分 Revision（Split）"></a>拆分 Revision（Split）</h3><p><strong>Git 操作：</strong></p>
<p>Git 中拆分提交相对复杂：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git: Split a commit</span></span><br><span class="line">git rebase -i HEAD~1</span><br><span class="line"><span class="comment"># Mark as &#x27;edit&#x27;, then:</span></span><br><span class="line">git reset HEAD~</span><br><span class="line">git add -p  <span class="comment"># Interactively stage parts</span></span><br><span class="line">git commit -m <span class="string">&quot;First part&quot;</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Second part&quot;</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p><strong>JJ 操作：</strong></p>
<p>JJ 的拆分操作更加优雅：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Interactive split current revision</span></span><br><span class="line">jj <span class="built_in">split</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>jj split</code> 命令需要指定交互式编辑器，JJ 官方推荐使用 <a target="_blank" rel="noopener" href="https://meldmerge.org/">Meld</a> 作为交互式编辑器，工具的安装方法可以参考<a target="_blank" rel="noopener" href="https://jj-vcs.github.io/jj/latest/config/#using-meld-as-a-diff-editor">官方文档</a>，安装完成后在 JJ 的配置文件里面添加如下配置：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ui]</span></span><br><span class="line"><span class="attr">diff-editor</span> = <span class="string">&quot;meld&quot;</span></span><br></pre></td></tr></table></figure>

<p>假设你在一个 revision 中修改了 3 个文件，现在需要将这 3 个文件拆分成 3 个新的 revision，可以使用 <code>jj split</code> 命令进行操作，下面是操作示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jj <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  xlylmopt your-email@example.com 2025-06-30 15:50:41 0568d673</span></span><br><span class="line"><span class="comment"># │  (no description set) # source revision</span></span><br><span class="line">jj st</span><br><span class="line"><span class="comment"># Working copy changes:</span></span><br><span class="line"><span class="comment"># M a.txt</span></span><br><span class="line"><span class="comment">#M b.txt</span></span><br><span class="line"><span class="comment">#M c.txt</span></span><br><span class="line">jj <span class="built_in">split</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先查看当前的 revision 历史，可以看到只有 1 个 revision</li>
<li>再查看当前的工作区状态，可以看到有 3 个文件被修改</li>
<li>执行 <code>jj split</code> 命令，会出现 Meld 的 GUI 界面，你可以选择将哪个文件拆分到新的 revision 中</li>
</ul>
<img src="/images/post/2025/07/jj-split.png" class="" width="1000" height="600">

<p>这里我们选中 <code>b.txt</code> 和 <code>c.txt</code> 文件并点击 <code>&gt;</code> 按钮将它们移动到新的 revision 中，然后点击右上角的关闭按钮，这样就会自动创建一个新的 revision，并切换到新的 revision 中。操作完成后，我们再次查看 revision 历史，可以看到已经创建了 2 个新的 revision。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jj <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  xuwrtktq your-email@example.com 2025-06-30 15:57:00 b97b256b</span></span><br><span class="line"><span class="comment"># │  (no description set)</span></span><br><span class="line"><span class="comment"># ○  xlylmopt your-email@example.com 2025-06-30 15:56:43 git_head() 590965ef</span></span><br><span class="line"><span class="comment"># │  (no description set)</span></span><br><span class="line">jj st</span><br><span class="line"><span class="comment"># Working copy changes:</span></span><br><span class="line"><span class="comment"># M b.txt</span></span><br><span class="line"><span class="comment"># M c.txt</span></span><br><span class="line">jj edit xl</span><br><span class="line">jj st</span><br><span class="line"><span class="comment"># Working copy changes:</span></span><br><span class="line"><span class="comment"># M a.txt</span></span><br></pre></td></tr></table></figure>

<p>重复以上的操作再将 <code>xuwrtktq</code> 这个 revision 拆分成 2 个 revision，这样我们的操作就完成了。</p>
<h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><h3 id="操作历史和回滚（Operation-Log）"><a href="#操作历史和回滚（Operation-Log）" class="headerlink" title="操作历史和回滚（Operation Log）"></a>操作历史和回滚（Operation Log）</h3><p>在日常开发中，我们有时会因为误操作而需要撤销之前的命令，比如错误地删除了分支、执行了错误的 rebase 等。这时候查看操作历史和回滚操作就显得非常重要。</p>
<p><strong>Git 操作：</strong></p>
<p>Git 提供了 <code>reflog</code> 命令来查看引用的历史记录，但它只能追踪特定引用（如分支）的变化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show reflog of current branch</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment"># show reflog of specific branch</span></span><br><span class="line">git reflog show main</span><br></pre></td></tr></table></figure>

<p>Git 的 reflog 有一些限制：只能追踪引用的变化，不能看到完整的操作历史；分支删除后 reflog 也会丢失；无法查看全局的操作记录。</p>
<p><strong>JJ 操作：</strong></p>
<p>JJ 的操作日志（operation log）功能更加强大，它记录了你在仓库中执行的每一个操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show operation log</span></span><br><span class="line">jj op <span class="built_in">log</span></span><br><span class="line"><span class="comment"># show detailed information of specific operation</span></span><br><span class="line">jj op show &lt;operation-id&gt;</span><br><span class="line"><span class="comment"># undo to previous state of specific operation</span></span><br><span class="line">jj op undo &lt;operation-id&gt; <span class="comment"># `jj undo` is a shortcut for `jj op undo`</span></span><br><span class="line"><span class="comment"># restore to the state of specific operation</span></span><br><span class="line">jj op restore &lt;operation-id&gt;</span><br></pre></td></tr></table></figure>

<p>JJ 的操作日志命令有查看、撤销和恢复等操作，让我们通过一个实际例子来看看 JJ 的操作历史功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do some operations</span></span><br><span class="line">jj new -m <span class="string">&quot;Feature A&quot;</span></span><br><span class="line">vim file1.txt</span><br><span class="line">jj new -m <span class="string">&quot;Feature B&quot;</span></span><br><span class="line">vim file2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># show operation log</span></span><br><span class="line">jj op <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  93d01c6ba9e4 user@example.local 2 minutes ago, lasted 2 milliseconds</span></span><br><span class="line"><span class="comment"># │  new empty commit</span></span><br><span class="line"><span class="comment"># │  args: jj new -m &#x27;Feature B&#x27;</span></span><br><span class="line"><span class="comment"># ○  37ca6e5da150 user@example.local 2 minutes ago, lasted 18 milliseconds</span></span><br><span class="line"><span class="comment"># │  new empty commit</span></span><br><span class="line"><span class="comment"># │  args: jj new -m &#x27;Feature A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># restore the operation to the state of the operation &quot;Feature A&quot;</span></span><br><span class="line">jj op restore 37ca6e5da150</span><br><span class="line"><span class="comment"># show revision history</span></span><br><span class="line">jj <span class="built_in">log</span></span><br><span class="line"><span class="comment"># @  wxsrykxn your-email@example.com 2025-07-01 18:20:12 440e094d</span></span><br><span class="line"><span class="comment"># │  (empty) Feature A</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先执行了两个操作，分别是创建了 2 个新的 revision，一个是 <code>Feature A</code>，一个是 <code>Feature B</code>，分别在这 2 个 revision 中修改了文件 <code>file1.txt</code> 和 <code>file2.txt</code></li>
<li>操作完成后当前的 revision 是 <code>Feature B</code></li>
<li>然后使用 <code>jj op restore</code> 命令将操作历史恢复到 <code>Feature A</code> 的状态</li>
<li>最后可以用 <code>jj log</code> 命令查看 revision 记录，可以看到 <code>Feature B</code> 的 revision 的已经被撤销了，只有 <code>Feature A</code> 的 revision 被保留了</li>
</ul>
<blockquote>
<p><strong>注意：</strong> <code>jj log</code> 和 <code>jj op log</code> 是两个不同的命令，前者是查看 revision 历史，后者是查看操作历史。</p>
</blockquote>
<p>JJ 提供了全面的操作记录追踪，不仅记录分支引用的变化，还会完整保存每一个执行的操作。这种设计让你可以精确地撤销任何特定操作而不影响其他工作，同时保证操作历史永不丢失，即使删除了分支也能完整保留。每个操作都会显示完整的命令行参数，让你清楚地了解当时执行了什么操作，极大地提升了操作的可追溯性和安全性。</p>
<h3 id="Cherry-pick-和复制修改"><a href="#Cherry-pick-和复制修改" class="headerlink" title="Cherry-pick 和复制修改"></a>Cherry-pick 和复制修改</h3><p>当你有一个大型功能分支，但只想将其中部分提交合并到主分支时，可以使用 Git 的 <code>cherry-pick</code> 命令来选择特定的 commit 并合并到主分支。</p>
<p><strong>Git 操作：</strong></p>
<p>Git 的 cherry-pick 操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git: Apply specific commits</span></span><br><span class="line">git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>

<p><strong>JJ 操作：</strong></p>
<p>与 <code>git cherry-pick</code> 类似，JJ 也提供了 <code>duplicate</code> 命令来复制特定的 revision 到另一个 revision 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Duplicate a revision</span></span><br><span class="line">jj duplicate &lt;revision&gt;</span><br><span class="line"><span class="comment"># Duplicate multiple revisions</span></span><br><span class="line">jj duplicate &lt;rev1&gt; &lt;rev2&gt; &lt;rev3&gt;</span><br><span class="line"><span class="comment"># Duplicate and rebase onto different parent</span></span><br><span class="line">jj duplicate &lt;revision&gt; -d &lt;new-parent&gt;</span><br></pre></td></tr></table></figure>

<h3 id="忽略文件跟踪"><a href="#忽略文件跟踪" class="headerlink" title="忽略文件跟踪"></a>忽略文件跟踪</h3><p>JJ 直接使用 <code>.gitignore</code> 文件，与 Git 完全兼容，但对于已经被跟踪的文件，JJ 提供了更便捷的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stop tracking a file (but keep it locally)</span></span><br><span class="line">jj file untrack &lt;file-path&gt;</span><br></pre></td></tr></table></figure>

<p><code>jj file untrack</code> 这个命令相当于 Git 的 <code>git rm --cached</code> 命令。</p>
<h2 id="JJ-的不足"><a href="#JJ-的不足" class="headerlink" title="JJ 的不足"></a>JJ 的不足</h2><p>前面我们看到了 JJ 的诸多优势，但任何新技术都不是完美的。在实际使用 JJ 的过程中也会经常遇到了一些问题，这些问题可能会影响你的使用体验。</p>
<ul>
<li>VS Code、SourceTree 等开发者常用的工具对 JJ 的支持还比较有限，而且 CI&#x2F;CD 集成也需要额外配置，生态系统不够成熟</li>
<li>从 Git 迁移到 JJ 需要重新理解 revision、bookmark 等概念，学习曲线比较陡峭</li>
<li>相比 Git 成熟的功能体系，JJ 在 hooks、复杂工作流支持等方面还有不足</li>
</ul>
<p>尽管有这些问题，我觉得 JJ 仍然值得尝试，但建议采取渐进的方式：</p>
<ul>
<li>首先可以在个人项目中试用，熟悉 JJ 的工作方式</li>
<li>如果觉得确实能提升效率，再考虑在小团队中推广</li>
<li>对于大型项目或企业环境，可以考虑混合使用的方式——个人开发时用 JJ，团队协作时仍然用 Git</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过对比 Git 和 JJ 的日常工作流程，从仓库初始化、配置管理、代码修改到高级操作，全面介绍了 JJ 的核心特性和实际使用方法。我们可以看到，JJ 通过自动保存 revision、灵活的历史管理和非阻塞的冲突处理等创新设计，有效解决了 Git 在日常使用中的诸多痛点。</p>
<p>虽然 Git 目前仍是版本控制的事实标准，但 JJ 展示了版本控制工具的另一种可能性。对于追求高效开发体验的个人开发者，或者需要处理复杂代码审查流程的团队来说，JJ 都值得投入时间去学习和尝试。毕竟，好的工具应该让我们更专注于创造，而不是被繁琐的操作所束缚。</p>
<p>虽然 JJ 还有这样那样的一些问题， 但是 JJ 还在快速发展中，很多现在的问题可能在未来的版本中会得到解决。如果你对版本控制工具的未来发展感兴趣，关注 JJ 的进展是个不错的选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://steveklabnik.github.io/jujutsu-tutorial/">Steve’s Jujutsu Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://zerowidth.com/2025/what-ive-learned-from-jj/">What I’ve learned from jj</a></li>
<li><a target="_blank" rel="noopener" href="https://zerowidth.com/2025/jj-tips-and-tricks/#bookmarks-and-branches">JJ Tips and Tricks</a></li>
<li><a target="_blank" rel="noopener" href="https://jj-vcs.github.io/jj/latest/git-command-table/?utm_source=chatgpt.com">JJ Git Command Table</a></li>
</ul>
<p>关注我，一起学习各种最新的 AI 和编程开发技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>
</div>

</article>
<section id="appreciates">
  <center>
	<h2>赞赏</h2>
    <div class="post-footer">
      <div>
	    <h4>如果文章对您有所帮助，可以捐赠我喝杯咖啡😌，捐赠方式：</h4>
        <div class="digital-wallet">
          <h6>BTC 地址：3LYgSyf7ddMALwGWPQr3PY4wzjsTDdg1oV</h6>
          <h6>ETH 地址：0x0C9b27c89A61aadb0aEC24CA8949910Cbf77Aa73</h6>
        </div>
        <div class="wechat_appreciates">
          <img src="/images/wechat_appreciates.png" alt="qrcode" width="250" >
        </div>
      </div>
      <div>
	    <h4>文章已同步更新公众号，欢迎关注</h4>
        <div class="wechat_appreciates">
          <img src="/images/wxgzh_qrcode.jpg" alt="qrcode" width="250" >
        </div>
      </div>
    </div>
  </center>
</section>



    
      <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = 'https://zhaozhiming.github.io/2025/07/01/jujutsu-usage-practice/';
            this.page.identifier = 'https://zhaozhiming.github.io/2025/07/01/jujutsu-usage-practice/';
        };

        (function() {
          var d = document, s = d.createElement('script');
          s.src = '//zhaozhiming.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

</div>

    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2025

    赵芝明
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5608723650603289" crossorigin="anonymous"></script>
</body>
</html>
