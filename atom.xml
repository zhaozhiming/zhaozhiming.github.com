<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hacker and Geeker&#39;s Way</title>
  
  
  <link href="https://zhaozhiming.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhaozhiming.github.io/"/>
  <updated>2025-05-26T12:48:03.269Z</updated>
  <id>https://zhaozhiming.github.io/</id>
  
  <author>
    <name>赵芝明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入解析 Solana 交易</title>
    <link href="https://zhaozhiming.github.io/2025/05/23/deep-dive-into-solana-transaction/"/>
    <id>https://zhaozhiming.github.io/2025/05/23/deep-dive-into-solana-transaction/</id>
    <published>2025-05-23T06:02:09.000Z</published>
    <updated>2025-05-26T12:48:03.269Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2025/05/solana-transaction.png" class="" width="400" height="300"><p>在区块链的世界里，交易是一切活动的核心，它记录着价值的转移、状态的变更以及智能合约的执行。对于 Solana 这样一个高性能区块链网络而言，理解交易的结构和机制显得尤为重要。与传统的区块链网络相比，Solana 的交易设计更加复杂和精巧，它不仅支持高并发处理，还提供了丰富的指令类型和灵活的账户模型。无论你是区块链开发者、数据分析师，还是对 Solana 生态感兴趣的技术爱好者，深入了解 Solana 交易的内部结构都是必不可少的技能。本文将带你全面解析 Solana 交易，从多种查看方式到详细的数据结构，从 RPC 调用到浏览器界面，帮助你掌握 Solana 交易分析的各种技巧和最佳实践。</p><span id="more"></span><h2 id="了解-Solana-交易信息的几种方式"><a href="#了解-Solana-交易信息的几种方式" class="headerlink" title="了解 Solana 交易信息的几种方式"></a>了解 Solana 交易信息的几种方式</h2><p>在 Solana 生态中，如果你想了解交易的详细信息，有多种方式可以帮助到你，以下是最常用的几种方法：</p><ol><li>Solana Explorer：最直观的图形界面方式，适合快速查看交易详情和状态</li><li>RPC 方法：通过编程方式获取原始交易数据，适合需要深度分析或集成到应用程序中</li><li>Web3.js SDK：提供更高级的 API 接口，简化交易数据的获取和处理</li></ol><p>可以根据你的需求来选择具体的方式，下面我们将详细介绍每种方式的具体使用方法。</p><h3 id="使用-Solana-浏览器查看交易"><a href="#使用-Solana-浏览器查看交易" class="headerlink" title="使用 Solana 浏览器查看交易"></a>使用 Solana 浏览器查看交易</h3><p><a href="https://explorer.solana.com/">Solana Explorer</a> 是 Solana 官方提供的区块链浏览器，它提供了丰富的交易信息查看功能。通过 Solana Explorer，你可以轻松查看交易详情、账户状态、区块高度等重要信息。</p><p>进入 Solana Explorer 网站后，你可以在搜索框中输入交易的哈希值，回车后就可以看到交易详情。交易详情包含 <code>Overview</code> 、 <code>Account Input(s)</code> 、 <code>Token Balances</code> 、 <code>Instructions</code> 和 <code>Program Instruction Logs</code> 等几个部分。</p><img src="/images/post/2025/05/solana-explorer.png" class="" width="1000" height="600"><ul><li>在 <code>Overview</code> 区域，你可以看到交易的基本信息，包括交易哈希、区块高度、时间戳、交易金额等。</li><li>在 <code>Account Input(s)</code> 区域，你可以看到交易涉及的账户信息，包括账号的地址和账户名称。</li><li>在 <code>Token Balances</code> 区域，你可以看到交易涉及的代币信息，包括转账代币的账号地址、代币地址、代币转账数量、交易后该账号的代币数量等。</li><li>在 <code>Instructions</code> 区域，你可以看到交易涉及的指令信息，包括顶层指令以及内部指令、指令的程序地址、消耗的 CU 数量、指令参数等。</li><li>在 <code>Program Instruction Logs</code> 区域，你可以看到交易涉及的程序指令日志信息，包括每个指令的详细日志输出内容等。</li></ul><p>除了在 Solana Explorer 网站上查看交易详情，你还可以在其他第三方的 Solana 浏览器上查看交易信息，其中比较出名的是 <a href="https://solscan.io/">Solscan</a> 网站。</p><p>Solscan 作为 Solana 生态中知名的第三方浏览器，相比官方的 Solana Explorer 提供了更多特色功能，包括更丰富的代币市场数据、更强大的账户分析工具、更友好的用户界面、额外的实用功能（如交易中代币转账的可视化地图）以及更完善的开发者工具。这些功能使 Solscan 成为一个更全面的 Solana 生态工具，特别适合需要深入分析交易和账户数据的用户。</p><h3 id="使用-Solana-RPC-方法获取交易信息"><a href="#使用-Solana-RPC-方法获取交易信息" class="headerlink" title="使用 Solana RPC 方法获取交易信息"></a>使用 Solana RPC 方法获取交易信息</h3><p>Solana 官方提供了很多 RPC 方法， 包括 <code>HTTP</code> 和 <code>Websocket</code> 的接口，这些接口可以获取账号信息、获取区块信息、获取交易信息等，其中获取交易信息是一个 <code>HTTP</code> 接口：<a href="https://solana.com/docs/rpc/http/gettransaction">getTransaction</a>。</p><p>这种方式比较适合需要深度分析交易信息的用户，比如开发者、数据分析师等。以下是一个使用 <code>curl</code> 命令获取交易信息的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.mainnet-beta.solana.com -s -X \</span><br><span class="line">   POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">     &quot;jsonrpc&quot;: &quot;2.0&quot;,</span></span><br><span class="line"><span class="string">     &quot;id&quot;: 1,</span></span><br><span class="line"><span class="string">     &quot;method&quot;: &quot;getTransaction&quot;,</span></span><br><span class="line"><span class="string">     &quot;params&quot;: [</span></span><br><span class="line"><span class="string">       &quot;3AnirZmjF1U64zfCUyrzWBzNGvcaa3Ya7PacAD5Y5LRoHsnZsHSekQEAKGuMCbtGNWXChPe5uWQkvipDGwfUVNAx&quot;,</span></span><br><span class="line"><span class="string">       &#123;</span></span><br><span class="line"><span class="string">         &quot;commitment&quot;: &quot;confirmed&quot;,</span></span><br><span class="line"><span class="string">         &quot;maxSupportedTransactionVersion&quot;: 0,</span></span><br><span class="line"><span class="string">         &quot;encoding&quot;: &quot;json&quot;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">     ]</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> &#x27;</span></span><br></pre></td></tr></table></figure><p><code>getTransaction</code> 方法的参数包括：</p><ul><li><code>transactionSignature</code>：交易哈希</li><li><code>config</code>：Object 类型的配置参数，包括以下几个参数：<ul><li><code>commitment</code>: 交易确认的级别，可选值包括 <code>confirmed</code> 和 <code>finalized</code>，默认值是 <code>finalized</code>。</li><li><code>maxSupportedTransactionVersion</code>: 最大支持的交易版本号，当前的有效值是 <code>0</code>。</li><li><code>encoding</code>: 交易编码格式，可选值包括 <code>json</code>、<code>base64</code>、<code>jsonParsed</code> 和 <code>base58</code>，默认值是 <code>json</code>。</li></ul></li></ul><p>返回的结果是一个 <code>JSON</code> 对象，其中包含交易信息，包括交易哈希、区块高度、时间戳、交易金额等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;blockTime&quot;</span><span class="punctuation">:</span> <span class="number">1747674547</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;computeUnitsConsumed&quot;</span><span class="punctuation">:</span> <span class="number">169182</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;err&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span> <span class="number">17621</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;innerInstructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;loadedAddresses&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;readonly&quot;</span><span class="punctuation">:</span>…<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logMessages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;postBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;postTokenBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preTokenBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;returnData&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span>…<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rewards&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Ok&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="number">341094579</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transaction&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span>…<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这些数据完全等价于我们在 Solana Explorer 中看到的交易信息，只是浏览器将这些数据进行了可视化的展示，方便我们查看，后面我们会详细介绍数据中各个字段的含义。</p><h3 id="使用-Solana-web3-js-NPM-包获取交易信息"><a href="#使用-Solana-web3-js-NPM-包获取交易信息" class="headerlink" title="使用 Solana@web3.js NPM 包获取交易信息"></a>使用 <code>Solana@web3.js</code> NPM 包获取交易信息</h3><p>还有一种交易查询方式方式适合开发者使用，那就是使用 <a href="https://www.npmjs.com/package/@solana/web3.js">Solana@web3.js NPM</a> 包，这个包是 Solana 官方提供的 JavaScript 库，可以方便地获取交易信息。</p><p>这个包提供了两个方法来获取交易信息：<code>getTransaction</code> 和 <code>getParsedTransaction</code>，这两个方法的底层都是调用 Solana 的 RPC 方法：<code>getTransaction</code>，但返回的数据结构有所不同。</p><p>以下是使用 <code>Solana@web3.js</code> NPM 包获取交易信息的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Connection</span>,</span><br><span class="line">  <span class="title class_">PublicKey</span>,</span><br><span class="line">  clusterApiUrl,</span><br><span class="line">  type <span class="title class_">GetVersionedTransactionConfig</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@solana/web3.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">new</span> <span class="title class_">Connection</span>(<span class="title function_">clusterApiUrl</span>(<span class="string">&quot;mainnet-beta&quot;</span>), <span class="string">&quot;confirmed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> signature =</span><br><span class="line">  <span class="string">&quot;3AnirZmjF1U64zfCUyrzWBzNGvcaa3Ya7PacAD5Y5LRoHsnZsHSekQEAKGuMCbtGNWXChPe5uWQkvipDGwfUVNAx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">config</span>: <span class="title class_">GetVersionedTransactionConfig</span> = &#123;</span><br><span class="line">  <span class="attr">commitment</span>: <span class="string">&quot;finalized&quot;</span>,</span><br><span class="line">  <span class="attr">maxSupportedTransactionVersion</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transaction = <span class="keyword">await</span> connection.<span class="title function_">getTransaction</span>(signature, config);</span><br><span class="line"><span class="keyword">let</span> parsedTransaction = <span class="keyword">await</span> connection.<span class="title function_">getParsedTransaction</span>(</span><br><span class="line">  signature,</span><br><span class="line">  config</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(transaction);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parsedTransaction);</span><br></pre></td></tr></table></figure><p><code>getTransaction</code> 方法返回的是一个 <code>Transaction</code> 对象，相比 <code>getParsedTransaction</code> 方法返回的对象，前者的数据量更小，传输更快，适合需要低层级访问或自定义解析逻辑的场景，对于简单的查询，处理速度可能更快。</p><p><code>getParsedTransaction</code> 方法返回的是一个 <code>ParsedTransaction</code> 对象，它的数据已经预先解析，更容易直接使用，提供更友好的访问格式，尤其是指令部分的数据，减少客户端的解析负担，更适合需要理解交易内容的应用程序。</p><p>以交易中的某个指令数据为例来说明这 2 个方法返回数据的主要不同：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getTransaction instruction</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;programIdIndex&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;accountKeyIndexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">25</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Buffer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getParsedTransaction instruction</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;parsed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7ubjuqeAFvE3yjsDNdrD31bS8Do9DHB2yGJ2b5yCCvJL&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;59obFNBzyTBGowrkif5uK7ojS58vsuWz3ZCvg6tfZAGw&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;21w1M4yesWyzVVryHuHqg7rLUMWtp78RRaH1Zz6vhwfB&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;systemProgram&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11111111111111111111111111111111&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tokenProgram&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;wallet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;21w1M4yesWyzVVryHuHqg7rLUMWtp78RRaH1Zz6vhwfB&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;createIdempotent&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spl-associated-token-account&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;programId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stackHeight&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>getTransaction</code> 方法返回的数据中，指令数据是原始的二进制数据，程序 ID 和账号地址都是索引值，且数据是二进制格式，需要客户端自己解析，而 <code>getParsedTransaction</code> 方法返回的数据中，指令数据已经解析为人类可读的格式，包括指令的类型、参数、账户等信息，其中的 <code>parsed</code> 字段就是解析后的数据。</p><p>这两个方法都可以用来获取交易的信息，选择哪个方法取决于你的具体需求。如果你需要最高效的数据传输和处理，并且计划自己解析交易数据，<code>getTransaction</code>方法可能更合适。如果你需要更易用、更人类可读的数据格式，并且不想处理复杂的解析逻辑，<code>getParsedTransaction</code> 可能是更好的选择。</p><p>在大多数应用场景中，尤其是开发者工具、区块浏览器或需要展示交易详情的应用，<code>getParsedTransaction</code>  方法通常更有优势，因为它提供了更方便的数据访问方式，减少了客户端的解析工作量，并且能够更好地处理复杂的交易指令内容。</p><h2 id="交易数据结构分析"><a href="#交易数据结构分析" class="headerlink" title="交易数据结构分析"></a>交易数据结构分析</h2><p>下面我们以 <code>getParsedTransaction</code> 方法返回的数据为例，来分析交易数据结构。首先我们来看下返回的数据结构顶层的字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;blockTime&quot;</span><span class="punctuation">:</span> <span class="number">1747674547</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;computeUnitsConsumed&quot;</span><span class="punctuation">:</span>…<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="number">341094579</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;transaction&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span>…<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>blockTime: 交易被确认的 UNIX 时间戳（秒）。</li><li>meta: 包含交易执行结果的元数据，包括状态、费用、令牌余额变化等。</li><li>slot: 交易所在区块的槽位号，也可以理解为区块高度，Solana 区块链中用于标识区块高度的唯一标识符。</li><li>transaction: 包含交易详细信息的对象，如签名、指令和账户等。</li><li>version: 交易格式的版本号。</li></ul><h3 id="meta-字段"><a href="#meta-字段" class="headerlink" title="meta 字段"></a>meta 字段</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;computeUnitsConsumed&quot;</span><span class="punctuation">:</span> <span class="number">169182</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;err&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span> <span class="number">17621</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;innerInstructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;logMessages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postTokenBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preTokenBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;returnData&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span>…<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rewards&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Ok&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>computeUnitsConsumed: 交易执行消耗的计算单元数量。</li><li>err: 如果交易失败，这里会显示错误信息；成功则为 null。</li><li>fee: 交易处理费用（以 lamports 为单位，1 SOL &#x3D; 10^9 lamports）。</li><li>innerInstructions: 包含由其他指令触发的内部指令数组。</li><li>logMessages: 交易执行时程序输出的日志信息数组。</li><li>preBalances 和 postBalances: 交易前后账户的 lamports 余额数组。</li><li>preTokenBalances 和 postTokenBalances: 交易前后涉及的代币账户余额信息。</li><li>returnData: 交易返回的数据。</li><li>rewards: 交易奖励信息。</li><li>status: 交易状态对象，通常成功会显示为 {“Ok”: null}。</li></ul><p><code>innerInstructions</code> 字段是一个数组，每个元素是一个内部指令对象，内部指令对象包含以下字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;innerInstructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;instructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;parsed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;extensionTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;immutableOwner&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;59obFNBzyTBGowrkif5uK7ojS58vsuWz3ZCvg6tfZAGw&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;getAccountDataSize&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spl-token&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;programId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stackHeight&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li>index: 对应顶层指令的索引</li><li>instructions: 内部指令列表，包含程序 ID 和指令数据，指令数据已经解析为人类可读的格式，包括指令的程序名称、程序 ID、指令参数等。</li></ul><p><code>preBalances</code> 和 <code>postBalances</code> 字段的数据类型是数组，是所有参与交易的账户的原生 SOL 余额（以 lamports 为单位），数组的索引位置与 <code>transaction.message.accountKeys</code>（后面会介绍）中的账户位置一一对应。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;postBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="number">493860324</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">2039280</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">2039280</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;postBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="number">495917225</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">2039280</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><code>preTokenBalances</code> 和 <code>postTokenBalances</code> 这 2 个数组字段只包含该交易中涉及代币变动的账户的代币余额信息，而不是所有账户。每个元素都包含 <code>accountIndex</code> 字段，指向 <code>accountKeys</code> 中的索引位置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;postTokenBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;accountIndex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;59obFNBzyTBGowrkif5uK7ojS58vsuWz3ZCvg6tfZAGw&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3CgvbiM3op4vjrrjH2zcrQUwsqh5veNVRjFCB9N6sRoD&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;programId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uiTokenAmount&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8802868&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;decimals&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;uiAmount&quot;</span><span class="punctuation">:</span> <span class="number">8.802868</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;uiAmountString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.802868&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="attr">&quot;preTokenBalances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;accountIndex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;59obFNBzyTBGowrkif5uK7ojS58vsuWz3ZCvg6tfZAGw&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3CgvbiM3op4vjrrjH2zcrQUwsqh5veNVRjFCB9N6sRoD&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;programId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uiTokenAmount&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8506130&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;decimals&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;uiAmount&quot;</span><span class="punctuation">:</span> <span class="number">8.50613</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;uiAmountString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.50613&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>代币余额信息包括：</p><ul><li>accountIndex: 对应 <code>accountKeys</code> 中的索引</li><li>mint: 代币铸造地址</li><li>owner: 代币账户所有者</li><li>uiTokenAmount: 代币数量信息（包括数量、精度和 UI 显示数量）</li></ul><p><code>logMessages</code> 字段是交易执行时程序输出的日志信息数组，每个元素是一行日志信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;logMessages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;Program ComputeBudget111111111111111111111111111111 invoke [1]&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;Program ComputeBudget111111111111111111111111111111 success&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;Program ComputeBudget111111111111111111111111111111 invoke [1]&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><code>rewards</code> 字段主要用于记录与区块验证和共识机制相关的奖励信息，是 Solana 经济模型的一个重要组成部分。对普通用户分析交易时，该字段通常不是重点关注内容，但对理解 Solana 的经济模型和奖励机制非常重要。</p><p><code>returnData</code> 字段是 Solana 程序向调用者返回数据的机制，允许程序在执行完成后传递结果数据。这个机制为 Solana 生态系统中的程序间通信提供了标准化的数据返回方式，特别在复杂的 DeFi 操作中非常有用。</p><h3 id="transaction-字段"><a href="#transaction-字段" class="headerlink" title="transaction 字段"></a>transaction 字段</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;transaction&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;accountKeys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;addressTableLookups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;instructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>…<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;recentBlockhash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;64DTRb3pnTsxvjNEnVLEpqwdoyFc388ydcf7EyMdcbTm&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;signatures&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;3AnirZmjF1U64zfCUyrzWBzNGvcaa3Ya7PacAD5Y5LRoHsnZsHSekQEAKGuMCbtGNWXChPe5uWQkvipDGwfUVNAx&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>message: 包含交易消息的对象。<ul><li>accountKeys: 参与交易的账户列表。</li><li>addressTableLookups: 地址查找表相关信息。</li><li>instructions: 交易包含的指令数组。</li><li>recentBlockhash: 交易使用的最近区块哈希。</li></ul></li><li>signatures: 交易签名数组，第一个通常是交易 ID。</li></ul><p><code>accountKeys</code> 字段是参与交易的账户列表，每个元素是一个账户对象，之前的 <code>meta</code> 字段中很多属性都与该字段有关联，包含以下信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;accountKeys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pubkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;21w1M4yesWyzVVryHuHqg7rLUMWtp78RRaH1Zz6vhwfB&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;signer&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;transaction&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;writable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li>pubkey: 账户公钥</li><li>signer: 是否为交易签名者</li><li>source: 账户来源（transaction 或 lookupTable）</li><li>writable: 是否可写</li></ul><p><code>addressTableLookups</code> 是 Solana 交易中的一个关键字段，主要用于解决交易账户数量限制问题，Solana 交易默认最多可包含 32 个直接账户引用，通过地址查找表可以引用更多账户，这样就突破账户数量限制。另外一个作用是减小交易大小，避免在交易中重复包含完整的 32 字节账户地址，仅包含查找表地址和索引，大幅减少交易数据体积。它的工作原理是事先在链上创建地址查找表（Address Lookup Table），该表存储多个常用账户地址，每个地址分配一个索引，交易中通过指定查找表地址和索引来引用账户，不需要包含完整的账户地址。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;addressTableLookups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;accountKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6dfGWWq4sTPFHPvnVBZNjQd2PTqzgGAexLAHXao7TRSb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;readonlyIndexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="number">17</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;writableIndexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">15</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><code>addressTableLookups</code> 字段中各字段含义：</p><ul><li>accountKey：地址查找表的公钥地址</li><li>readonlyIndexes：从查找表引用的只读账户索引</li><li>writableIndexes：从查找表引用的可写账户索引</li></ul><p>在交易时，交易处理器会找到 <code>accountKey</code> 指定的地址查找表，查找表中检索指定索引位置的账户地址，将这些地址添加到交易的账户列表中，根据是在 <code>readonlyIndexes</code> 还是 <code>writableIndexes</code> 中标记账户权限，这就是为什么在 <code>accountKeys</code> 数组中，有些账户的 <code>source</code> 值为 <code>lookupTable</code>，表明它们是通过地址查找表加载的，而不是直接包含在交易中。</p><p><code>transaction.message.instructions</code> 字段是交易包含的顶层指令数组，每个元素是一个顶层指令对象，顶层指令与 <code>meta</code> 字段中的 <code>innerInstructions</code> 内部指令的区别是：</p><ul><li>顶层指令是用户&#x2F;客户端显式包含在交易中的指令，在交易创建和签名时直接指定，代表交易的主要意图和行为，由交易者直接控制和构建，在交易提交时已确定，数量通常有限，按数组顺序执行，相当于程序的主函数或入口点，是触发后续一系列操作的起点。</li><li>内部指令是顶层指令执行过程中动态生成的派生指令，不在原始交易中显式指定，是程序执行逻辑的细节体现，当一个程序调用另一个程序（CPI）时产生，每组内部指令通过 <code>index</code> 字段关联到生成它的顶层指令，一个顶层指令可能生成多个内部指令，内部指令可能进一步产生更深层次的内部指令，形成指令调用树结构。</li></ul><p>我们可以在这些指令对象中看到 <code>stackHeight</code> 字段，该字段是指令在程序调用栈中的深度级别，反映了指令之间的调用层级关系，值为 <code>null</code> 通常表示顶层指令，值为 <code>1</code> 表示由顶层程序直接调用的指令，值为 <code>2</code> 表示由 <code>stackHeight</code> 为 <code>1</code> 的程序调用的指令，值为 <code>3+</code> 表示更深层次的嵌套调用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;transaction&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;instructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;accounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EC5es9&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;programId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ComputeBudget111111111111111111111111111111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stackHeight&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从实用角度出发，全面解析了 Solana 交易的查看方式和数据结构。无论你是通过浏览器快速查看交易详情，还是使用 RPC 接口进行深度分析，或是利用 Web3.js SDK 构建应用程序，都能在本文中找到最适合的方法和最佳实践。通过深入理解交易的 meta 和 transaction 字段、指令层级关系以及地址查找表等核心概念，你将具备分析任何 Solana 交易的能力。这些知识不仅是 Solana 开发的基础技能，更是在这个高性能区块链生态中构建优秀应用的必备工具。掌握了这些，你就拥有了解读 Solana 链上世界的钥匙。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://solana.com/docs/core/transactions">交易和指令</a></li><li><a href="https://docs.solscan.io/transaction-details/transaction-details">Solscan 交易详情</a></li><li><a href="https://info.solscan.io/exploring-account-page/">Solscan 账号页面</a></li><li><a href="https://solana.com/docs/rpc">Solana RPC 接口文档</a></li></ul><p>关注我，一起学习各种最新的 AI 和编程开发技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">深入解析 Solana 交易，包括查看方式、交易结构、交易解析等。</summary>
    
    
    
    <category term="solana" scheme="https://zhaozhiming.github.io/categories/solana/"/>
    
    
    <category term="solana" scheme="https://zhaozhiming.github.io/tags/solana/"/>
    
    <category term="transaction" scheme="https://zhaozhiming.github.io/tags/transaction/"/>
    
    <category term="solana-explorer" scheme="https://zhaozhiming.github.io/tags/solana-explorer/"/>
    
    <category term="solscan" scheme="https://zhaozhiming.github.io/tags/solscan/"/>
    
    <category term="solana-rpc" scheme="https://zhaozhiming.github.io/tags/solana-rpc/"/>
    
  </entry>
  
  <entry>
    <title>在 Solana 上实现布隆过滤器</title>
    <link href="https://zhaozhiming.github.io/2025/05/14/solana-bloom-filter/"/>
    <id>https://zhaozhiming.github.io/2025/05/14/solana-bloom-filter/</id>
    <published>2025-05-14T13:47:57.000Z</published>
    <updated>2025-05-19T13:24:35.072Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2025/05/solana-bloom-filter.png" class="" width="400" height="300"><p>在编程世界里，<a href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器</a>早已是耳熟能详的高效工具，它能迅速判定一个元素是否存在于集合中，其应用在网络爬虫、数据库查询和缓存系统中屡见不鲜。布隆过滤器凭借其超快的查询速度和极低的内存占用，能巧妙地减少无谓的数据传输与处理，从而极大地提升运行效率。但如果我们想在区块链上实现一个布隆过滤器，是否也能跟中心化互联网世界一样，达到既能存储大量数据又能快速查询的效果呢？今天我们就来带大家在 Solana 这个高性能区块链网络上实现一个布隆过滤器，同时揭示其在实际运行中可能遇到的各种奇妙问题。</p><span id="more"></span><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器由布尔顿・霍华德・布隆（Burton Howard Bloom）在 1970 年提出，它是一种用于检查元素是否属于集合的数据结构，以及在数据库和网络应用中进行高效的数据查询。布隆过滤器使用多个不同的哈希函数将元素映射到一个二进制数组中，通过检查相应的索引位置是否都被设置为 1 来判断元素是否存在。虽然布隆过滤器可能会产生误报（false positive），但不会产生漏报（false negative），即它能准确判断某元素不在集合中，但无法保证判断存在的元素确实存在。布隆过滤器的优势在于不管你要检测的集合有多大，使用布隆过滤器进行查找时所需的内存和时间都是非常低且固定的。此外，布隆过滤器的误报率可以通过调整哈希函数的数量和位数组的大小来控制。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><img src="/images/post/2025/05/bloom-filter.png" class="" width="1000" height="600"><p>这是布隆过滤器的一个示例图，我们可以从中看到布隆过滤器的几个重要的属性：</p><ul><li>位图大小（m）：位图数组的长度，决定了布隆过滤器所需的存储空间。</li><li>哈希函数的数量（k）：用于将元素映射到位图中的哈希函数个数，影响布隆过滤器的查询性能和误报率。</li><li>存储元素的数量（n）：布隆过滤器中需要存储的元素个数。</li><li>误报率（p）：表示的是一个不在布隆过滤器中的元素被错误地判断为在布隆过滤器中的概率。</li></ul><p>以上面的示例图为例，位图（值为 0 和 1）数组长度为 10， 所以 m 为 10，哈希函数有 3 个，所以 k 为 3，存储的元素 分别是 <code>Foo</code> 和 <code>Bar</code>，所以 n 为 2。根据其中的任意 3 个属性，我们都可以计算出第 4 个属性的值，它们的计算公式分别为：</p><ul><li><code>n = ceil(m / (-k / log(1 - exp(log(p) / k))))</code></li><li><code>p = pow(1 - exp(-k / (m / n)), k)</code></li><li><code>m = ceil((n \* log(p)) / log(1 / pow(2, log(2))))</code></li><li><code>k = round((m / n) \* log(2))</code></li></ul><h3 id="为什么会出现误报率"><a href="#为什么会出现误报率" class="headerlink" title="为什么会出现误报率"></a>为什么会出现误报率</h3><p>以示例图中的例子为例，我们假设的情形如下：</p><ol><li>初始化布隆过滤器，长度 m &#x3D; 10 的布隆过滤器，初始时所有位都是 0，表示为：<code>0 0 0 0 0 0 0 0 0 0</code>。</li><li>插入元素 <code>Foo</code>，假设使用的 3 个哈希函数得到的索引分别为：0、2、4，插入 <code>Foo</code> 后，将索引 0、2、4 位置的位设为 1，布隆过滤器变为：<code>1 0 1 0 1 0 0 0 0 0</code>。</li><li>插入元素 <code>Bar</code>，假设 <code>Bar</code> 的 3 个哈希函数得到的索引分别为：4、7、9，插入 <code>Bar</code> 后，将索引 4、7、9 位置的位设为 1，布隆过滤器变为：<code>1 0 1 0 1 0 0 1 0 1</code>。</li><li>产生误报的情况，现在假设查询一个未插入的元素 <code>Baz</code>，如果 <code>Baz</code> 的 3 个哈希函数计算出来的索引碰巧为：2、4、9，此时，我们在布隆过滤器中查看索引 2、4、9 的位，发现它们都为 1。因为所有对应位置都是 1，布隆过滤器会判断 <code>Baz</code> 可能存在，即返回<strong>存在</strong>的结果，实际上 <code>Baz</code> 并没有被插入，这就是误报。</li></ol><p>那么误报率多少是合适的呢？一般来说，1% 左右的误报率常见且合适，在很多应用场景中，1% 的误报率被认为是一个较好的折衷方案：既能节省内存，又不会对系统的整体性能产生太大影响。如果应用对准确性要求非常高，可以将误报率降低到 0.1% 甚至更低。但这通常会需要更大的位图大小 <code>m</code> 或者更多的哈希函数 <code>k</code>（但 <code>k</code> 并不是越大越好，太大了反而可能加大误报率），从而增加存储和计算开销。所以这个问题没有标准答案，选择多少误报率合适取决于你的具体场景。例如，在缓存系统、数据库索引等场景下，1% 的误报率已经足够；而在医疗或金融系统中，可能会追求更低的误报率以减少潜在风险。</p><p>在这里推荐一个布隆过滤器的在线计算工具：<a href="https://hur.st/bloomfilter">Bloom Filter Calculator</a>，可以帮助你快速计算布隆过滤器的各种属性。</p><h2 id="实现布隆过滤器"><a href="#实现布隆过滤器" class="headerlink" title="实现布隆过滤器"></a>实现布隆过滤器</h2><p>下面我们来演示如何在 <a href="https://solana.com/">Solana</a> 上实现一个布隆过滤器，我们将使用 Anchor 来编写程序，实现的代码包括布隆过滤器的初始化、插入元素、查询元素等操作，同时有相关的测试代码，以便验证布隆过滤器的正确性。</p><blockquote><p><a href="https://www.anchor-lang.com/">Anchor</a> 是 Solana 区块链上广泛使用的开发框架，用于简化程序（智能合约）和去中心化应用（DApp）的开发流程。它为开发者提供了一套高效且直观的工具和库，极大降低了 Solana 应用开发的门槛，Solana 官方推荐使用 Anchor 进行开发。</p></blockquote><h3 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h3><p>首先我们需要定义一个布隆过滤器的数据结构，包括布隆过滤器的名称、位图大小、哈希函数数量等属性，示例代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state.rs</span></span><br><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MAX_FILTER_SIZE: <span class="type">usize</span> = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[account]</span></span><br><span class="line"><span class="meta">#[derive(InitSpace)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="comment">// filter name</span></span><br><span class="line">    <span class="meta">#[max_len(32)]</span></span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="comment">// the bit array</span></span><br><span class="line">    <span class="meta">#[max_len(MAX_FILTER_SIZE)]</span></span><br><span class="line">    <span class="keyword">pub</span> bit_array: <span class="type">Vec</span>&lt;<span class="type">bool</span>&gt;,</span><br><span class="line">    <span class="comment">// size of the bit array</span></span><br><span class="line">    <span class="keyword">pub</span> m: <span class="type">u32</span>,</span><br><span class="line">    <span class="comment">// number of hash functions</span></span><br><span class="line">    <span class="keyword">pub</span> k: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// number of elements in the filter</span></span><br><span class="line">    <span class="keyword">pub</span> n: <span class="type">u32</span>,</span><br><span class="line">    <span class="comment">// false positive rate</span></span><br><span class="line">    <span class="keyword">pub</span> false_positive_rate: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>名称 name 用于标识布隆过滤器，长度最大为 32 字节</li><li><code>bit_array</code> 是一个布尔类型的数组，用于存储布隆过滤器的位图，因为 Solana Account 在初始化时需要指定固定的长度，所以我们定义了一个最大长度 <code>MAX_FILTER_SIZE</code> 来作为 bit_array 的最大长度</li><li><code>m</code> 是位图的大小，是 bit_array 的实际长度</li><li><code>k</code> 是哈希函数的数量</li><li><code>n</code> 是布隆过滤器中存储的元素数量</li><li><code>false_positive_rate</code> 是误报率，范围为 0 到 1</li></ul><p>定义好数据结构后，我们来实现布隆过滤器的初始化指令，示例代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instructions/init.rs</span></span><br><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"><span class="keyword">use</span> solana_program::log::sol_log_compute_units;</span><br><span class="line"><span class="keyword">use</span> crate::state::&#123;BloomFilter, NewFilter, BLOOM_FILTER_NAME&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="meta">#[instruction(new_filter: NewFilter)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Init</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> user: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init,</span></span><br><span class="line"><span class="meta">        payer = user,</span></span><br><span class="line"><span class="meta">        space = 8 + BloomFilter::INIT_SPACE,</span></span><br><span class="line"><span class="meta">        seeds = [</span></span><br><span class="line"><span class="meta">            BLOOM_FILTER_NAME.as_bytes(),</span></span><br><span class="line"><span class="meta">            user.key().as_ref(),</span></span><br><span class="line"><span class="meta">            new_filter.name.as_bytes()</span></span><br><span class="line"><span class="meta">        ]</span>,</span><br><span class="line">        bump</span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> filter: <span class="type">Box</span>&lt;Account&lt;<span class="symbol">&#x27;info</span>, BloomFilter&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(ctx: Context&lt;Init&gt;, new_filter: NewFilter) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// validate the filter parameters</span></span><br><span class="line">    new_filter.<span class="title function_ invoke__">validate</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the bloom filter</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filter</span> = &amp;<span class="keyword">mut</span> ctx.accounts.filter;</span><br><span class="line">    filter.<span class="title function_ invoke__">init</span>(new_filter)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义了一个 <code>Init</code> 上下文结构，在 Anchor 框架中，每个指令都需要有一个关联的 Context 结构</li><li>在这个结构中，我们用到了指令的参数 <code>new_filter</code>，可以看到在 <code>init</code> 方法中也有同样的参数。<code>#[instruction(...)]</code> 属性用于声明指令的参数，这些参数会被传递到指令处理函数中作为额外的参数，参数可以在账户验证逻辑中使用</li><li><code>Init</code> 结构中包含了用户签名、布隆过滤器账号、系统程序等信息，其中 <code>filter</code> 是 通过<a href="https://solana.com/docs/core/pda">程序派生地址（PDA）</a> 创建的账号</li><li>这个 PDA 账号使用了 <code>BLOOM_FILTER_NAME</code>、用户地址和新布隆过滤器的名称作为种子，通过 <code>bump</code> 参数来生成地址</li><li><code>filter</code> 账号的数据结构实际上就是我们之前定义的 <code>BloomFilter</code></li><li><code>init</code> 函数用于初始化布隆过滤器，首先使用参数 <code>new_filter</code> 来验证新布隆过滤器的参数，然后通过上下文对象 <code>ctx</code> 获取 <code>filter</code> 账号，最后调用 <code>filter</code> 的 <code>init</code> 方法来初始化布隆过滤器</li></ul><p>我们再来看初始化指令中用到的一些参数和方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state.rs</span></span><br><span class="line"><span class="meta">#[derive(AnchorSerialize, AnchorDeserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewFilter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> num_hashes: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">NewFilter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">validate</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">0</span> || <span class="keyword">self</span>.num_hashes == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err!(BloomFilterError::InvalidParameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.size <span class="keyword">as</span> <span class="type">usize</span> &gt; MAX_FILTER_SIZE &#123;</span><br><span class="line">            <span class="keyword">return</span> err!(BloomFilterError::FilterTooLarge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="comment">// initialize the bloom filter</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_filter: NewFilter) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.bit_array = <span class="built_in">vec!</span>[<span class="literal">false</span>; new_filter.size <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">        <span class="keyword">self</span>.name = new_filter.name.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">self</span>.m = new_filter.size;</span><br><span class="line">        <span class="keyword">self</span>.k = new_filter.num_hashes;</span><br><span class="line">        <span class="keyword">self</span>.n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.false_positive_rate = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>NewFilter</code> 结构用于表示初始化指令的参数，表示我们初始化一个布隆过滤器需要传入这几个参数：名称、位图大小和哈希函数数量</li><li><code>validate</code> 方法用于验证参数的有效性，包括位图大小和哈希函数数量不能为 0，位图大小不能超过 <code>MAX_FILTER_SIZE</code></li><li><code>init</code> 方法用于初始化布隆过滤器，首先根据参数 <code>new_filter</code> 初始化位图数组 <code>bit_array</code>，然后设置布隆过滤器的名称、位图大小、哈希函数数量，位图数组中的元素数量初始化时为 0，误报率也为 0</li></ul><p>最后在 <code>lib.rs</code> 中导入相关模块和方法，这样我们的初始化指令就完成了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"><span class="meta">#[program]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> bloom_filter &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(ctx: Context&lt;Init&gt;, new_filter: NewFilter) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        instructions::<span class="title function_ invoke__">init</span>(ctx, new_filter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他还有<code>add</code>、<code>check</code> 等指令的实现，这里就不再赘述了，完整代码可以参考 <a href="https://github.com/zhaozhiming/bloom-filter-solana">bloom-filter-solana</a> 仓库。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>所有的程序指令完成之后，我们需要编写测试来验证我们的布隆过滤器是否能正常工作，所幸 Anchor 提供了一套完善的测试框架，可以方便地编写测试代码。</p><p>在写测试案例之前，我们需要准备好测试的上下文环境，示例代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">AnchorError</span>,</span><br><span class="line">  <span class="title class_">AnchorProvider</span>,</span><br><span class="line">  <span class="title class_">Program</span>,</span><br><span class="line">  setProvider,</span><br><span class="line">  workspace,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@coral-xyz/anchor&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Connection</span>,</span><br><span class="line">  <span class="title class_">Keypair</span>,</span><br><span class="line">  <span class="variable constant_">LAMPORTS_PER_SOL</span>,</span><br><span class="line">  <span class="title class_">PublicKey</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@solana/web3.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&quot;chai&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; v4 <span class="keyword">as</span> uuidv4 &#125; <span class="keyword">from</span> <span class="string">&quot;uuid&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BloomFilter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../target/types/bloom_filter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BLOOM_FILTER_NAME</span> = <span class="string">&quot;bloom-filter&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BLOOM_FILTER_SEED</span> = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="variable constant_">BLOOM_FILTER_NAME</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;bloom-filter&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Solana attributes</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">provider</span>: <span class="title class_">AnchorProvider</span> = <span class="title class_">AnchorProvider</span>.<span class="title function_">local</span>();</span><br><span class="line">  <span class="title function_">setProvider</span>(provider);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">connection</span>: <span class="title class_">Connection</span> = provider.<span class="property">connection</span>;</span><br><span class="line">  <span class="keyword">const</span> program = workspace.<span class="property">BloomFilter</span> <span class="keyword">as</span> <span class="title class_">Program</span>&lt;<span class="title class_">BloomFilter</span>&gt;;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">Keypair</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">filterAddress</span>: <span class="title class_">PublicKey</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">before</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    user = <span class="title class_">Keypair</span>.<span class="title function_">generate</span>();</span><br><span class="line">    <span class="keyword">const</span> airdropTxSignature = <span class="keyword">await</span> connection.<span class="title function_">requestAirdrop</span>(</span><br><span class="line">      user.<span class="property">publicKey</span>,</span><br><span class="line">      <span class="variable constant_">LAMPORTS_PER_SOL</span> * <span class="number">500</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> lastBlockHash = <span class="keyword">await</span> connection.<span class="title function_">getLatestBlockhash</span>();</span><br><span class="line">    <span class="keyword">await</span> connection.<span class="title function_">confirmTransaction</span>(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">signature</span>: airdropTxSignature,</span><br><span class="line">        <span class="attr">blockhash</span>: lastBlockHash.<span class="property">blockhash</span>,</span><br><span class="line">        <span class="attr">lastValidBlockHeight</span>: lastBlockHash.<span class="property">lastValidBlockHeight</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;confirmed&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [pda] = <span class="title class_">PublicKey</span>.<span class="title function_">findProgramAddressSync</span>(</span><br><span class="line">      [</span><br><span class="line">        <span class="variable constant_">BLOOM_FILTER_SEED</span>,</span><br><span class="line">        user.<span class="property">publicKey</span>.<span class="title function_">toBuffer</span>(),</span><br><span class="line">        <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="variable constant_">BLOOM_FILTER_NAME</span>, <span class="string">&quot;utf-8&quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">      program.<span class="property">programId</span></span><br><span class="line">    );</span><br><span class="line">    filterAddress = pda;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>首先我们初始化 Solana 环境的 Provider、Connection 和 Program</li><li>然后在 <code>before</code> 钩子函数中创建一个用户账号 <code>user</code>，并对这个账号空投了 500 SOL 作为账号的测试费用</li><li>接着通过 PDA 推导的方式得到布隆过滤器账号 <code>filterAddress</code> 的账号地址，后面可以用这个账号来进行验证</li></ul><p>接着我们再来看布隆过滤器初始化指令 <code>init</code> 的测试代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;initialize bloom filter&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;initialize bloom filter with correct name, size and hash functions&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> program.<span class="property">methods</span></span><br><span class="line">      .<span class="title function_">init</span>(newFilter)</span><br><span class="line">      .<span class="title function_">accounts</span>(&#123;</span><br><span class="line">        <span class="attr">user</span>: user.<span class="property">publicKey</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">signers</span>([user])</span><br><span class="line">      .<span class="title function_">rpc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> filter = <span class="keyword">await</span> program.<span class="property">account</span>.<span class="property">bloomFilter</span>.<span class="title function_">fetch</span>(filterAddress);</span><br><span class="line">    <span class="title function_">expect</span>(filter.<span class="property">name</span>).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="variable constant_">BLOOM_FILTER_NAME</span>);</span><br><span class="line">    <span class="title function_">expect</span>(filter.<span class="property">m</span>).<span class="property">to</span>.<span class="title function_">equal</span>(newFilter.<span class="property">size</span>);</span><br><span class="line">    <span class="title function_">expect</span>(filter.<span class="property">k</span>).<span class="property">to</span>.<span class="title function_">equal</span>(newFilter.<span class="property">numHashes</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>测试程序中首先定义了 <code>init</code> 方法的参数 <code>newFilter</code>，包括布隆过滤器的名称、位图大小和哈希函数数量</li><li>然后调用 <code>program.methods.init</code> 方法来初始化布隆过滤器，传入参数 <code>newFilter</code>，并指定用户账号 <code>user</code> 为签名者</li><li>虽然在 Rust 代码中 <code>init</code> 方法的 Context 结构中有 3 个账号， 但在测试代码中只需要传入一个用户账号 <code>user</code> 即可，<code>program.methods.init</code> 方法会根据 Rust 程序中定义的 seeds 和 bump 自动推导出 filter 账户的地址，并且会自动包含 system_program 作为依赖</li><li>最后通过 <code>program.account.bloomFilter.fetch</code> 方法获取布隆过滤器账号的数据，然后验证布隆过滤器的名称、位图大小和哈希函数数量是否正确</li></ul><p>其他指令的测试代码与 <code>init</code> 指令的测试代码类似，这里就不再赘述了，完整代码可以参考 <a href="https://github.com/zhaozhiming/bloom-filter-solana">bloom-filter-solana</a> 仓库。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>现在我们了解了布隆过滤器在 Solana 程序中的基本实现，但是布隆过滤器在 Solana 网络中实际运行的结果可能与我们期望的有所不同。虽然布隆过滤器可以使用少量的资源来存储和检查大量的数据，但是区块链网络的资源是非常受限的，不管是存储空间还是计算单元（CU），只要程序运行时超过任何一方的限制都会导致程序运行失败，接下来我们就来看看布隆过滤器在 Solana 网络中实际运行的情况。</p><blockquote><p>在 Solana 区块链中，CU 是衡量交易执行时消耗的计算资源最小单位。每笔交易在链上运行时，由于执行不同的指令（如账户写入、跨程序调用、系统调用等），会消耗一定数量的 CU。</p></blockquote><h3 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小"></a>存储大小</h3><p>我们可以通过 <code>init</code> 初始化指令的测试代码来分析布隆过滤器在 Solana 网络中实际的存储大小，我们在之前的测试代码上加上获取布隆过滤器账号存储大小的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;initialize bloom filter with correct name, size and hash functions&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// add the code to get the account size</span></span><br><span class="line">  <span class="keyword">const</span> accountInfo = <span class="keyword">await</span> connection.<span class="title function_">getAccountInfo</span>(filterAddress);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;account size:&quot;</span>, accountInfo?.<span class="property">data</span>.<span class="property">length</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>在测试代码中，我们初始化了一个位图数组长度为 1000 且哈希函数数量为 8 的布隆过滤器</li><li>在测试方法最后通过 <code>connection.getAccountInfo</code> 方法获取布隆过滤器账号的存储大小</li></ul><p>然后我们运行这个测试用例，看看实际的存储大小是多少：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ anchor <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">bloom-filter</span><br><span class="line">    initialize bloom filter</span><br><span class="line">account size: 10065</span><br><span class="line">      ✔ initialize bloom filter with correct name, size and <span class="built_in">hash</span> <span class="built_in">functions</span> (461ms)</span><br></pre></td></tr></table></figure><p>从测试结果中我们可以看到，布隆过滤器账号的存储大小为 10065 字节。我们继续实验，将测试代码中的位图数组长度 <code>size</code> 修改为 2000，看看修改后账号的存储大小是否有变化，再次运行完程序后，我们惊奇地发现，布隆过滤器账号的存储大小并没有变化，仍然是 10065 字节。这是什么原因呢？</p><p>我们回过头去看下 <code>init</code> 指令的 Rust 代码，发现布隆过滤器的位图数组的最大长度在最开始时是由常量 <code>MAX_FILTER_SIZE</code> 决定的，因为 Solana 账号在初始化时需要指定固定长度，而 <code>init</code> 指令中传递的位图数组长度是实际使用的长度，这个长度不能超过 <code>MAX_FILTER_SIZE</code> 的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MAX_FILTER_SIZE: <span class="type">usize</span> = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="meta">#[max_len(MAX_FILTER_SIZE)]</span></span><br><span class="line">    <span class="keyword">pub</span> bit_array: <span class="type">Vec</span>&lt;<span class="type">bool</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_filter: NewFilter) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.bit_array = <span class="built_in">vec!</span>[<span class="literal">false</span>; new_filter.size <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以无论我们在测试代码中初始化时设置的位图数组长度是多少，布隆过滤器的账号的存储大小都不会变化，其大小都是按照位图数组最大长度 10000 来计算的。</p><p>如果我们修改了位图数组最大长度 <code>MAX_FILTER_SIZE</code> 的值，比如设置为 2000（原来的五分之一），看看实际的存储大小是否有变化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ anchor <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">bloom-filter</span><br><span class="line">    initialize bloom filter</span><br><span class="line">account size: 2065</span><br><span class="line">      ✔ initialize bloom filter with correct name, size and <span class="built_in">hash</span> <span class="built_in">functions</span> (463ms)</span><br></pre></td></tr></table></figure><p>可以看到，这一次布隆过滤器账号的存储大小变成了 2065 字节，证明我们的推断是正确的。然而当我们把最大长度修改为 20000 后（原来的两倍），运行程序则会直接报错，这是因为 Anchor 通过 <a href="https://solana.com/docs/core/cpi">Cross Program Invocation</a>（CPI）作为内部指令来为账户分配存储空间，每个内部指令允许的最大重新分配空间为 10240 字节，也就是 10KB，当我们的账号大小超过这个限制时，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bloom-filter</span><br><span class="line">       initialize bloom filter</span><br><span class="line">         initialize bloom filter with correct name, size and <span class="built_in">hash</span> <span class="built_in">functions</span>:</span><br><span class="line">     Error: Simulation failed.</span><br><span class="line">Message: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data.</span><br><span class="line">Logs:</span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;Program 25vTrRPxj41T6BituXJC3fDh8PxS3Jf14AfzFU44gfCS invoke [1]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program log: Instruction: Init&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program 11111111111111111111111111111111 invoke [2]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program 11111111111111111111111111111111 success&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Account data size realloc limited to 10240 in inner instructions&quot;</span>,</span><br><span class="line">  ......</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p><strong>小结：</strong> 布隆过滤器的存储大小与账号初始化时设置的位图数组最大长度有关，最大长度越大，账号的存储大小越大，但最大长度建议不要超过 10000，否则会报超过账号重分配大小限制的错误。</p><h3 id="CU-消耗"><a href="#CU-消耗" class="headerlink" title="CU 消耗"></a>CU 消耗</h3><p>现在我们知道布隆过滤器在 Solana 网络的存储大小限制下，可以存储的位图数组是大约 10000 个元素，但在实际运行中，布隆过滤器真的可以存储这么多元素吗？我们可以通过运行测试代码来观察布隆过滤器在实际运行中消耗的 CU 情况。</p><h4 id="init-指令"><a href="#init-指令" class="headerlink" title="init 指令"></a><code>init</code> 指令</h4><p>首先我们看下 <code>init</code> 指令的 CU 消耗情况，<code>init</code> 指令的测试代码如之前所示（<code>it(&quot;initialize bloom filter with correct name, size and hash functions&quot;</code> 方法），我们分别运行当 size &#x3D; 1000、2000、3000 且 k &#x3D; 8 时的测试程序，当执行测试命令 <code>anchor test</code> 后，我们可以在 <code>.anchor/program-logs</code> 目录下找到对应的日志文件，日志文件中会记录每个测试方法的 CU 消耗情况，运行后的测试结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;initialize bloom filter with correct name, size and hash functions&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">1000</span>, <span class="comment">// modify the size to observe the CU consumption</span></span><br><span class="line">    <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  ......</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test result:</span></span><br><span class="line"><span class="comment">// 1000 size, 8 numHashes: 65965 CU</span></span><br><span class="line"><span class="comment">// 2000 size, 8 numHashes: 122965 CU</span></span><br><span class="line"><span class="comment">// 3000 size, 8 numHashes: 179967 CU</span></span><br></pre></td></tr></table></figure><p>从测试结果可以看出，当 size &#x3D; 1000 时，<code>init</code> 指令的 CU 消耗为 65965 CU，而当 size 为 2000 和 3000 时，<code>init</code> 指令的 CU 消耗成倍增长，分别为 122965 CU 和 179967 CU。如果继续将 size 增加到 4000 ，<code>init</code> 指令的 CU 消耗就会超过指令的 CU 限制，导致程序运行失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bloom-filter</span><br><span class="line">       initialize bloom filter</span><br><span class="line">         initialize bloom filter with correct name, size and <span class="built_in">hash</span> <span class="built_in">functions</span>:</span><br><span class="line">     Error: Simulation failed.</span><br><span class="line">Message: Transaction simulation failed: Error processing Instruction 0: Program failed to complete.</span><br><span class="line">Logs:</span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;Program 25vTrRPxj41T6BituXJC3fDh8PxS3Jf14AfzFU44gfCS invoke [1]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program log: Instruction: Init&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program 11111111111111111111111111111111 invoke [2]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program 11111111111111111111111111111111 success&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program log: init bloom filter&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program consumption: 191663 units remaining&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program 25vTrRPxj41T6BituXJC3fDh8PxS3Jf14AfzFU44gfCS consumed 200000 of 200000 compute units&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Program 25vTrRPxj41T6BituXJC3fDh8PxS3Jf14AfzFU44gfCS failed: exceeded CUs meter at BPF instruction&quot;</span></span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>我们再来看修改函数数量 <code>k</code> 的 CU 消耗情况，我们用同样的方式进行测试，分别运行当 k &#x3D; 8、16、32 且 size &#x3D; 1000 时的测试程序，运行后的测试结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;initialize bloom filter with correct name, size and hash functions&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">numHashes</span>: <span class="number">8</span>, <span class="comment">// modify the numHashes to observe the CU consumption</span></span><br><span class="line">  &#125;;</span><br><span class="line">  ......</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test result:</span></span><br><span class="line"><span class="comment">// 1000 size, 8 numHashes: 65965 CU</span></span><br><span class="line"><span class="comment">// 1000 size, 16 numHashes: 65965 CU</span></span><br><span class="line"><span class="comment">// 1000 size, 32 numHashes: 65965 CU</span></span><br></pre></td></tr></table></figure><p>从测试结果可以看出，函数数量的增长对于 CU 的消耗影响不大，<code>init</code> 指令的 CU 消耗基本保持不变。</p><h4 id="add-指令"><a href="#add-指令" class="headerlink" title="add 指令"></a><code>add</code> 指令</h4><p>接下来我们看下 <code>add</code> 指令的 CU 消耗情况，<code>add</code> 指令的测试代码（<code>describe(&quot;add element&quot;)</code> 方法）可在 <a href="https://github.com/zhaozhiming/bloom-filter-solana">bloom-filter-solana</a> 仓库中找到，我们分别运行当布隆过滤器的 size &#x3D; 1000、2000、3000 且 k &#x3D; 8 时的 <code>add</code> 指令测试程序，运行后的测试结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;add element&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">1000</span>, <span class="comment">// modify the size to observe the CU consumption</span></span><br><span class="line">      <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ......</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;successfully add a single element&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;......&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test result:</span></span><br><span class="line"><span class="comment">// 1000 size, 8 numHashes: 99756 CU</span></span><br><span class="line"><span class="comment">// 2000 size, 8 numHashes: 179865 CU</span></span><br><span class="line"><span class="comment">// 3000 size, 8 numHashes: Reached maximum CU limit</span></span><br></pre></td></tr></table></figure><p>从测试结果可以看出，当 size &#x3D; 1000 时，<code>add</code> 指令的 CU 消耗为 99756 CU，当 size 为 2000 时，<code>add</code> 指令的 CU 消耗为 179865 CU，当 size 为 3000 时，<code>add</code> 指令的 CU 消耗超过了单个指令的 CU 限制(200000 CU)，导致程序运行失败。</p><p>我们再来看修改函数数量 <code>k</code> 后 <code>add</code> 指令的 CU 消耗情况，我们用同样的方式进行测试，分别运行当 k &#x3D; 8、16、32 且 size &#x3D; 1000 时的测试程序，运行后的测试结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;add element&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">numHashes</span>: <span class="number">8</span>, <span class="comment">// modify the numHashes to observe the CU consumption</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ......</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;successfully add a single element&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;......&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test result:</span></span><br><span class="line"><span class="comment">// 1000 size, 8 numHashes: 99756 CU</span></span><br><span class="line"><span class="comment">// 1000 size, 16 numHashes: 104770 CU</span></span><br><span class="line"><span class="comment">// 1000 size, 32 numHashes: 114390 CU</span></span><br></pre></td></tr></table></figure><p>从测试结果可以看出，函数数量的增长对于 CU 的消耗影响不大，<code>add</code> 指令的 CU 消耗随着函数数量的增加而增加，增幅大约为 10000 CU。</p><h4 id="check-指令"><a href="#check-指令" class="headerlink" title="check 指令"></a><code>check</code> 指令</h4><p>最后我们来看下 <code>check</code> 指令的 CU 消耗情况，<code>check</code> 指令的测试代码（<code>describe(&quot;check element&quot;)</code> 方法）可在 <a href="https://github.com/zhaozhiming/bloom-filter-solana">bloom-filter-solana</a> 仓库中找到，我们分别运行当布隆过滤器的 size &#x3D; 1000、2000、3000 且 k &#x3D; 8 时的 <code>check</code> 指令测试程序，运行后的测试结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;check element&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">before</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// init bloom filter</span></span><br><span class="line">    <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ......</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// add element</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;should return true if element is in bloom filter&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;......&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test result:</span></span><br><span class="line"><span class="comment">// 1000 size, 8 numHashes: 29886 CU</span></span><br><span class="line"><span class="comment">// 2000 size, 8 numHashes: 52886 CU</span></span><br><span class="line"><span class="comment">// 3000 size, 8 numHashes: Reached maximum CU limit</span></span><br></pre></td></tr></table></figure><p><code>check</code> 指令首先需要通过 <code>add</code> 指令来添加布隆过滤器的元素，所以它的 CU 消耗受限于 <code>add</code> 指令的 CU 消耗。从测试结果可以看出，<code>check</code> 指令的 CU 消耗从位图数组长度 1000 增加到 2000 时，增加的幅度不足位图数组长度 1000 时的 2 倍。当位图数组长度增加到 3000 时，<code>check</code> 指令由于 <code>add</code> 指令的 CU 消耗超过了单个指令的 CU 限制，导致程序运行失败。</p><p>我们再来看修改函数数量 <code>k</code> 后 <code>check</code> 指令的 CU 消耗情况，我们用同样的方式进行测试，分别运行当 k &#x3D; 8、16、32 且 size &#x3D; 1000 时的测试程序，运行后的测试结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/bloom_filter.ts</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;check element&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">before</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// init bloom filter</span></span><br><span class="line">    <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ......</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// add element</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;should return true if element is in bloom filter&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;......&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test result:</span></span><br><span class="line"><span class="comment">// 1000 size, 8 numHashes: 29886 CU</span></span><br><span class="line"><span class="comment">// 1000 size, 16 numHashes: 34774 CU</span></span><br><span class="line"><span class="comment">// 1000 size, 32 numHashes: 44550 CU</span></span><br></pre></td></tr></table></figure><p>从测试结果可以看出，函数数量的增长对于 CU 的消耗影响不大，<code>check</code> 指令的 CU 消耗随着函数数量的增加而增加，增幅大约为 5000~10000 CU。</p><h3 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h3><p>通过以上测试，我们可以得到以下结论：</p><ul><li>布隆过滤器在 Solana 网络中，位图数组长度 <code>m</code> 最大可以设置为 2000 多一些，且不能超过 3000</li><li>函数数量 <code>k</code> 可以设置为 1~32+ ，但不是越大越好，<code>k</code> 超过一定数量之后误判率反而会升高</li></ul><p>如果我们想控制布隆过滤器的误报率 <code>p</code> 在 <code>0.01</code> 以下，那么根据公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = ceil(m / (-k / log(1 - exp(log(p) / k))))</span><br></pre></td></tr></table></figure><p>我们可以算出存储元素的数量 <code>n</code> 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = 0.01 (1 in 100)</span><br><span class="line">m = 2000 (250B)</span><br><span class="line">k = 8</span><br><span class="line">n = 207</span><br></pre></td></tr></table></figure><p>也就是说，当布隆过滤器的位图数组长度为 2000 且函数数量为 8 时，最多可以存储 207 个元素，如果超过这个数量，布隆过滤器的误报率会超过 0.01，我们可以写一个性能测试来验证这个结论：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;performance&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">before</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="comment">// init bloom filter</span></span><br><span class="line">      <span class="keyword">const</span> newFilter = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="variable constant_">BLOOM_FILTER_NAME</span>,</span><br><span class="line">        <span class="attr">size</span>: <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">numHashes</span>: <span class="number">8</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> program.<span class="property">methods</span></span><br><span class="line">        .<span class="title function_">init</span>(newFilter)</span><br><span class="line">        .<span class="title function_">accounts</span>(&#123;</span><br><span class="line">          <span class="attr">user</span>: user.<span class="property">publicKey</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">signers</span>([user])</span><br><span class="line">        .<span class="title function_">rpc</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;performance test&quot;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="comment">// Add elements with a delay between each call</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">207</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> program.<span class="property">methods</span></span><br><span class="line">          .<span class="title function_">add</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">`element-<span class="subst">$&#123;i&#125;</span>`</span>, <span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">          .<span class="title function_">accounts</span>(&#123;</span><br><span class="line">            <span class="attr">user</span>: user.<span class="property">publicKey</span>,</span><br><span class="line">            <span class="attr">filter</span>: filterAddress,</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">signers</span>([user])</span><br><span class="line">          .<span class="title function_">rpc</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for 10ms before the next call</span></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">10</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> filter = <span class="keyword">await</span> program.<span class="property">account</span>.<span class="property">bloomFilter</span>.<span class="title function_">fetch</span>(filterAddress);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;filter name&quot;</span>, filter.<span class="property">name</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;filter m&quot;</span>, filter.<span class="property">m</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;filter k&quot;</span>, filter.<span class="property">k</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;filter n&quot;</span>, filter.<span class="property">n</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;filter falsePositiveRate&quot;</span>, filter.<span class="property">falsePositiveRate</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"># test <span class="attr">result</span>:</span><br><span class="line"></span><br><span class="line">  bloom-filter</span><br><span class="line">    performance</span><br><span class="line">filter name bloom-filter</span><br><span class="line">filter m <span class="number">2000</span></span><br><span class="line">filter k <span class="number">8</span></span><br><span class="line">filter n <span class="number">207</span></span><br><span class="line">filter falsePositiveRate <span class="number">0.010105245890285032</span></span><br><span class="line">      ✔ check account size when add <span class="title function_">elements</span> (100192ms)</span><br></pre></td></tr></table></figure><p>测试中我们通过调用 <code>add</code> 方法添加了 207 个元素， 然后分别打印出布隆过滤器的名称、位图数组长度、函数数量、存储元素的数量、误报率，通过测试结果可以看出，布隆过滤器的误报率大约为 0.01，与理论计算结果一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Solana 上的布隆过滤器虽然有诸多限制，但通过合理的设计和优化，它仍然能在许多场景中发挥重要作用。以下是几个典型的应用场景：</p><ul><li>特定场景下的应用价值：即使只能存储 200 多个元素，在某些特定用例中仍然非常有用。例如验证小型白名单、简单权限控制或轻量级重复数据检测等场景。</li><li>链下与链上结合使用：可以将布隆过滤器作为链上和链下系统的桥梁。大量数据存储在链下，只在链上保存验证所需的布隆过滤器。</li><li>分片使用：可以创建多个布隆过滤器账号，每个处理不同的数据子集，类似于分布式哈希表的思想。</li><li>作为初筛工具：布隆过滤器可以作为第一道防线，快速排除明确不在集合中的元素，减少需要进行更详细验证的数据量。</li></ul><p>布隆过滤器在 Solana 上的应用需要针对其限制进行优化设计。它不适合存储大量数据，但对于特定用例和优化场景下仍有其独特价值，关键是理解你的应用需求，评估布隆过滤器是否真的是最佳选择。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hur.st/bloomfilter">Bloom Filter Calculator</a></li></ul><p>关注我，一起学习各种最新的 AI 和编程开发技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">通过一个完整的代码示例来介绍布隆过滤器在 Solana 上如何实现。</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="solana" scheme="https://zhaozhiming.github.io/tags/solana/"/>
    
    <category term="anchor" scheme="https://zhaozhiming.github.io/tags/anchor/"/>
    
    <category term="bloom filter" scheme="https://zhaozhiming.github.io/tags/bloom-filter/"/>
    
  </entry>
  
  <entry>
    <title>深入解密 Solana 开发中的资源限制——存储篇</title>
    <link href="https://zhaozhiming.github.io/2025/02/22/solana-storage-limitation/"/>
    <id>https://zhaozhiming.github.io/2025/02/22/solana-storage-limitation/</id>
    <published>2025-02-22T09:04:40.000Z</published>
    <updated>2025-05-19T06:50:35.610Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2025/02/solana-limitation-storage.jpeg" class="" width="400" height="300"><p>上一期我们介绍了 Solana 程序资源限制中的 Compute Unit（以下简称 CU ）部分，今天我们再来介绍 Solana 程序资源限制中的存储部分。Solana 的存储限制主要是指 Solana 账号中的存储限制，这个限制是为了保障 Solana 网络的稳定性和安全性，同时也是为了防止恶意程序占用过多的存储空间。在这个限制下，如何设计程序的数据结构，如何确保账户的数据不超过限制，这些都是 Solana 开发者关心的问题，我们今天将通过详细的讲解和一些实际案例分析来为大家揭开 Solana 存储限制的神秘面纱。</p><span id="more"></span><h2 id="Solana-存储限制"><a href="#Solana-存储限制" class="headerlink" title="Solana 存储限制"></a>Solana 存储限制</h2><p>在了解 <a href="https://solana.com/">Solana</a> 存储限制之前，我们需要先来了解一下 Solana 的账号模型。</p><img src="/images/post/2025/02/solana-account-model.png" class="" width="600" height="400"><p>在 Solana 区块链中，每个账户的数据结构被称为 <code>AccountInfo</code>，这个数据结构包含了以下字段：</p><ul><li>Data：账户数据</li><li>Executable：是否为可执行程序</li><li>Lamports：账户余额（以 lamports 为单位，1 SOL 等于 10 亿 lamports）</li><li>Owner：账户所有者程序</li></ul><p>账户根据 <code>Executable</code> 字段可以分为两种类型：<strong>程序账户</strong>和<strong>数据账户</strong>。程序账户用来保存运行在 Solana 网络上的程序（也称为智能合约），它是无状态的，仅存储执行代码。而程序相关的数据则需要保存在数据账户中，数据账户可以保存任意格式的数据。两者的内容都保存在 <code>Data</code> 字段中，程序账户保存的是程序的字节码，数据账户保存的是具体数据。</p><p>Solana 的存储限制是：每个账户的最大存储空间为 <strong>10MB</strong>，这里的存储空间指的就是 <code>Data</code> 字段的大小，保存到账户的数据单位一般是字节，所以 10MB 等于 10 x 1024 x 1024 字节。</p><h2 id="存储大小查询"><a href="#存储大小查询" class="headerlink" title="存储大小查询"></a>存储大小查询</h2><p>既然我们已经了解了 Solana 的存储限制，那么如何确定账户实际占用了多少存储空间呢？实际上，Solana 提供了多种方法来查询账户的存储大小，无论是在程序代码中还是在测试代码中，都可以轻松实现这一功能。</p><blockquote><p>Solana 的程序代码使用 Rust 语言编写，而测试代码一般使用 JavaScript 或 TypeScript 语言编写。<br>Solana 的程序开发分为 Native 和 <a href="https://www.anchor-lang.com/docs">Anchor</a> 两种方式，在下面的代码示例中，我们默认以 Anchor 为例进行说明。</p></blockquote><p>如果你希望在 Solana 的程序中查询账户的存储大小，我们可以在 Rust 程序通过 <code>AccountInfo</code> 结构的 <code>data.len()</code> 方法来查询账户的存储大小，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">account_size</span> = ctx.accounts.your_account.<span class="title function_ invoke__">to_account_info</span>().<span class="title function_ invoke__">data_len</span>();</span><br><span class="line">msg!(<span class="string">&quot;account size: &#123;&#125;&quot;</span>, account_size);</span><br></pre></td></tr></table></figure><ul><li>其中 ctx 为 Anchor 的上下文对象，其中包含了当前程序的所有账户信息，<code>your_account</code> 为你的账户变量名。</li></ul><p>另外比较常见的做法是在测试代码中查询账户的存储大小，我们可以通过 Solana 的 JavaScript SDK 来查询账户的存储大小，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Connection</span>,<span class="title class_">PublicKey</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@solana/web3.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">connection</span>: <span class="title class_">Connection</span> = ...;</span><br><span class="line"><span class="keyword">const</span> yourAccount = <span class="keyword">new</span> <span class="title class_">PublicKey</span>(<span class="string">&quot;your_account_address&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> accountInfo = <span class="keyword">await</span> connection.<span class="title function_">getAccountInfo</span>(yourAccount);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;account size:&quot;</span>, accountInfo?.<span class="property">data</span>.<span class="property">length</span>);</span><br></pre></td></tr></table></figure><ul><li>其中 Connection 为 Solana SDK 的连接对象，<code>your_account_address</code> 为你的账户地址。</li></ul><p>通过以上方法可以查询到账号的大小，单位为字节，比如我们得到的查询结果为：<code>account size: 1000</code>，那么这个账户的大小就是 1000 字节。</p><h2 id="存储大小计算"><a href="#存储大小计算" class="headerlink" title="存储大小计算"></a>存储大小计算</h2><p>现在我们知道如何查询账户的存储大小了，那么账户的存储大小究竟是如何计算的呢？Anchor 的官方文档中详细上列出了<a href="https://www.anchor-lang.com/docs/references/space#type-chart">基础数据类型的大小以及相应的计算方法</a>，借助这些信息，我们就能准确地计算出账户实际占用的存储空间。</p><p>我们列举几个文档上的数据类型的大小来做示例说明：</p><ul><li><code>bool</code>：1 字节</li><li><code>u8/i8</code>：1 字节</li><li><code>Vec&lt;T&gt;</code>：4 + (space(T) x amount)</li></ul><p>其中 <code>bool</code> 和 <code>u8/i8</code> 类型的大小都是 1 字节，<code>Vec</code> 类型的大小是 4 字节加上泛型 <code>T</code> 类型的大小乘以 <code>Vec</code> 的长度，我们以具体的示例来说明 <code>Vec</code> 大小的计算方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[account]</span></span><br><span class="line"><span class="meta">#[derive(InitSpace)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyStorage</span> &#123;</span><br><span class="line">    <span class="meta">#[max_len(10)]</span></span><br><span class="line">    data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个数据结构中，<code>data</code> 字段是一个 <code>Vec</code> 类型的数据，<code>Vec</code> 的长度最大为 10，<code>Vec</code> 中每个元素的类型是 <code>u8</code>，那么这个数据结构的大小就是 4 + 1 x 10 &#x3D; 14 字节。</p><p>由于 <code>MyStorage</code> 结构体采用了 <code>#[derive(InitSpace)]</code> 宏，在 Solana 的 Anchor 框架中，该宏能够自动计算并初始化账户所需的存储空间，因此我们可以直接通过 <code>MyStorage::INIT_SPACE</code> 方法来获取该数据结构的大小。</p><h2 id="存储费用查询"><a href="#存储费用查询" class="headerlink" title="存储费用查询"></a>存储费用查询</h2><p>现在我们已经知道了如何计算账户大小，接下来让我们来探讨在 Solana 区块链上存储数据所需支付的费用。实际上每个账户都必须为其存储的数据支付一定的费用，那么我们要如何得知账户所需的费用呢？实际上 Solana 提供了一个命令行工具，可以通过输入字节数就能计算出相应的存储费用，工具的使用示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana rent 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># output result</span></span><br><span class="line">Rent-exempt minimum: 0.00158688 SOL</span><br></pre></td></tr></table></figure><p>这里表示存储 100 字节的数据需要支付 0.00158688 SOL 的费用，可能有朋友会比较好奇，如果一个 10MB 的账号需要多少费用，我们来看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana rent 10485760</span><br><span class="line"></span><br><span class="line"><span class="comment"># output result</span></span><br><span class="line">Rent-exempt minimum: 72.98178048 SOL</span><br></pre></td></tr></table></figure><p>如果我们存储一个 10MB 的账户，字节数为 10 x 1024 x1024 &#x3D; 10485760，则需要支付 72.98178048 SOL 的费用，截至目前为止（2025-02），1 SOL 约等于 196 美元，所以存储一个 10MB 的账户大约需要支付 14330.5 美元的费用，这是一笔非常昂贵的开销。因此，在设计账户时，应谨慎评估哪些数据必须保存在链上，哪些数据可以存储在其他地方，以便有效地控制成本。</p><p>我们再来看一个例子，当我们输入的字节数为 0 时，我们会发现输出结果并不是 0 SOL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana rent 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># output result</span></span><br><span class="line">Rent-exempt minimum: 0.00089088 SOL</span><br></pre></td></tr></table></figure><p>这是因为 Solana 区块链中的账户有一个最小存储开销，即使账户中没有数据，也需要支付一定的费用。</p><h2 id="存储费用计算"><a href="#存储费用计算" class="headerlink" title="存储费用计算"></a>存储费用计算</h2><p>在实际的开发中，我们不需要手动计算账户的存储费用，Solana 可以根据账户的大小自动计算出存储费用。但我们还是有必要了解一下 Solana 的存储费用计算方法，这样我们可以更好地理解账户的存储费用。</p><p>在 Solana 的源码定义了一些常量和方法来计算账户的存储费用，我们可以通过查看<a href="https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97">这些源码</a>来了解存储费用的计算方法，源码内容如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT_LAMPORTS_PER_BYTE_YEAR: <span class="type">u64</span> = <span class="number">1_000_000_000</span> / <span class="number">100</span> * <span class="number">365</span> / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT_EXEMPTION_THRESHOLD: <span class="type">f64</span> = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> ACCOUNT_STORAGE_OVERHEAD: <span class="type">u64</span> = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">minimum_balance</span>(&amp;<span class="keyword">self</span>, data_len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = data_len <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">    (((ACCOUNT_STORAGE_OVERHEAD + bytes) * <span class="keyword">self</span>.lamports_per_byte_year) <span class="keyword">as</span> <span class="type">f64</span></span><br><span class="line">        * <span class="keyword">self</span>.exemption_threshold) <span class="keyword">as</span> <span class="type">u64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_EXEMPTION_THRESHOLD：默认豁免时间点，默认是 2.0 年</li><li>DEFAULT_LAMPORTS_PER_BYTE_YEAR：默认每字节每年度费用，默认是 3480 lamports</li><li>ACCOUNT_STORAGE_OVERHEAD：账户最小开销，默认是 128 字节，这里就是我们之前查询的 0 字节账户时的 最小字节开销</li><li>费用的计算公式为：<code>((ACCOUNT_STORAGE_OVERHEAD + 账户存储大小) x DEFAULT_LAMPORTS_PER_BYTE_YEAR) x DEFAULT_EXEMPTION_THRESHOLD</code></li></ul><p>以 0 字节账号为例，当账户存储大小为 0 时，存储费用为：<code>((128 + 0) x 3480) x 2.0 = 890880 lamports</code>，转换为 SOL 即为 0.00089088 SOL，结果和我们之前查询的一致。</p><h3 id="租借机制"><a href="#租借机制" class="headerlink" title="租借机制"></a>租借机制</h3><p>在存储费用计算中，有一个常量引起了我们的注意，比如 <code>DEFAULT_EXEMPTION_THRESHOLD</code>，表示默认的豁免时间点，默认值为 2.0 年，为什么会设计这个常量呢？这还要从 Solana 的租借机制说起。</p><p>还记得之前介绍过的账户结构 <code>AccountInfo</code> 吗？在这个结构中，大家通常会注意到 <code>Data</code>、<code>Executable</code> 等主要字段，它们分别存储了账户的数据和是否为可执行程序等信息。但实际上，<code>AccountInfo</code> 内部还包含了一个历史遗留字段，名为 <code>rent_epoch</code>。这个字段用于记录账户开始进入租借状态的 epoch 值，即标志着账户租金计算的起始时间。最初设计时，Solana 希望借助这个字段来追踪账户的租金缴纳情况和剩余租金状态，确保系统能够及时回收那些长时间未活跃且租金不足的账户。尽管如今系统的租金扣费方式已经发生了较大变化，<code>rent_epoch</code> 依然保留在账户结构中，以便兼容历史数据和为需要查询账户租借信息的应用程序提供参考。</p><p>最初的 Solana 系统中采用的是按年计费的租金机制，也就是说，账户需要定期支付租金来维持其在链上的存在。如果用户只预付了半年的租金，那么系统会在每个新的 epoch 开始时，从账户余额中扣除相应的租金金额。这样一来，经过大约六个月后，账户余额会逐步减少至零，届时系统就会自动删除该账户，认为它已不再满足持续存在的条件。相反，如果用户选择预付<strong>两年</strong>的租金，那么该账户就会获得一个特殊状态，被称为<strong>免租账户</strong>，从而在之后的周期中不再需要继续扣除租金。这样一来，账户可以长期稳定地存在于链上，而不必担心因余额耗尽而被清理。</p><p>随着技术的不断发展和生态系统的成熟，Solana 对租金机制进行了优化和调整，旧有的定期扣费方式已经被全面废弃。现在，所有新创建的账户必须在初始化时至少预存两年租金，以确保账户有足够的余额来支持长时间的存续。这种机制不仅简化了租金计算和管理流程，也大大提高了系统资源的利用效率。更重要的是，当用户决定关闭账户时，系统会全额退还预存的租金押金，从而避免了资金的长期占用和不必要的经济负担。这种改进使得账户管理变得更加透明、简单，并且更好地保护了用户的资产权益。</p><h2 id="账户重分配大小限制"><a href="#账户重分配大小限制" class="headerlink" title="账户重分配大小限制"></a>账户重分配大小限制</h2><p>虽然 Solana 的账户最大存储大小为 10MB，但是在实际创建账户时，我们无法一下子创建一个 10MB 的账户，下面是创建账户的代码示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[account]</span></span><br><span class="line"><span class="meta">#[derive(InitSpace)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyStorage</span> &#123;</span><br><span class="line">    <span class="meta">#[max_len(10230)]</span></span><br><span class="line">    data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Init</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> user: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init,</span></span><br><span class="line"><span class="meta">        payer = user,</span></span><br><span class="line"><span class="meta">        space = 8 + MyStorage::INIT_SPACE,</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;my_storage&quot;</span>]</span>,</span><br><span class="line">        bump</span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> my_storage: <span class="type">Box</span>&lt;Account&lt;<span class="symbol">&#x27;info</span>, MyStorage&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(_ctx: Context&lt;Init&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们首先定义了一个数据结构 <code>MyStorage</code>，根据之前的计算方法，这个数据结构的大小为 4 + 1 x 10230 &#x3D; 10234 字节</li><li>在 <code>Init</code> 结构中，我们定义了一个 <code>my_storage</code> 账户，这个账户的大小为 8 字节加上 <code>MyStorage</code> 的大小，即 8 + 10234 &#x3D; 10242 字节</li></ul><p>当运行这个程序，程序在初始化 <code>my_storage</code> 账号时，会报一个 <code>Account data size realloc limited to 10240 in inner instructions</code> 的错误，这是因为 Anchor 通过 <a href="https://solana.com/docs/core/cpi">Cross Program Invocation（CPI）</a>作为内部指令来为账户分配存储空间，每个内部指令允许的最大重新分配空间为 10240 字节，也就是 <strong>10KB</strong>，但我们的账户大小为 10242 字节，已经超过了这个限制，所以会报错。</p><p>这个限制的常量名为 <code>MAX_PERMITTED_DATA_INCREASE</code>，我们可以通过<a href="https://docs.rs/solana-account-info/2.2.0/src/solana_account_info/lib.rs.html#17">这里</a>来查看相关代码。</p><h3 id="增加账户存储大小"><a href="#增加账户存储大小" class="headerlink" title="增加账户存储大小"></a>增加账户存储大小</h3><p>初始创建的账户大小最大只有 10240 字节，那么我们该如何扩展其存储容量呢？我们可以通过重新分配账户存储空间来增加账户的存储大小，下面是扩展账户存储大小的代码示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IncreaseAccountSize</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> user: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut,</span></span><br><span class="line"><span class="meta">              realloc = my_storage.to_account_info().data_len() + 10240,</span></span><br><span class="line"><span class="meta">              realloc::payer = user,</span></span><br><span class="line"><span class="meta">              realloc::zero = false,</span></span><br><span class="line"><span class="meta">              seeds = [b<span class="string">&quot;my_storage&quot;</span>]</span>,</span><br><span class="line">              bump)]</span><br><span class="line">    <span class="keyword">pub</span> my_storage: Account&lt;<span class="symbol">&#x27;info</span>, MyStorage&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">increase_account_size</span>(_ctx: Context&lt;IncreaseAccountSize&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>IncreaseAccountSize</code> 结构体中，我们使用<a href="https://solana.com/docs/core/pda">程序派生地址（PDA）</a>得到之前创建的 <code>my_storage</code> 账户，其重新分配的大小是在当前账户大小上再增加 10240 字节</li><li><code>realloc::zero</code> 属性用于控制在重新分配账户存储空间时，是否将新分配的空间初始化为零，false 表示不会将新分配的空间初始化为零</li></ul><p>这里我们在账户<strong>原有的基础</strong>上增加了 10240 字节的存储空间，这个大小刚好满足 CPI 最大重新分配空间的限制，因此程序可以正常执行。但如果增加的大小超过 10240 字节，那么程序会报之前同样的错误。也就是说，每次扩展账户存储空间的大小不能超过 10240 字节，如果需要增加更多的存储空间，可以多次执行这个操作。每次为账户增加 10240 字节的存储空间，需要执行 1024 次操作才能达到 10MB 的上限。</p><p>此外，由于账户存储空间会产生费用，请务必确保账户余额充足以覆盖新增存储空间的费用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们了解到 Solana 的存储限制包括：</p><ul><li>账户的最大存储空间为 <strong>10MB</strong></li><li>创建或者重分配账户存储空间的限制为 <strong>10KB</strong></li></ul><p>我们还介绍了如何查询和计算账户的存储大小与存储费用，以及账户的租借机制等内容。在实际开发中，我们需要根据账户的存储需求合理设计数据结构，确保账户存储空间不超限，同时合理控制存储费用，从而提升程序的性能和效率。希望本文能够帮助大家更好地理解 Solana 的存储限制，为 Solana 开发提供一些参考。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://solana.com/docs/core/accounts">Solana Docs: Core Accounts</a></li><li><a href="https://www.rareskills.io/post/solana-account-rent">Cost of storage, maximum storage size, and account resizing in Solana</a></li><li><a href="https://www.anchor-lang.com/docs/references/space">Account Space</a></li></ul><p>关注我，一起学习最新的开发编程新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">深入浅出地介绍 Solana 开发中的账号存储限制。</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="blockchain" scheme="https://zhaozhiming.github.io/tags/blockchain/"/>
    
    <category term="web3" scheme="https://zhaozhiming.github.io/tags/web3/"/>
    
    <category term="solana" scheme="https://zhaozhiming.github.io/tags/solana/"/>
    
    <category term="account" scheme="https://zhaozhiming.github.io/tags/account/"/>
    
    <category term="storage limitation" scheme="https://zhaozhiming.github.io/tags/storage-limitation/"/>
    
  </entry>
  
  <entry>
    <title>深入解密 Solana 开发中的资源限制——CU 篇</title>
    <link href="https://zhaozhiming.github.io/2024/12/07/solana-resources-limitation-research/"/>
    <id>https://zhaozhiming.github.io/2024/12/07/solana-resources-limitation-research/</id>
    <published>2024-12-07T13:44:32.000Z</published>
    <updated>2024-12-22T07:35:30.353Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/12/solana-limitation-cu.jpeg" class="" width="400" height="300"><p>很多开发人员在开发 Solana 程序（智能合约）时经常遇到这样的问题，明明程序逻辑没有问题，但是在程序运行的时候就会出现奇怪的错误，错误的提示会出现<code>限制</code>或者<code>超出</code>等字眼，这表示你的程序可能落入了 Solana 的资源限制中。Solana 作为高性能区块链，其核心特性之一在于通过并行处理显著提升交易吞吐量，这种高效能背后依赖严格的资源管理机制，开发者需要深刻理解这些限制，才能有效开发和优化 Solana 程序。本文旨在介绍 Solana 开发中的资源限制，并详细介绍其中关于计算单元（Compute Unit，以下简称 CU）的限制，剖析实际场景，探讨优化策略。</p><span id="more"></span><h2 id="Solana-介绍"><a href="#Solana-介绍" class="headerlink" title="Solana 介绍"></a>Solana 介绍</h2><p><a href="https://solana.com/">Solana</a> 于 2020 年推出，最初被视为新兴区块链网络并且迅速崛起，成为全球最受欢迎的区块链生态系统之一。根据相关数据统计，Solana 在 2024 年占据了全球加密货币投资者对特定链兴趣的 49.3%，显示出其在行业中的主导地位。</p><p>Solana 是一个高性能的公有区块链平台，与传统区块链网络（如比特币、以太坊等）相比，其核心特点是高吞吐量与低延迟，其创新的 Proof of History 共识机制与高效的并行处理架构使其能够每秒处理数千笔交易。为了维持网络的稳定与公平，Solana 针对程序执行设置了多种资源限制，以确保系统资源合理分配并最大化利用。</p><h2 id="限制类型"><a href="#限制类型" class="headerlink" title="限制类型"></a>限制类型</h2><p>在 Solana 上运行的程序会受到以下几类资源限制，这些限制设计的目的是为了保证网络的高效性和稳定性，同时为开发者提供明确的开发边界。这些资源限制涵盖从计算能力到数据存储的多方面要求，使得程序在保证性能的前提下能够公平地利用系统资源。</p><h3 id="CU-限制"><a href="#CU-限制" class="headerlink" title="CU 限制"></a>CU 限制</h3><p>在 Solana 区块链中，CU 是衡量交易执行时消耗的计算资源最小单位。每笔交易在链上运行时，由于执行不同的指令（如账户写入、跨程序调用、系统调用等），会消耗一定数量的 CU。每个交易都会有一个 CU 限制，该限制可以使用默认设置，也可以通过程序申请提高。当交易的 CU 消耗超过限制时，处理会被中止，导致交易失败。常见的操作如执行指令、程序间数据传递、加密运算等都会产生 CU 消耗。CU 的设计旨在管理资源分配，防止网络滥用并提升整体效率，更多详细信息可以参考<a href="https://solana.com/docs/core/fees#compute-unit-limit">这里</a>。</p><p>以下是 Solana 中 CU 的限制：</p><ul><li>每个交易的最大 CU 限制是 <strong>140 万</strong></li><li>每个指令（每个交易会包含多个指令）的默认 CU 限制是 <strong>20 万</strong></li><li>每个区块的 CU 限制是 <strong>4800 万</strong></li><li>每个用户在一个区块中的 CU 限制是 <strong>1200 万</strong></li></ul><p>每个指令的默认 CU 限制是 20 万 CU，假设一个交易只包含了一个指令，那么该交易的 CU 默认限制就是 20 万 CU，但可以通过 <code>SetComputeUnitLimit</code> 指令来提高或降低交易的 CU 限制，但最大不得超过交易的 140 万 CU 这个限制。</p><h3 id="存储限制"><a href="#存储限制" class="headerlink" title="存储限制"></a>存储限制</h3><p>在 Solana 区块链中，每个账户的数据结构被称为 <strong>AccountInfo</strong>，包含账户状态、程序代码（若为程序账户）、余额（以 lamports 为单位，1 SOL 等于 10 亿 lamports）以及指定的所有者程序（程序 ID）。在 Solana 的账户模型中，每个账户都由一个程序作为其所有者，只有所有者程序可以修改账户数据或减少余额，而增加余额则不受限制。这一模型确保了账户数据的安全性和操作的可控性，更多详细信息可以参考<a href="https://solana.com/docs/core/accounts#accountinfo">这里</a>。</p><p>以下是 Solana 中存储的限制：</p><ul><li>每个账户的最大存储空间为 <strong>10MB</strong></li></ul><h3 id="交易大小限制"><a href="#交易大小限制" class="headerlink" title="交易大小限制"></a>交易大小限制</h3><p>Solana 网络遵循最大传输单元（MTU）大小为 1280 字节的限制，与 IPv6 的 MTU 标准一致，以确保通过 UDP 快速可靠地传输集群信息。在扣除 IPv6 和片段头部的 48 字节后，剩余 1232 字节用于承载数据，如序列化交易。这意味着每笔 Solana 交易的总大小不得超过 1232 字节，包括签名和消息部分。其中每个签名占用 64 字节，数量根据交易需求决定，消息部分包含指令、账户和其他元数据，每个账户需占用 32 字节，整体大小视交易所包含的指令而变化。这一限制确保交易数据在网络中高效传输，更多详细信息可以参考<a href="https://solana.com/docs/core/transactions#transaction-size">这里</a>。</p><p>以下是 Solana 中交易大小的限制：</p><ul><li>每笔交易的大小最大限制为 <strong>1232 字节</strong></li></ul><h3 id="调用深度限制"><a href="#调用深度限制" class="headerlink" title="调用深度限制"></a>调用深度限制</h3><p>在 Solana 中，为保证程序运行的高效性，每个程序的调用栈深度也有限制。如果超出该限制，将触发 <code>CallDepthExceeded</code> 错误。此外，Solana 支持程序直接调用其他程序（跨程序调用），但跨程序调用的深度也有限制，超过这一限制将触发 <code>CallDepth</code> 错误。这些限制旨在提高网络性能和资源管理效率，更多详细信息可以参考<a href="https://solana.com/docs/programs/limitations#call-stack-depth-object-object-error">这里</a>。</p><p>以下是 Solana 中调用深度的限制：</p><ul><li>每个程序的调用栈深度限制为 <strong>64 层</strong></li><li>跨程序调用的深度限制为 <strong>4 层</strong></li></ul><h3 id="堆栈大小限制"><a href="#堆栈大小限制" class="headerlink" title="堆栈大小限制"></a>堆栈大小限制</h3><p>在 Solana 程序设计的虚拟机架构中，每个栈帧大小有一定限制，使用固定栈帧而非可变栈指针。如果程序超出栈帧限制，编译器会发出警告，但不阻止编译。在运行时，如果确实超出栈大小，会触发 <code>AccessViolation</code> 错误。在堆管理方面，Solana 程序使用一个简单的堆来做内存管理，采用快速分配的 <strong>bump</strong> 模式，不支持内存释放或重新分配。每个 Solana 程序都可以访问这个内存区域，并根据需要实现自定义堆管理，这些限制有助于优化性能和资源分配，更多详细信息可以参考<a href="https://solana.com/docs/programs/faq#stack">这里</a>。</p><p>以下是 Solana 中堆栈大小的限制：</p><ul><li>每个栈帧大小为 <strong>4KB</strong></li><li>程序堆大小为 <strong>32KB</strong></li></ul><h3 id="PDA-账号限制"><a href="#PDA-账号限制" class="headerlink" title="PDA 账号限制"></a>PDA 账号限制</h3><p>在 Solana 中，程序派生地址（PDA）为开发者提供了一种确定性生成账户地址的机制，通过预定义的<strong>种子</strong>（如字符串、数字或其他账户地址）和程序 ID 来派生地址，从而实现类似链上哈希映射的功能。此外，Solana 运行时允许程序为其派生的 PDA 进行签名操作。PDA 的优势在于无需记住具体的账户地址，只需记住用于生成地址的输入即可，简化了账户管理，提高了开发效率，更多详细信息可以参考<a href="https://solana.com/developers/courses/native-onchain-development/program-derived-addresses#seeds">这里</a>。</p><p>以下是 Solana 中 PDA 账号的限制：</p><ul><li>每个 PDA 的种子长度不得超过 <strong>32 字节</strong></li><li>所有种子的总数量不得超过 <strong>16 个</strong></li></ul><h2 id="CU-限制详解"><a href="#CU-限制详解" class="headerlink" title="CU 限制详解"></a>CU 限制详解</h2><p>介绍完了 Solana 的各种资源限制后，我们来重点了解一下关于 CU 限制的相关内容。前面提到，CU 是衡量交易执行时消耗的计算资源的最小单位，每笔交易的 CU 消耗不能超过 120 万 CU，但对于初入 Solana 开发的开发者来说，这个概念可能还不够直观，下面我们通过一些示例来帮助大家更好地理解 CU 的消耗。</p><h3 id="显示-CU-消耗"><a href="#显示-CU-消耗" class="headerlink" title="显示 CU 消耗"></a>显示 CU 消耗</h3><p>在分析程序的 CU 消耗之前，我们先来了解一下 Solana 程序中显示 CU 消耗的方法。在 Solana 程序中，可以通过 <code>log</code> 函数来输出日志，其中包括 CU 消耗，下面是一个简单的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::log::sol_log_compute_units;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">sol_log_compute_units</span>();</span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line"><span class="title function_ invoke__">sol_log_compute_units</span>();</span><br></pre></td></tr></table></figure><p>每个 <code>sol_log_compute_units</code> 函数调用都会输出当前的 CU 消耗，程序运行后的日志如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program consumption: 149477 units remaining</span><br><span class="line"><span class="comment"># other logs</span></span><br><span class="line">Program consumption: 137832 units remaining</span><br></pre></td></tr></table></figure><p>通过这种方式，我们就可以计算出对应程序的 CU 消耗情况，比如在上面的例子中，两次调用 <code>sol_log_compute_units</code> 函数的差值就是中间程序的 CU 消耗。</p><p>我们也可以将 CU 消耗打印语句封装成一个 Rust 的宏，这样就可以在程序中更方便地调用，代码示例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build a macro to log compute units</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> compute_fn &#123;</span><br><span class="line">    ($msg:expr=&gt; $($tt:tt)*) =&gt; &#123;&#123;</span><br><span class="line">        msg!(<span class="built_in">concat!</span>($msg, <span class="string">&quot; &#123;&quot;</span>));</span><br><span class="line">        <span class="title function_ invoke__">sol_log_compute_units</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = &#123; $($tt)* &#125;;</span><br><span class="line">        <span class="title function_ invoke__">sol_log_compute_units</span>();</span><br><span class="line">        msg!(<span class="built_in">concat!</span>(<span class="string">&quot; &#125; // &quot;</span>, $msg));</span><br><span class="line">        res</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the macro to log compute units</span></span><br><span class="line">compute_fn!(<span class="string">&quot;create account&quot;</span> =&gt; &#123;</span><br><span class="line">    <span class="comment">// create account code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>封装成宏的方式可以更方便地在程序中调用，同时也可以输出更多的信息，方便调试。</p><h3 id="Solana-程序示例"><a href="#Solana-程序示例" class="headerlink" title="Solana 程序示例"></a>Solana 程序示例</h3><p>为了测试 Solana 程序的 CU 消耗情况，我们可以通过一些示例程序来了解不同操作的 CU 消耗情况。</p><p>Solana 为初学者提供了很多学习资料，其中包括一系列简单的示例程序（<code>program-examples</code>），可以帮助开发者更好地理解 Solana 的开发流程，示例程序可以查看这个 GitHub <a href="https://github.com/solana-developers/program-examples">仓库</a>。</p><p>在这个仓库中，每个示例程序都有两种示例，一种是原生程序，另一种是 Anchor 程序。</p><blockquote><p><a href="https://www.anchor-lang.com/">Anchor</a> 是 Solana 区块链上广泛使用的开发框架，用于简化程序（智能合约）和去中心化应用（DApp）的开发流程。它为开发者提供了一套高效且直观的工具和库，极大降低了 Solana 应用开发的门槛，Solana 官方推荐使用 Anchor 进行开发。</p></blockquote><p>后面我们在介绍 Solana 程序的 CU 消耗时，会引用这个仓库中的示例程序，通过这些示例程序来了解 Solana 中 CU 的消耗情况。下面我们通过操作和程序的角度来分别介绍 Solana 中 CU 的消耗情况。</p><h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3><p>首先是 Solana 中的一些常见操作，我们通过这些操作来了解每个操作的 CU 消耗情况。</p><p><strong>转账 SOL</strong></p><p>在 Solana 中，转账 SOL 是最常见的操作之一，每次转账都会消耗一定数量的 CU，大家肯定很好奇一次转账会消耗多少 CU，我们可以简单的做个实验，在 Solana 的 Devnet 网络上进行一次转账，然后在 <a href="https://explorer.solana.com/">Solana 浏览器</a>上查看这笔交易的 CU 消耗情况，结果如下：</p><img src="/images/post/2024/12/solana-transfer-sol-cu.png" class="" width="1000" height="600"><p>我们在浏览器的交易详情中可以看到，这笔转账消耗了 <strong>150</strong> CU，这个值不是固定的，但通常不会相差太大，消耗的 CU 大小与转账金额的大小无关，而是与交易的指令数量和复杂度有关。</p><p><strong>创建账号</strong></p><p>创建账号也是 Solana 中常见的操作之一，每次创建账号也会消耗一定数量的 CU，我们可以通过创建账号来了解其消耗情况。</p><p>我们可以在 <code>program-examples</code> 仓库的 <code>basic/create-account</code> 目录下找到创建账号的<a href="https://github.com/solana-developers/program-examples/blob/main/basics/create-account/anchor/programs/create-system-account/src/lib.rs#L20C1-L33C12">示例程序</a>，在这个程序中，我们通过在代码中添加 CU 消耗打印语句的方式来验证该程序的 CU 消耗情况，程序运行后的打印日志如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2024-12-08T07:34:47.865105000Z DEBUG solana_runtime::message_processor::stable_log] Program consumption: 186679 units remaining</span><br><span class="line">[2024-12-08T07:34:47.865181000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 invoke [2]</span><br><span class="line">[2024-12-08T07:34:47.865209000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 success</span><br><span class="line">[2024-12-08T07:34:47.865217000Z DEBUG solana_runtime::message_processor::stable_log] Program consumption: 183381 units remaining</span><br><span class="line">[2024-12-08T07:34:47.865219000Z DEBUG solana_runtime::message_processor::stable_log] Program <span class="built_in">log</span>: Account created succesfully.</span><br></pre></td></tr></table></figure><p>测试结果发现，每次创建账号的 CU 消耗大约在 <strong>3000</strong> 左右，这个值是不固定的，但通常不会相差太大。</p><p><strong>创建简单数据结构</strong></p><p>我们再来看下创建一个简单的数据结构的 CU 消耗情况，示例程序可以在 <code>program-examples</code> 仓库中的 <code>basic/account-data</code> 目录下找到，这个示例程序中定义了一个简单的数据结构，完整的示例程序代码可以查看<a href="https://github.com/solana-developers/program-examples/blob/main/basics/account-data/anchor/">这里</a>，这个数据结构定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[account]</span></span><br><span class="line"><span class="meta">#[derive(InitSpace)]</span> <span class="comment">// automatically calculate the space required for the struct</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AddressInfo</span> &#123;</span><br><span class="line">    <span class="meta">#[max_len(50)]</span> <span class="comment">// set a max length for the string</span></span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>, <span class="comment">// 4 bytes + 50 bytes</span></span><br><span class="line">    <span class="keyword">pub</span> house_number: <span class="type">u8</span>, <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="meta">#[max_len(50)]</span></span><br><span class="line">    <span class="keyword">pub</span> street: <span class="type">String</span>, <span class="comment">// 4 bytes + 50 bytes</span></span><br><span class="line">    <span class="meta">#[max_len(50)]</span></span><br><span class="line">    <span class="keyword">pub</span> city: <span class="type">String</span>, <span class="comment">// 4 bytes + 50 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构中有 3 个字符串字段和 1 个 u8 字段，每个字符串字段的最大长度为 50，经过测试后发现，创建这样一个简单的数据结构的 CU 消耗大约在 <strong>7000</strong> 左右。</p><p><strong>计数器</strong></p><p>Solana 的官方示例程序中，还提供了一个简单的计数器程序，可以在 <code>program-examples</code> 仓库中的 <code>basic/counter</code> 目录下找到，这个示例程序中定义了一个简单的计数器数据结构，并有创建计数器和增加计数等指令，完整的示例程序代码可以查看<a href="https://github.com/solana-developers/program-examples/tree/main/basics/counter/anchor">这里</a>。</p><p>经过测试后发现，创建计数器的 CU 消耗大约在 <strong>5000</strong> 左右，增加计数 的 CU 消耗大约在 <strong>900</strong> 左右。</p><p><strong>转账 Token</strong></p><p>在 Solana 程序中，还有一个比较常见但相对复杂的操作就是转账 Token。</p><blockquote><p>在 Solana 中，Token 是通过 SPL Token 标准实现的，SPL Token 是 Solana 官方提供的一个标准，用于实现代币的发行、转账等操作，SPL Token 提供了一套标准的接口，方便开发者在 Solana 上实现代币相关的操作。</p></blockquote><p>在 <code>program-examples</code> 仓库中也提供了一个转账 Token 的示例程序，可以在 <code>token/transfer-tokens</code> 目录下找到，该示例程序主要功能是转账 Token，但也包含了创建 Token、Mint Token、Burn Token 等操作，完整的示例程序代码可以查看<a href="https://github.com/solana-developers/program-examples/tree/main/tokens/transfer-tokens/native">这里</a>。</p><p>经过测试后发现，Token 相关操作的 CU 消耗情况结果如下：</p><ul><li>创建 Token 的 CU 消耗大约在 <strong>3000</strong> 左右</li><li>Mint Token 的 CU 消耗大约在 <strong>4500</strong> 左右</li><li>Burn Token 的 CU 消耗大约在 <strong>4000</strong> 左右</li><li>转账 Token 的 CU 消耗大约在 <strong>4500</strong> 左右</li></ul><p>在真实的交易记录中，我们也可以看到转账 Token 的 CU 消耗情况，以<a href="https://explorer.solana.com/tx/FiqGufYKmKeGWfnyRXAkSx3UXPwp8iyZroBPCmcSNrdxNm1ydFqtBCvfq7iU5hTscc11ZuxzHP5dowVQFbgKv5s">这个交易</a>为例，在其交易详情最下方的日志输出中，我们可以看到转账 Token 的 CU 消耗情况：</p><img src="/images/post/2024/12/solana-transfer-token-cu.png" class="" width="1000" height="600"><p><strong>小结</strong></p><p>常见操作的 CU 消耗情况总结如下：</p><table><thead><tr><th>Action</th><th>CU Cost (approx.)</th></tr></thead><tbody><tr><td>Transfer SOL</td><td>150</td></tr><tr><td>Create Account</td><td>3000</td></tr><tr><td>Create Simple data struct</td><td>7000</td></tr><tr><td>Counter</td><td>5000 (Init) <br> 900 (Add count)</td></tr><tr><td>Token</td><td>3000 (Create) <br> 4500 (Mint) <br> 4000 (Burn) <br> 4500 (Transfer)</td></tr></tbody></table><h3 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h3><p>了解完 Solana 中一些常见操作的 CU 消耗情况后，我们再来看下一些常用程序语法的 CU 消耗情况。</p><p><strong>循环语句</strong></p><p>在 Solana 程序中，循环语句是常见的语法之一，我们可以通过循环语句来了解其 CU 消耗情况，下面我们来对比一下不同大小的循环语句的 CU 消耗情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple msg print, cost 226 CU</span></span><br><span class="line">msg!(<span class="string">&quot;i: &#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple print for loop 1 time, cost 527 CU</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;i: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple print for loop 2 times, cost 934 CU</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">2</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;i: &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试后发现，简单的打印语句需要消耗 226 CU，加上 1 次循环后需要消耗 527 CU，加上 2 次循环后需要消耗 934 CU，于是我们可以简单地得出结论，初始化一个循环语句需要大概需要消耗 527-226&#x3D;301 CU，每次循环大概需要消耗 934 - 226x2 - 301 &#x3D; 181 CU。</p><p>我们再用 CU 消耗较高的语句来验证一下循环语句的 CU 消耗，比如打印账号地址的语句：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print account address, cost 11809 CU</span></span><br><span class="line">msg!(<span class="string">&quot;A string &#123;0&#125;&quot;</span>, ctx.accounts.address_info.<span class="title function_ invoke__">to_account_info</span>().<span class="title function_ invoke__">key</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// print account address in for loop 1 time, cost 12108 CU</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;A string &#123;0&#125;&quot;</span>, ctx.accounts.address_info.<span class="title function_ invoke__">to_account_info</span>().<span class="title function_ invoke__">key</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print account address in for loop 2 times, cost 24096 CU</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;A string &#123;0&#125;&quot;</span>, ctx.accounts.address_info.<span class="title function_ invoke__">to_account_info</span>().<span class="title function_ invoke__">key</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，循环语句的 CU 消耗根据其中的程序逻辑而变化，但是循环语句本身的消耗是比较少的，大概在 <strong>200-300</strong> CU 之间。</p><p><strong>If 语句</strong></p><p>If 语句也是常见的语法之一，我们可以通过 If 语句来了解其 CU 消耗情况，下面我们来对比一下 If 语句的 CU 消耗情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a base function consumed 221 CU</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>(_ctx: Context&lt;Initialize&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after add if sentence, the CU consumed is 339 CU</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>(_ctx: Context&lt;Initialize&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试后发现，一个空的函数需要消耗 221 CU，如果在这个函数中加上 If 语句，那么消耗会增加到 339 CU，所以一个简单的 if 语句的 CU 消耗大约在 <strong>100</strong> CU 左右。</p><p><strong>不同大小的数据结构</strong></p><p>使用不同大小的数据结构也会影响 CU 消耗，下面我们来对比一下不同大小的数据结构的 CU 消耗情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use a default vector and push 10 items, it will consume 628 CU</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    a.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use a 64 bit vector and do the same things, it will consume 682 CU</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> <span class="type">Vec</span>&lt;<span class="type">u64</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    a.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use a 64 bit vector and do the same things, it will consume 462 CU</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    a.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试后发现，使用默认的数据结构 <code>Vec&lt;u32&gt;</code> 来存储 10 个元素需要消耗 <strong>628</strong> CU，使用 64 位的数据结构 <code>Vec&lt;u64&gt;</code> 来存储 10 个元素需要消耗 <strong>682</strong> CU，使用 8 位的数据结构 <code>Vec&lt;u8&gt;</code> 来存储 10 个元素需要消耗 <strong>462</strong> CU，所以数据结构的大小对 CU 消耗也有一定的影响。</p><p><strong>哈希函数</strong></p><p>在 Solana 程序中，常见的语法还有使用哈希函数，下面我们来对比一下使用哈希函数的 CU 消耗情况，下面是一个简单的哈希函数使用示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_program::hash::hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>(_ctx: Context&lt;Initialize&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">b&quot;some data&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_hash</span> = <span class="title function_ invoke__">hash</span>(data);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对添加哈希函数和不添加哈希函数的程序进行对比，经测试后发现，使用了 Solana hash 函数来计算哈希值大概需要消耗 <strong>200</strong> CU 左右。</p><p><strong>调用函数</strong></p><p>调用函数也是编程过程中必不可少的操作之一，下面我们来对比一下调用函数的 CU 消耗情况，下面是一个简单的调用函数使用示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>(_ctx: Context&lt;Initialize&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">other_func</span>(_ctx)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">other_func</span>(_ctx: Context&lt;Initialize&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试后发现，调用函数所消耗的 CU 跟被调函数的实现逻辑有关， 调用一个空的函数方法只需要消耗 <strong>100</strong> CU 左右。</p><p><strong>小结</strong></p><p>常见程序语法的 CU 消耗情况总结如下：</p><table><thead><tr><th>Program</th><th>CU Cost (approx.)</th></tr></thead><tbody><tr><td>For</td><td>301 (Init) <br> 181 (Loop)</td></tr><tr><td>If</td><td>100</td></tr><tr><td>Diff Size Struct</td><td>462 (Vec u8) <br> 628 (Vec u32) <br> 682 (Vec u64)</td></tr><tr><td>Hash</td><td>200</td></tr><tr><td>Call Function</td><td>100</td></tr></tbody></table><h2 id="Solana-原生程序与-Anchor-程序-CU-消耗对比"><a href="#Solana-原生程序与-Anchor-程序-CU-消耗对比" class="headerlink" title="Solana 原生程序与 Anchor 程序 CU 消耗对比"></a>Solana 原生程序与 Anchor 程序 CU 消耗对比</h2><p>之前提到，Solana 程序目前有两种开发方式，一种是原生程序，另一种是使用 Anchor 框架开发程序，Anchor 框架是 Solana 官方推荐的开发框架，提供了一套高效且直观的工具和库，极大降低了 Solana 应用开发的门槛。大家可能会好奇，原生程序和 Anchor 程序的 CU 消耗有什么区别，下面我们就来对比这两种程序的 CU 消耗情况，我们将以<strong>转账 Token</strong> 操作为例来进行对比。</p><h3 id="原生程序-CU-消耗"><a href="#原生程序-CU-消耗" class="headerlink" title="原生程序 CU 消耗"></a>原生程序 CU 消耗</h3><p>我们先来看下原生程序中关于转账 Token 的 CU 消耗情况，我们可以通过分析源码来进行分析，Solana 程序的源码在<a href="https://github.com/solana-labs/solana-program-library">这个仓库</a>中，转账 Token 的核心方法 <code>process_transfer</code> 的源码可以查看<a href="https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L229-L343">这里</a>。在这个方法中，我们对这个方法进行了详细的步骤分解，并统计出了每个步骤的 CU 消耗情况，具体分析结果如下：</p><ul><li>基础消耗：运行空方法的消耗为 939 CU</li><li>转账初始化：包括账号检查和初始化，消耗为 2641 CU</li><li>检查账号是否冻结：消耗为 105 CU</li><li>检查源账号余额是否足够：消耗为 107 CU</li><li>检查 Token 类型是否匹配：消耗为 123 CU</li><li>检查 Token 地址和预期小数位数：消耗为 107 CU</li><li>处理自我转账：消耗为 107 CU</li><li>更新账号余额：消耗为 107 CU</li><li>处理 SOL 转账：消耗为 103 CU</li><li>保存账号状态：消耗为 323 CU</li></ul><p>整个转账 Token 的操作消耗大约在 4555 CU，与我们之前的测试结果（4500 CU）接近。其中转账初始化的消耗最大，为 2641 CU，可以再将其拆分为更细的步骤，拆分和分析后的结果如下：</p><ul><li>初始化源账号：消耗为 106 CU</li><li>初始化 mint 信息：消耗为 111 CU</li><li>初始化目标账号：消耗为 106 CU</li><li>解包源账号：消耗为 1361 CU</li><li>解包目标账号：消耗为 1361 CU</li></ul><p>其中两个账号的解包操作消耗最大，每个账号的解包操作消耗大约在 1361 CU，这个消耗是比较大的，所以在开发过程中需要注意。</p><h3 id="Anchor-程序-CU-消耗"><a href="#Anchor-程序-CU-消耗" class="headerlink" title="Anchor 程序 CU 消耗"></a>Anchor 程序 CU 消耗</h3><p>了解了原生程序的 CU 消耗情况后，我们再来看下 Anchor 程序的 CU 消耗情况。我们可以在 <code>program-examples</code> 仓库的 <code>tokens/transfer-tokens</code> 的目录下找到 Anchor 程序的示例程序，其中关于转账的 Token 的源码文件是 <a href="https://github.com/solana-developers/program-examples/blob/main/tokens/transfer-tokens/anchor/programs/transfer-tokens/src/instructions/transfer.rs">src&#x2F;instractions&#x2F;transfer.rs</a>。</p><p>初次运行该指令时，我们惊讶的发现 Anchor 程序转账 Token 的 CU 消耗竟然在 80000 ～ 90000 CU 左右，这个消耗量接近原生程序的 <strong>20 倍</strong>!</p><p>为什么 Anchor 程序的 CU 消耗会如此之高呢？我们开始对该程序的源码进行分析，Anchor 程序一般会包含两部分，一部分是账号的初始化，另一部分是指令的执行，这两部分都会消耗一定的 CU，我们对这两部分的消耗进行了详细的分析，具体分析结果如下：</p><ul><li>程序的整体消耗是 81457 CU</li><li>Anchor 框架的初始化消耗是 10526 CU</li><li>账号初始化的消耗是 20544 CU（源码中的 L9-L34）</li><li>转账 Token 的指令消耗是 50387 CU（源码中的 L36-L67）</li></ul><p>在账号初始化的过程中，需要初始化包括 sender_token_account，recipient_token_account 等账号，还需要初始化 token_program，associated_token_program 等程序，总共消耗了 20544 CU。</p><p>而在转账 Token 的指令执行过程中，总共消耗了 50387 CU，我们再次对转账 Token 的指令执行过程进行了详细的分析，具体分析结果如下：</p><ul><li>函数初始化的消耗是 6213 CU（即一个空方法也会消耗这么多 CU）</li><li>程序开始包含了 3 个 CU 消耗很大的打印语句</li><li>第一个打印语句的消耗是 11770 CU（源码中的 L38-L41），这是因为需要将账号地址隐式转换为 Base58 编码，这个操作非常耗费资源，这也是 <a href="https://solana.com/developers/guides/advanced/how-to-optimize-compute">Solana 官方不推荐的操作</a></li><li>第二个打印语句的消耗是 11645 CU（源码中的 L42-L45）</li><li>第三个打印语句的消耗是 11811 CU（源码中的 L46-L49）</li><li>转账指令的消耗是 7216 CU（源码中的 L52-L62），这里调用了 anchor_spl::token::transfer 方法，这个方法是对原生的 transfer 方法的封装，除了调用原生 transfer 方法外，还会进行一些其他操作</li><li>其他消耗是 1732 CU</li></ul><p>通过这些分析发现，程序中关于转账 Token 部分的实际消耗只有 <strong>7216</strong> CU，但是由于 Anchor 框架的初始化、账号初始化和一些打印语句的消耗，才导致整个程序的消耗达到了 81457 CU。</p><p>使用 Anchor 开发的程序虽然会消耗更多的 CU，但是 Anchor 框架提供了更多的功能和便利，所以这种消耗是可以理解的，开发者可以根据自己的需求选择合适的开发方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天为大家总结了 Solana 开发中的各种资源限制，然后重点介绍了 Solana 中 CU 的限制，分别介绍了一些常见操作和程序的 CU 消耗，最后对比了 Solana 原生程序和 Anchor 程序的 CU 消耗情况。不管你是 Solana 的初学者还是经验丰富的开发者，希望这篇文章能够帮助你更好地理解 Solana 中 CU 的消耗情况，在开发设计过程中更好地规划程序资源，优化程序性能。</p><p>我们也根据 Solana 的官方文档总结了一些优化计算资源的方法，帮助开发者更好地避免 CU 限制中的_陷阱_，具体如下：</p><ul><li>测量计算使用量：使用在日志中显示 CU 消耗信息可以评估代码片段的 CU 消耗，从而识别高计算开销的部分。</li><li>减少日志记录：日志记录操作（如 <code>msg!</code> 宏）会显著增加 CU 消耗，特别是涉及 Base58 编码和字符串连接时。建议仅记录必要的信息，并使用更高效的方法，如 <code>.key().log()</code>，来记录公钥等数据。</li><li>选择合适的数据类型：较大的数据类型（如 u64）比较小的数据类型（如 u8）消耗更多的 CU。在可能的情况下，优先使用较小的数据类型以减少 CU 使用。</li><li>优化序列化操作：序列化和反序列化操作会增加 CU 消耗。通过使用零拷贝（zero copy）技术，直接与账户数据交互，可以降低这些操作的开销。</li><li>PDA 的查找：<code>find_program_address</code> 函数的计算复杂度取决于找到有效地址所需的尝试次数。在初始化时保存 bump 值，并在后续操作中使用已知的 bump 值，可以减少 CU 消耗。</li></ul><p>希望在以后的文章中，我们可以继续讨论 Solana 资源限制的其他方面，为大家提供更多的参考，如果你有什么想问想说的，欢迎在评论区留言。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://solana.com/docs/core/fees">Solana Docs: Core Fees</a></li><li><a href="https://solana.com/docs/core/accounts">Solana Docs: Core Accounts</a></li><li><a href="https://solana.com/docs/core/transactions">Solana Docs: Core Transactions</a></li><li><a href="https://solana.com/developers/courses/native-onchain-development/program-derived-addresses">Solana Docs: Program-Derived Addresses</a></li><li><a href="https://solana.com/docs/programs/limitations">Solana Docs: Program Limitations</a></li><li><a href="https://solana.com/docs/programs/faq">Solana Docs: Program FAQ</a></li><li><a href="https://github.com/solana-developers/program-examples">Solana Developers: Program Examples</a></li><li><a href="https://www.anchor-lang.com/">Anchor Lang</a></li><li><a href="https://solana.com/developers/guides/advanced/how-to-optimize-compute">Solana Developers: How to Optimize Compute</a></li></ul><p>关注我，一起学习最新的开发编程新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">详细介绍 Solana 开发过程中经常遇到的资源限制问题，通过示例分析，程序对比来重点介绍 Solana 开发中的 CU 限制。</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="blockchain" scheme="https://zhaozhiming.github.io/tags/blockchain/"/>
    
    <category term="web3" scheme="https://zhaozhiming.github.io/tags/web3/"/>
    
    <category term="solana" scheme="https://zhaozhiming.github.io/tags/solana/"/>
    
    <category term="anchor" scheme="https://zhaozhiming.github.io/tags/anchor/"/>
    
    <category term="computer-unit" scheme="https://zhaozhiming.github.io/tags/computer-unit/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Curve 流动性池子：投资指南与数据分析</title>
    <link href="https://zhaozhiming.github.io/2024/11/04/curve-pool-base-invest-and-data-computer/"/>
    <id>https://zhaozhiming.github.io/2024/11/04/curve-pool-base-invest-and-data-computer/</id>
    <published>2024-11-04T07:13:08.000Z</published>
    <updated>2024-11-18T01:14:01.124Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/11/curve-defi.jpg" class="" width="400" height="300"><p>对于不熟悉 Web3 的朋友来说，可能会觉得 DeFi (Decentralized Finance，去中心化金融) 是一个充满风险的赌场或骗局。但实际上，DeFi 是一个去中心化的金融体系，在某些方面与投资股票、基金等传统金融产品具有相似性。DeFi 利用区块链技术提供公开透明、无需中介的金融服务，降低了信任成本和交易费用。目前，主流的 DeFi 平台包括 Curve、 Uniswap、Aave 和 Compound 等。今天我们将介绍 Curve 这个平台的基本操作，并探讨其中涉及的智能合约方法，希望通过这篇文章帮助大家更好地理解 DeFi，增强对 DeFi 投资的信心，并找到一种新的财富增长方式。</p><span id="more"></span><h2 id="Curve-介绍"><a href="#Curve-介绍" class="headerlink" title="Curve 介绍"></a>Curve 介绍</h2><p><a href="https://curve.fi/">Curve</a> 是一个去中心化的交易平台，专注于提供稳定币和类似资产之间的交换服务。它通过流动性池子模型运作，允许用户在没有买卖撮合的情况下进行低滑点和低费用的交易，即在交易过程中，价格波动较小，用户可以更好地控制交易成本。Curve 的设计使其成为跨不同稳定币和相关资产交换的理想选择，特别是在加密货币市场中，稳定币之间的交换需求日益增长。流动性提供者可以通过向这些池子中投入代币来赚取交易费用和额外的激励奖励，如 CRV 代币等。Curve 平台是非托管的，意味着用户始终控制自己的资金，而智能合约的不可升级特性增加了资金安全性。Curve 的用户界面展示了关键的财务指标，帮助用户评估和优化他们的投资回报。此外，Curve 支持多条边链，并允许通过 Curve Factory 让用户可以无需权限地创建新的流动性池子，这促进了平台的去中心化和创新。</p><h3 id="流动性池子"><a href="#流动性池子" class="headerlink" title="流动性池子"></a>流动性池子</h3><p>Curve 的流动性池子好比股市中的 ETF 基金，它通过一个组合集合了许多股票，投资者可以通过购买 ETF 的方式获得多只股票的收益，降低投资的风险。在 Curve 中，用户可以将自己的代币投入到池子中，其他用户可以在这个池子中进行代币的交换，交易的价格则由智能合约的算法自动确定，而不是由买卖双方直接撮合。这种方式减少了交易摩擦，提高了流动性，尤其是在稳定币之间的兑换中具有明显优势。</p><p>Curve 有两种主要类型的流动性池子：<strong>Stableswap 池子</strong> 和 <strong>Cryptoswap 池子</strong>。</p><p>Stableswap 池子主要用于稳定币或价值相对稳定的代币，如 USDC、USDT 等。Curve 上比较出名的 Stableswap 池子有 <a href="https://curve.fi/#/ethereum/pools/3pool/deposit">3pool</a>。3pool 包含 USDC、USDT 和 DAI，这些都是最常见的稳定币。这类池子利用了一种特殊的算法，以维持资产之间的平衡和近似 1:1 的汇率。</p><img src="/images/post/2024/11/curve-3pool.png" class="" width="1000" height="600"><p>而 Cryptoswap 池子则用于价值波动较大的资产，如 BTC 、 ETH 等，比较出名的 Cryptoswap 池子有 <a href="https://curve.fi/#/ethereum/pools/factory-tricrypto-0/deposit">TricryptoUSDC</a>。TricryptoUSDC 包含 BTC、ETH 和 USDC，用于跨加密货币之间的高效交换。这类池子通过维持资产的市场价值平衡来适应价格波动。</p><img src="/images/post/2024/11/curve-tricrptousdc.png" class="" width="1000" height="600"><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>流动性池子的奖励和收益主要包括两种类型：</p><ul><li>Base vAPY（可变年收益率）：指 LP（流动性提供者）通过存入资产并从池子中累积的交易费用获得的收益。随着 LP 代币价值的增加，这些收益也会直接增加 LP 的财富。</li><li>Reward tAPR（总年化收益率）：主要由 CRV 代币奖励和其他代币激励组成。LP 可以将获得的 CRV 代币用于参与 Curve DAO 的治理，从而进一步提高其投资回报，但需要将 CRV 代币锁定一段时间。</li></ul><p>流动性池子中产生的收益完全归 LP 所有，不会因手续费或池子中的其他成本而被削减。</p><img src="/images/post/2024/11/curve-reward.png" class="" width="1000" height="600"><h3 id="支持链"><a href="#支持链" class="headerlink" title="支持链"></a>支持链</h3><p>Curve 支持多个区块链网络，这使其成为一个非常灵活且兼容性强的去中心化金融平台。目前，Curve 支持包括主链和侧链在内的多个区块链，如 Ethereum、Polygon 和 Arbitrum 等。通过支持这些不同的链，Curve 为用户提供了更多选择，让用户可以在不同的链上分散投资，降低风险并优化收益。同时，用户能够根据自己的需求选择适合的链进行操作，例如选择更低的费用、更快的交易速度或更丰富的资产组合。Curve 的多链支持不仅增强了平台的灵活性和兼容性，还确保用户能够在不同区块链生态中获得最佳的流动性和收益体验。不同链上的 Curve 流动性池子功能一致，这使得用户在不同链之间自由转移资产变得更加方便和高效。</p><img src="/images/post/2024/11/curve-support-chain.png" class="" width="300" height="800"><h2 id="投资流程"><a href="#投资流程" class="headerlink" title="投资流程"></a>投资流程</h2><p>Curve 的投资主要分为 2 个主要过程，分别是投资和提现。在进行投资之前，用户需要将钱包中的代币转换成流动性池子支持的代币，然后才能进行投资。在对流动性池进行投资之后，还可以抵押 LP 代币来获取更多的奖励。在提现时，用户需要先将 LP 代币解除质押，然后再将代币从流动性池中提现到钱包中。下面是一个 Curve 投资的基本流程图：</p><img src="/images/post/2024/11/curve-deposit-flow.png" class="" width="1000" height="600"><p>在开始投资 Curve 之前，你需要完成一些基本的准备工作。首先是钱包准备，你要安装支持以太坊网络的 <a href="https://metamask.io/">MetaMask</a> 或其他钱包，并确保钱包中存有足够的 ETH 用于支付后续操作的 gas 费用。同时，将钱包网络切换到对应的区块链网络。接着是资金准备，根据你的投资计划准备好相应数量的稳定币，比如 USDT、USDC 或 DAI 等，并将这些资金转入到你的钱包地址中。建议首次操作时先用<strong>小额资金</strong>测试，以熟悉整个流程。</p><p>完成准备工作后，就可以开始连接 Curve 平台了。首先打开浏览器访问 Curve 的<a href="https://curve.fi/">官网</a>，在页面右上角找到 <strong>Connect Wallet（连接钱包）</strong> 按钮并点击。这时会弹出钱包连接请求，仔细检查连接地址是否正确后，在钱包中确认授权连接。成功连接后，你就可以看到自己钱包地址显示在页面右上角了，这表示你已经可以开始使用 Curve 平台的各项功能了。在进行任何操作之前，建议先浏览一下平台的界面布局，熟悉各个功能模块的位置。</p><p>下面我们以投资 <code>Arbitrum</code> 链上的 <code>2BTC-ng</code> 池子为例，介绍 Curve 投资的基本操作流程。</p><h3 id="货币转换"><a href="#货币转换" class="headerlink" title="货币转换"></a>货币转换</h3><p>流动性池子 <code>2BTC-ng</code> 需要投资的代币是 <code>WBTC</code> 或 <code>tBTC</code>，你可以投资任意一种代币或两种代币的组合到流动性池子中。如果你的钱包中这两种代币都没有的话，可以通过 Curve 的 Swap 功能进行兑换。</p><p>首先在右上角选择 <code>Arbitrum</code> 网络，然后在 Curve 主页面点击 <strong>SWAP</strong> 菜单，在交易界面的上方选择你要支付的代币，下方方选择你要获得的代币。输入你想要兑换的数量，系统会自动计算你将获得的代币数量，并显示兑换比率和价格影响。在确认兑换之前，请注意查看 <strong>Exchange Rate（兑换率）</strong>和 <strong>Price Impact（价格影响）</strong>，确保它们在合理范围内。第一次兑换某个代币时，需要先点击 <strong>Approve</strong> 按钮授权 Curve 合约使用你的代币，授权成功后点击 <strong>Swap</strong> 按钮进行兑换。整个过程需要支付 gas 费用，建议在 gas 价格较低的时候进行操作。</p><img src="/images/post/2024/11/curve-swap.png" class="" width="1000" height="600"><h3 id="投资池子"><a href="#投资池子" class="headerlink" title="投资池子"></a>投资池子</h3><p>接下来我们回到 Curve 首页，选择 <strong>POOLS</strong> 菜单，然后在搜索框中输入 <code>2BTC-ng</code> 关键字进行检索，找到对应的流动性池子。</p><p>选定流动性池子后，你需要先完成代币授权才能注入流动性。在流动性池页面，选择左上角的 <strong>Deposit</strong> 选项卡，在你要存入的代币（<code>2BTC-ng</code> 池子是 <code>WBTC</code> 和 <code>tBTC</code>）输入框中输入存入金额，系统会自动计算并显示你将获得的 LP 代币数量。然后点击 <strong>Approve Spending</strong> 按钮，允许 Curve 合约使用你的代币。这个授权操作需要在钱包中确认并支付一笔 gas 费，这是一次性的操作，同一代币在后续投资时无需重复授权。</p><p>完成授权后，就可以开始注入流动性了，在点击 <strong>Deposit</strong> 按钮之前，请仔细核对显示的数据，包括存入金额、LP 代币数量以及兑换比率等信息，确保一切参数都符合预期。确认无误后点击 <strong>Deposit</strong> 按钮，在钱包中确认交易并支付 gas 费，等待交易完成后，你就会收到对应的 LP 代币，这标志着你已经成功在这个流动性池中注入了流动性。</p><img src="/images/post/2024/11/curve-pool-deposit.png" class="" width="1000" height="600"><p>完成流动性注入后，你会获得对应的 LP 代币，并且你会持续地获得 Base vAPY 奖励。如果你想获得更多的奖励，你可以选择将这些 LP 代币进行质押以获取额外的 CRV 奖励。在 Curve 平台上，每个流动性池都有对应的 Gauge（质押合约）。在 Deposit 选项卡中，选择 <strong>Stake</strong> 标签就可以对 LP 代币进行质押。在质押页面中，第一次质押时需要授权 Gauge 合约使用你的 LP 代币，授权确认后，输入要质押的 LP 代币数量，确认交易即可完成质押。</p><img src="/images/post/2024/11/curve-pool-stake.png" class="" width="1000" height="600"><p>当然你可以将 <strong>Deposit</strong> 和 <strong>Stake</strong> 操作合并在一起，即在 <strong>Deposit</strong> 选项卡中直接选择 <strong>Deposit &amp; Stake</strong> 标签，输入存款金额和质押数量，确认交易并支付 gas 费，系统会自动完成存款和质押两个操作。</p><p>完成质押后，你的 LP 代币会开始持续产生 CRV 代币奖励，也就是 Reward tAPR 奖励。除了 CRV 奖励外，有些流动性池还会额外提供其他代币的奖励，比如 <code>2BTC-ng</code> 流动性池除了 CRV 奖励外，还会提供 ARB 代币奖励。</p><h3 id="领取收益"><a href="#领取收益" class="headerlink" title="领取收益"></a>领取收益</h3><p>在 Curve 平台上领取奖励的操作相对简单直观，用户只需进入流动性池页面，这里我们进入 <code>2BTC-ng</code> 的流动性池子页面，选择 <strong>Withdraw&#x2F;Claim</strong> 选项卡，再选择 <strong>Claim Rewards</strong> 标签，这时你可以看到所有可领取的奖励，包括 CRV、ARB 等代币奖励。</p><img src="/images/post/2024/11/curve-pool-claim.png" class="" width="1000" height="600"><p>你可以选择领取 CRV 奖励，点击 <strong>Claim CRV</strong> 按钮就能将 CRV 奖励发送到你的钱包地址，或者你也可以选择领取其他代币奖励如 ARB 等，点击 <strong>Claim Rewards</strong> 按钮，这些奖励就会直接发送到你的钱包地址。</p><p>为了最大化投资收益，定期监控和管理你的收益非常重要。这包括经常查看流动性池子的 APY 变化情况、关注 CRV 代币的价格波动，并据此计算实际收益率。建议设置提醒，以便能够定期领取奖励，避免遗漏。</p><p>对于已经领取的 CRV 奖励，你有多种管理策略可以选择。你可以选择立即将 CRV 出售换成稳定币，也可以选择持有 CRV 等待其价格升值，还可以将 CRV 锁定为 veCRV 来参与治理并获得更多收益。具体采用哪种策略，需要根据当时的市场情况来灵活调整。</p><h3 id="结束投资"><a href="#结束投资" class="headerlink" title="结束投资"></a>结束投资</h3><p>从 Curve 中撤出流动性的操作和投资流程相反。第一步是解除 Gauge 质押，首先是进入流动性池页面，选择 <strong>Withdraw&#x2F;Claim</strong> 选项卡，再选择 <strong>Unstake</strong> 标签，输入要解除质押的 LP 代币数量， 然后点击 <strong>Unstake</strong> 按钮，在钱包中确认交易并支付 gas 费，等待交易完成后，你的 LP 代币就会从 Gauge 合约返回到你的钱包中。</p><img src="/images/post/2024/11/curve-pool-unstack.png" class="" width="1000" height="600"><p>第二步是从流动性池中提现，在流动性池页面选择 <strong>Withdraw&#x2F;Claim</strong> 选项卡，再选择 <strong>Withdraw</strong> 标签，输入要提现的 LP 代币数量，你可以选择将所有 LP 代币都换成一种代币，或者按自定义比例换成多种代币。输入数量后，系统会显示你将收到的代币数量， 然后点击 <strong>Approve Spending</strong> 按钮，授权 Curve 合约使用你的 LP 代币，确认无误后点击 <strong>Withdraw</strong> 按钮，在钱包中确认交易并支付 gas 费，等待交易完成后，你的代币就会到达你的钱包中。</p><img src="/images/post/2024/11/curve-pool-withdraw.png" class="" width="1000" height="600"><p>在完成撤资操作后，你会收到相应的代币，这时你可能需要将这些代币转换成你想要持有的目标币种。为了获得最优的兑换率，建议你同时查看其他去中心化交易所（DEX）提供的兑换率，选择对你最有利的平台进行兑换操作。</p><h2 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h2><p>如果你是一个开发人员，你可能想了解在 Curve 投资过程中智能合约是如何自动计算出相关数据，并如何将其应用到实际操作中。下面我们将以 <code>2BTC-ng</code> 流动性池子为例，介绍一些 Curve 使用智能合约计算数据的方法，希望能帮助你更好地理解 Curve 平台的运作原理。</p><h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><p>在每个流动性池子中，Curve 一般会包含 2 个合约，它们分别是 <strong>LP Token 合约</strong>和 <strong>Gauge 合约</strong>。</p><p>LP Token 合约是一个符合 ERC20 标准的代币合约，用来代表用户在流动性池中的份额占比。当用户向池子提供流动性时，会根据提供的资产价值铸造对应数量的 LP Token。同样地，当用户想要撤回流动性时，需要销毁这些 LP Token 来赎回原始资产。LP Token 还能帮助用户自动获得交易手续费收入，因为所有的手续费都会被按照持有的 LP Token 比例分配给流动性提供者。</p><p>Gauge 合约也是一个符合 ERC20 标准的代币合约，是 Curve 协议中负责流动性挖矿和激励分配的重要组件。当用户将 LP Token 质押到 Gauge 合约中时，就可以开始赚取 CRV 代币奖励，奖励的数量取决于质押的 LP Token 数量以及池子的权重。Gauge 合约还支持额外的奖励代币分发功能，项目方可以通过 Gauge 向特定池子的流动性提供者发放自己的代币奖励，这种机制有效地激励了用户向重要的池子提供长期流动性。</p><p>下面是 <code>2BTC-ng</code> 流动性池子的 LP Token 和 Gauge 合约：</p><img src="/images/post/2024/11/curve-pool-contracts.png" class="" width="1000" height="600"><h3 id="投资金额"><a href="#投资金额" class="headerlink" title="投资金额"></a>投资金额</h3><p>要获取用户在 Curve 平台上流动性池子的投资金额，可以根据投资情况来调用不同合约的方法。在 LP Token 合约和 Gauge 合约中都有 <code>balanceOf</code> 方法，如果你在投资流动性池子过程中只执行了 <strong>Deposit</strong> 操作，那么你可以调用 LP Token 合约的 <code>balanceOf</code> 方法来获取你的账号金额。如果你执行了<strong>Stake</strong> 操作，那么你可以调用 Gauge 合约的 <code>balanceOf</code> 方法来获取你的账号金额。<code>balanceOf</code> 方法的参数是用户的地址，返回值是用户在合约中的余额。下面是代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Web3</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect the Arbitrum One mainnet</span></span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;https://arb1.arbitrum.io/rpc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// smart contract ABI</span></span><br><span class="line"><span class="keyword">const</span> abi = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">stateMutability</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;balanceOf&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;arg0&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;],</span><br><span class="line">    <span class="attr">outputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// pool contract address(take 2BTC-ng as an example)</span></span><br><span class="line"><span class="keyword">const</span> lpTokenContractAddress = <span class="string">&quot;0x186cf879186986a20aadfb7ead50e3c20cb26cec&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> gaugeContractAddress = <span class="string">&quot;0xB7e23A438C9cad2575d3C048248A943a7a03f3fA&quot;</span>;</span><br><span class="line"><span class="comment">// wallet address</span></span><br><span class="line"><span class="keyword">const</span> walletAddress = <span class="string">&quot;0xd693bc8e4a24097bbec4f7cdbc7021cf356b818c&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// create smart contract</span></span><br><span class="line">  <span class="keyword">const</span> lpTokenContract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(abi, lpTokenContractAddress);</span><br><span class="line">  <span class="keyword">const</span> gaugeContract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(abi, gaugeContractAddress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// invoke contrace function</span></span><br><span class="line">  <span class="keyword">const</span> lpTokenBalance = <span class="keyword">await</span> lpTokenContract.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">balanceOf</span>(walletAddress)</span><br><span class="line">    .<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lp token wallet balance is:&quot;</span>, lpTokenBalance);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> gaugeBalance = <span class="keyword">await</span> gaugeContract.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">balanceOf</span>(walletAddress)</span><br><span class="line">    .<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Gauge wallet balance is:&quot;</span>, gaugeBalance);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果显示</span></span><br><span class="line"><span class="comment">// Lp token wallet balance is: 0n</span></span><br><span class="line"><span class="comment">// Gauge wallet balance is: 78988425012240n</span></span><br></pre></td></tr></table></figure><ul><li>我们先使用 Arbitrum One 主网创建一个 Web3 实例</li><li>然后定义 LP Token 和 Guage 合约的 ABI，这 2 个合约都有同样的 <code>balanceOf</code> 方法</li><li>接着定义 2BTC-ng 流动性池子的合约地址和用户的钱包地址</li><li>再通过 Web3 实例创建 LP Token 和 Guage 合约实例</li><li>最后调用 <code>balanceOf</code> 方法获取用户在 Curve 平台上的投资金额</li></ul><p>在 Curve 流动性池子中进行投资后，投资的金额会根据池子的比例进行分配，这个比例是由 Curve 的算法自动计算的。我们也可以通过 LP Token 合约中的方法来显示分配后的投资金额，这样可以更直观地了解自己在 Curve 平台上的投资情况。在 LP Token 合约中，有 <code>totalSupply</code> 方法，可以获取这个流动性池子的代币总供应量，然后有另外一个方法 <code>balances</code> 可以获取池子中每种代币的供应量，最后通过计算就可以得到每种代币在总供应量中的比例，最后再根据用户的投资金额来计算用户在池子中每种代币的投资金额。下面是代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smart contract ABI</span></span><br><span class="line"><span class="keyword">const</span> abi = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">stateMutability</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;totalSupply&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [],</span><br><span class="line">    <span class="attr">outputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">stateMutability</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;balances&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;i&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">    <span class="attr">outputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...... previous code</span></span><br><span class="line">  <span class="keyword">const</span> totalBalance = lpTokenBalance + gaugeBalance;</span><br><span class="line">  <span class="keyword">const</span> totalSupply = <span class="keyword">await</span> lpTokenContract.<span class="property">methods</span>.<span class="title function_">totalSupply</span>().<span class="title function_">call</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tokenOne = <span class="keyword">await</span> lpTokenContract.<span class="property">methods</span>.<span class="title function_">balances</span>(<span class="number">0</span>).<span class="title function_">call</span>();</span><br><span class="line">  <span class="comment">// because WBTC&#x27;s decimals is 8, so we need to convert it to ether</span></span><br><span class="line">  tokenOne = web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(tokenOne, <span class="string">&quot;gwei&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> tokenTwo = <span class="keyword">await</span> lpTokenContract.<span class="property">methods</span>.<span class="title function_">balances</span>(<span class="number">1</span>).<span class="title function_">call</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tokenOneRatio = <span class="title class_">Number</span>(tokenOne) / <span class="title class_">Number</span>(totalSupply);</span><br><span class="line">  <span class="keyword">const</span> tokenTwoRatio = <span class="title class_">Number</span>(tokenTwo) / <span class="title class_">Number</span>(totalSupply);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tokenOneBalance = web3.<span class="property">utils</span>.<span class="title function_">fromWei</span>(</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">floor</span>(tokenOneRatio * <span class="title class_">Number</span>(totalBalance)).<span class="title function_">toString</span>(),</span><br><span class="line">    <span class="string">&quot;ether&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Token one balance is:&quot;</span>, tokenOneBalance);</span><br><span class="line">  <span class="keyword">const</span> tokenTwoBalance = web3.<span class="property">utils</span>.<span class="title function_">fromWei</span>(</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">floor</span>(tokenTwoRatio * <span class="title class_">Number</span>(totalBalance)).<span class="title function_">toString</span>(),</span><br><span class="line">    <span class="string">&quot;ether&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Token two balance is:&quot;</span>, tokenTwoBalance);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果显示</span></span><br><span class="line"><span class="comment">// Token one balance is: 0.000034135788291198</span></span><br><span class="line"><span class="comment">// Token two balance is: 0.0000450482379098</span></span><br></pre></td></tr></table></figure><ul><li>我们首先定义了 LP Token 合约的 ABI，包括 <code>totalSupply</code> 和 <code>balances</code> 方法</li><li>然后使用之前获取到的 2 个合约的用户金额，计算出用户在流动性池子上的总投资金额</li><li>接着调用 <code>totalSupply</code> 方法获取流动性池子的总供应量</li><li>再调用 <code>balances</code> 方法获取池子中每种代币的供应量，其中因为代币 WBTC 的 decimals 是 8，所以需要将其转换成 ether</li><li>然后计算每种代币在池子总供应量中的比例</li><li>最后根据用户的投资金额来计算用户在池子中每种代币的投资金额</li></ul><h3 id="收益计算"><a href="#收益计算" class="headerlink" title="收益计算"></a>收益计算</h3><p>在 Curve 平台上，用户可以通过质押 LP Token 来获取 CRV 代币奖励，除了 CRV 奖励外，有些流动性池还会额外提供其他代币的奖励，比如 <code>2BTC-ng</code> 流动性池除了 CRV 奖励外，还会提供 ARB 代币奖励。在 Gauge 合约中，获取可领取的 CRV 奖励和其他代币奖励的方法是不同的。获取 CRV 奖励的方法是 <code>claimable_tokens</code>，获取其他代币奖励的方法是 <code>claimable_reward</code>。<strong>注意</strong> <code>claimable_tokens</code> 方法在智能合约中的 <code>stateMutability</code> 属性是 <code>nonpayable</code>，这意味着你无法直接在 <a href="https://arbiscan.io/address/0xb7e23a438c9cad2575d3c048248a943a7a03f3fa#readContract">Explorer 页面</a>上调用这个方法，但我们可以将这个方法的 ABI 添加到我们的代码中，然后将 <code>stateMutability</code> 属性改为 <code>view</code>，这样就可以在代码中调用这个方法了。下面是代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Web3</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;https://arb1.arbitrum.io/rpc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abi = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">stateMutability</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;claimable_tokens&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;addr&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;],</span><br><span class="line">    <span class="attr">outputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">stateMutability</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;claimable_reward&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;_user&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;_reward_token&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">outputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2BTC-ng pool gauge contract address</span></span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">&quot;0xB7e23A438C9cad2575d3C048248A943a7a03f3fA&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> walletAddress = <span class="string">&quot;0xd693bc8e4a24097bbec4f7cdbc7021cf356b818c&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> arbTokenAddress = <span class="string">&quot;0x912ce59144191c1204e64559fe8253a0e49e6548&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> contract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(abi, contractAddress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> crvRewards = <span class="keyword">await</span> contract.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">claimable_tokens</span>(walletAddress)</span><br><span class="line">    .<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CRV tokens amount is:&quot;</span>, crvRewards);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arbRewards = <span class="keyword">await</span> contract.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">claimable_reward</span>(walletAddress, arbTokenAddress)</span><br><span class="line">    .<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ARB tokens amount is:&quot;</span>, arbRewards);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果显示</span></span><br><span class="line"><span class="comment">// CRV tokens amount is: 25937502765335321n</span></span><br><span class="line"><span class="comment">// ARB tokens amount is: 589955392324932n</span></span><br></pre></td></tr></table></figure><ul><li>我们首先定义了 Gauge 合约的 ABI，包括 <code>claimable_tokens</code> 和 <code>claimable_reward</code> 方法</li><li>定义 Gauge 合约地址、用户的钱包地址和 ARB 代币地址，<strong>注意 ARB 代币在不同的网络上有不同的地址</strong>，这里我们需要使用 Arbitrum 网络上的 ARB 代币地址</li><li>使用 Web3 实例创建 Gauge 合约实例</li><li>调用 <code>claimable_tokens</code> 方法，传入用户的钱包地址，获取用户可领取的 CRV 奖励</li><li>调用 <code>claimable_reward</code> 方法，传入用户的钱包地址和 ARB 代币地址，获取用户可领取的 ARB 奖励</li></ul><p>之前的方法是获取用户在流动性池子中<strong>可领取</strong>的奖励，这里的<strong>可领取</strong>表示用户还未对奖励进行 <strong>Claim</strong> 操作，如果想获取用户已经 <strong>Claim</strong> 过的 CRV 奖励，则需要使用 Curve 的 <code>ChildChainGaugeFactory</code> 合约中的方法，这个合约是 Curve 的子合约，用来管理用户在 Curve 平台上的奖励，合约中的方法说明可以看<a href="https://docs.curve.fi/curve_dao/liquidity-gauge-and-minting-crv/evm-sidechains/ChildGaugeFactory/">这个文档</a>。这个智能合约在每个区块链网络上都有部署，这里是各个网络上的<a href="https://docs.curve.fi/references/deployed-contracts/#evm-sidechain-gauges">合约地址</a>，你可以根据自己的网络选择对应的合约地址，这里我们使用 Arbitrum 网络上的合约地址<code>0xabC000d88f23Bb45525E447528DBF656A9D55bf5</code>。下面是代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> abi = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">stateMutability</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;minted&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;arg0&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&quot;arg1&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;address&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">outputs</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// arbitrum network childchain guage factory address</span></span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">&quot;0xabC000d88f23Bb45525E447528DBF656A9D55bf5&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> walletAddress = <span class="string">&quot;0xd693bc8e4a24097bbec4f7cdbc7021cf356b818c&quot;</span>;</span><br><span class="line"><span class="comment">// 2BTC-ng pool gauge contract address</span></span><br><span class="line"><span class="keyword">const</span> guageContractAddress = <span class="string">&quot;0xB7e23A438C9cad2575d3C048248A943a7a03f3fA&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> contract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(abi, contractAddress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> crvRewards = <span class="keyword">await</span> contract.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">minted</span>(walletAddress, guageContractAddress)</span><br><span class="line">    .<span class="title function_">call</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Claimed CRV tokens amount is:&quot;</span>, crvRewards);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果显示</span></span><br><span class="line"><span class="comment">// Cliamed CRV tokens amount is: 31262343705302473n</span></span><br></pre></td></tr></table></figure><ul><li>我们首先定义了 Curve 的 <code>ChildChainGaugeFactory</code> 合约的 ABI，这里是 <code>minted</code> 方法</li><li>定义 Curve 的 <code>ChildChainGaugeFactory</code> 合约地址、用户的钱包地址和流动性池子的 Gauge 合约地址</li><li>使用 Web3 实例创建 <code>ChildChainGaugeFactory</code> 合约实例</li><li>调用 <code>minted</code> 方法，传入用户的钱包地址和 流动性池子的 Gauge 合约地址，获取用户已经 <strong>Claim</strong> 过的 CRV 奖励</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 DeFi 的世界里，Curve 只是众多流动性池平台之一，但它的稳定性和高效性使得它成为了很多用户的首选。这篇文章为大家介绍了 Curve 平台的基本概念和投资操作流程，同时也为开发人员提供了 Curve 流动性池子中智能合约的使用方法，希望能帮助大家更好地了解 Curve 平台的运作原理和数据计算方法。</p><p>关注我，一起学习最新的开发编程新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍 Curve 平台的基本操作，以及其中相关数据的计算方法</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="blockchain" scheme="https://zhaozhiming.github.io/tags/blockchain/"/>
    
    <category term="curve" scheme="https://zhaozhiming.github.io/tags/curve/"/>
    
    <category term="defi" scheme="https://zhaozhiming.github.io/tags/defi/"/>
    
    <category term="web3" scheme="https://zhaozhiming.github.io/tags/web3/"/>
    
    <category term="finance" scheme="https://zhaozhiming.github.io/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>Go 开发中你应该了解的 5 种 Mock 方法</title>
    <link href="https://zhaozhiming.github.io/2024/10/18/maybe-you-donot-known-5-way-to-mock-golang-programm/"/>
    <id>https://zhaozhiming.github.io/2024/10/18/maybe-you-donot-known-5-way-to-mock-golang-programm/</id>
    <published>2024-10-18T01:17:48.000Z</published>
    <updated>2024-10-19T09:17:34.760Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/10/golang-mock-tech.jpeg" class="" width="400" height="300"><p>在软件开发过程中，单元测试是确保代码质量的重要环节，而在编写单元测试时，我们通常需要隔离待测试的代码与其依赖的外部组件，例如引用的外部方法、数据库等。Mock 技术可以帮助我们模拟这些外部组件，控制它们的行为和输出，从而让我们可以专注于测试目标代码的逻辑。本文将介绍在 Golang 中常用的 5 种 Mock 方法，帮助你在编写单元测试时更加得心应手。</p><span id="more"></span><h2 id="Testify-Mock"><a href="#Testify-Mock" class="headerlink" title="Testify Mock"></a>Testify Mock</h2><p><a href="https://github.com/stretchr/testify">Testify</a> 是 Go 生态中一个非常流行的测试工具库，主要用于简化 Go 语言中的单元测试工作。它是一个包含多个包的集合，提供了断言、Mock 和其他便捷的测试功能。</p><p>Testify 的 Mock 是其中一个功能强大的模块，它提供了模拟接口和方法调用的能力，支持参数匹配、调用次数和顺序的验证。它允许开发者通过链式调用设置不同的返回值和行为，并能精确匹配参数或自定义参数验证，帮助模拟外部依赖如 API 调用，使其在复杂的逻辑测试中非常灵活和高效。它与 Go 原生测试框架无缝集成，提供直观易用的 API，简化了测试代码编写和维护。</p><p>下面我们通过代码示例介绍 Testify Mock 的功能，首先来看被测试的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/third-party/amazonx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-sdk-go-v2/aws&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-sdk-go-v2/service/secretsmanager&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">service <span class="keyword">struct</span> &#123;</span><br><span class="line">amazon amazonx.Amazon</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(svc *service)</span></span> GetTokenFromAWSSecret(c context.Context) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">input := &amp;secretsmanager.GetSecretValueInput&#123;</span><br><span class="line">SecretId:     aws.String(<span class="string">&quot;SECRET_ID&quot;</span>),</span><br><span class="line">VersionStage: aws.String(<span class="string">&quot;AWSCURRENT&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := svc.amazon.GetSecretValue(c, input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(*resp.SecretString), &amp;resMap); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resMap[<span class="string">&quot;token&quot;</span>].(<span class="type">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>被测试方法 <code>GetTokenFromAWSSecret</code> 输入参数是一个 <code>context.Context</code> 对象，返回一个 <code>string</code> 类型的 <code>token</code> 和一个 <code>error</code> 对象</li><li><code>GetTokenFromAWSSecret</code> 方法依赖于 <code>amazonx.Amazon</code> 接口，通过 <code>svc.amazon.GetSecretValue</code> 方法获取 AWS Secret Value，并解析其中的 <code>token</code> 字段。</li></ul><p>了解完被测函数后， 我们来看如何使用 Testify Mock 对 <code>amazonx.Amazon</code> 接口进行 Mock：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go-v2/service/secretsmanager&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/mock&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MockAmazon <span class="keyword">struct</span> &#123;</span><br><span class="line">mock.Mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockAmazon)</span></span> GetSecretValue(ctx context.Context, input *secretsmanager.GetSecretValueInput) (*secretsmanager.GetSecretValueOutput, <span class="type">error</span>) &#123;</span><br><span class="line">args := m.Called(ctx, input)</span><br><span class="line"><span class="keyword">return</span> args.Get(<span class="number">0</span>).(*secretsmanager.GetSecretValueOutput), args.Error(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先我们使用 Testify Mock 定义了一个 <code>MockAmazon</code> 结构体</li><li>然后使用 Mock 对象来实现 <code>amazonx.Amazon</code> 接口的 <code>GetSecretValue</code> 方法</li></ul><p>接下来我们编写单元测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-sdk-go-v2/service/secretsmanager&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetTokenFromAWSSecretSuccess</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mockAmazon := <span class="built_in">new</span>(MockAmazon)</span><br><span class="line">svc := &amp;service&#123;</span><br><span class="line">amazon: mockAmazon,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx := context.TODO()</span><br><span class="line">secretString := <span class="string">`&#123;&quot;token&quot;: &quot;test-token&quot;&#125;`</span></span><br><span class="line">mockAmazon.On(<span class="string">&quot;GetSecretValue&quot;</span>, ctx,</span><br><span class="line">    mock.AnythingOfType(<span class="string">&quot;*secretsmanager.GetSecretValueInput&quot;</span>)).</span><br><span class="line">Return(&amp;secretsmanager.GetSecretValueOutput&#123;</span><br><span class="line">    SecretString: &amp;secretString,</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">token, err := svc.GetTokenFromAWSSecret(ctx)</span><br><span class="line">assert.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;test-token&quot;</span>, token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在测试函数中，我们首先创建了一个 <code>MockAmazon</code> 对象，并将其传入 <code>service</code> 结构体中</li><li>然后模拟 <code>GetSecretValue</code> 方法的行为，设置返回值为 <code>&#123; &quot;token&quot;: &quot;test-token&quot; &#125;</code></li><li>最后调用 <code>GetTokenFromAWSSecret</code> 方法，验证返回值是否符合预期</li></ul><p>这里需要注意的地方是，<code>mockAmazon</code> 对象需要模拟真实对象 <code>amazonx.Amazon</code> 的<strong>所有方法</strong>，如果有其中一个方法没有实现的话，就<strong>无法赋值</strong>给 <code>service</code> 结构体。一旦真实对象的接口方法很多，那么手动实现所有方法就会十分繁琐，这个时候如果有一种工具可以自动生成 Mock 方法就会非常方便，这就是我们接下来要介绍的 Mock 工具——GoMock。</p><h2 id="GoMock"><a href="#GoMock" class="headerlink" title="GoMock"></a>GoMock</h2><p><a href="https://github.com/uber-go/mock">GoMock</a> 是一个为 Go 语言提供模拟框架的工具库，由 Uber 维护，支持 Go 官方支持的最新两个版本。GoMock 允许开发者使用 <code>mockgen</code> 工具来生成用于测试的模拟对象，支持源文件模式和包模式生成模拟对象，并且与 Go 的内置 <code>testing</code> 包兼容，同时支持类型安全的模拟方法，并允许设置详细的期望调用。</p><p>使用 GoMock 首先需要安装 <code>mockgen</code> 工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/golang/mock/mockgen@latest</span><br></pre></td></tr></table></figure><p>然后在要模拟的接口文件中添加接口生成注释，以之前的被测方法为例，我们需要在 <code>amazonx</code> 包中的 <code>amazon.go</code> 文件中添加如下注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:generate mockgen -destination ./amazon_mock.go -package amazonx -source amazon.go Amazon</span></span><br></pre></td></tr></table></figure><p>这个注释表示使用 <code>mockgen</code> 在当前目录下生成一个 <code>amazon_mock.go</code> 文件，包名为 <code>amazonx</code>，并且使用 <code>amazon.go</code> 文件中的 <code>Amazon</code> 接口生成 Mock 对象。一般支持 Golang 的编辑器都支持 <code>go:generate</code> 注释，可以直接在编辑器中执行生成 Mock 对象的命令。</p><img src="/images/post/2024/10/golang-mockgen.png" class="" width="1000" height="600"><p>生成后的 <code>amazon_mock.go</code> 文件内容大概是这个样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MockAmazon is a mock of Amazon interface.</span></span><br><span class="line"><span class="keyword">type</span> MockAmazon <span class="keyword">struct</span> &#123;</span><br><span class="line">ctrl     *gomock.Controller</span><br><span class="line">recorder *MockAmazonMockRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MockAmazonMockRecorder is the mock recorder for MockAmazon.</span></span><br><span class="line"><span class="keyword">type</span> MockAmazonMockRecorder <span class="keyword">struct</span> &#123;</span><br><span class="line">mock *MockAmazon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMockAmazon creates a new mock instance.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMockAmazon</span><span class="params">(ctrl *gomock.Controller)</span></span> *MockAmazon &#123;</span><br><span class="line">mock := &amp;MockAmazon&#123;ctrl: ctrl&#125;</span><br><span class="line">mock.recorder = &amp;MockAmazonMockRecorder&#123;mock&#125;</span><br><span class="line"><span class="keyword">return</span> mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other methods...</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>NewMockAmazon</code> 方法来模拟 <code>amazonx.Amazon</code> 接口，下面来看下我们使用 GoMock 写的测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/third-party/amazonx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/golang/mock/gomock&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetTokenFromAWSSecretByGomock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctrl := gomock.NewController(t)</span><br><span class="line"><span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">mockAmazon := amazonx.NewMockAmazon(ctrl)</span><br><span class="line">svc := &amp;service&#123;</span><br><span class="line">amazon: mockAmazon,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx := context.TODO()</span><br><span class="line"></span><br><span class="line">secretString := <span class="string">`&#123;&quot;token&quot;:&quot;test-token&quot;&#125;`</span></span><br><span class="line">mockAmazon.EXPECT().GetSecretValue(ctx, gomock.Any()).</span><br><span class="line">Return(&amp;secretsmanager.GetSecretValueOutput&#123;</span><br><span class="line">SecretString: &amp;secretString,</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">token, err := svc.GetTokenFromAWSSecret(ctx)</span><br><span class="line">assert.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;test-token&quot;</span>, token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在测试函数中，我们首先创建了一个 GoMock 的 <code>controller</code> 对象，然后使用 <code>amazonx.NewMockAmazon</code> 方法创建一个 <code>MockAmazon</code> 对象</li><li>然后通过 <code>EXPECT</code> 方法设置 <code>GetSecretValue</code> 方法的行为和返回值</li><li>最后调用 <code>GetTokenFromAWSSecret</code> 方法，验证返回值是否符合预期</li></ul><p>使用 GoMock 写的测试代码跟 Testify Mock 类似，但是我们不再需要手动的编写 Mock 对象，而是通过 <code>mockgen</code> 工具生成 Mock 对象，这样就可以大大提高测试代码的编写效率。</p><h2 id="引用包-Mock"><a href="#引用包-Mock" class="headerlink" title="引用包 Mock"></a>引用包 Mock</h2><p>在单元测试中，我们经常会遇到被测试代码直接调用引用包方法的情况，举个例子，比如我们经常使用 Go 内置的 <code>os</code> 包进行文件读写，如果真实地去调用 <code>os</code> 包的方法，那么我们就需要在测试中构造测试文件，然后再对测试文件进行清理，这样会增加测试代码的复杂度。我们更希望可以直接 Mock <code>os</code> 包中的方法，这样就可以避免对文件系统的依赖，同时可以更加灵活地控制返回值。</p><p>下面我们就来介绍一下如何 Mock 引用包的方法，首先我们来看下被测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEnvVariable</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    value := os.Getenv(<span class="string">&quot;MY_ENV_VAR&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被测试代码中直接使用 <code>os</code> 包的 <code>Getenv</code> 方法获取环境变量，如果我们要 Mock <code>os</code> 包中的 <code>Getenv</code> 方法，我们需要对这个方法进行一些改造，修改后的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getenv = os.Getenv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEnvVariable</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    value := getenv(<span class="string">&quot;MY_ENV_VAR&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 <code>os.Getenv</code> 方法赋值给了一个变量 <code>getenv</code>，这样我们就可以在测试代码中修改 <code>getenv</code> 的值，从而实现 Mock <code>os</code> 包中的 <code>Getenv</code> 方法。下面我们来看下测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetEnvVariable</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    oldGetenv := getenv</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; getenv = oldGetenv &#125;()</span><br><span class="line"></span><br><span class="line">    getenv = <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&quot;MY_ENV_VAR&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;mock_value&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result := GetEnvVariable()</span><br><span class="line">    assert.Equal(t, <span class="string">&quot;mock_value&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在测试函数中，我们首先保存了原始的 <code>getenv</code> 方法</li><li>然后通过给 <code>getenv</code> 赋值的方式对 <code>os.Getenv</code> 方法进行 Mock</li><li>最后调用 <code>GetEnvVariable</code> 方法，验证返回值是否符合预期</li></ul><p>其实对于 <code>os.getenv</code> 的测试，我们也可以通过 <code>os.setenv</code> 方法来设置期望值，但我们现在不是讨论如何让这个测试案例通过，而是如何 Mock 引用包的方法。这种方法无需引用任何第三方库，只需要对被测试代码做一点简单的修改，就可以实现 Mock 引用包的目的，如果你遇到了引用其他包的情况，可以通过这种方式来进行 Mock。</p><h2 id="数据库-Mock"><a href="#数据库-Mock" class="headerlink" title="数据库 Mock"></a>数据库 Mock</h2><p>对于数据库的 Mock， 如果使用之前提到的 Testify Mock 或 GoMock 往往力不从心，你会发现当你写了一大堆 Mock 逻辑后，代码不是编译不通过就是运行起来各种报错。这个时候我们需要更专业的数据库 Mock 工具，比如 <a href="https://github.com/DATA-DOG/go-sqlmock">go-sqlmock</a>。</p><p>go-sqlmock 是一个用于 Go 语言的 SQL 驱动模拟库，旨在测试中模拟真实数据库交互，支持事务、多连接、上下文和命名 SQL 参数，无需修改源代码，且不依赖任何第三方库，它能够模拟任何 SQL 驱动方法的行为，并具有严格的预期顺序匹配。</p><p>下面我们来看下如何使用 go-sqlmock 对数据库进行 Mock，首先我们来看下被测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/db&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">userRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">Instance *db.Instance</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ur *userRepo)</span></span> FindUser(c context.Context, id <span class="type">uint64</span>) (*model.User, <span class="type">error</span>) &#123;</span><br><span class="line">user := <span class="built_in">new</span>(model.User)</span><br><span class="line"><span class="keyword">if</span> err := ur.Instance.Conn(c).</span><br><span class="line">Table(model.TabNameUser()).</span><br><span class="line">Where(<span class="string">&quot;id = ?&quot;</span>, id).</span><br><span class="line">First(user).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, gorm.ErrRecordNotFound) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;user not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>被测试代码中的 <code>FindUser</code> 方法是一个查询用户信息的方法</li><li>它依赖于项目中的 <code>db.Instance</code> 对象，这个对象是一个 PostgreSQL 数据库连接对象</li><li>该方法使用 <code>grom</code> 库以 ORM 方式查询数据库信息，简化了 SQL 查询的操作</li><li>转换成 SQL 语句大概是这样：<code>SELECT * FROM users WHERE id = ?</code></li></ul><p>下面我们来看下如何创建一个数据库 Mock 对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/DATA-DOG/go-sqlmock&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/postgres&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm/logger&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DbMock</span><span class="params">(t *testing.T)</span></span> (*sql.DB, *gorm.DB, sqlmock.Sqlmock) &#123;</span><br><span class="line">sqldb, mock, _ := sqlmock.New()</span><br><span class="line">dialector := postgres.New(postgres.Config&#123;</span><br><span class="line">Conn:       sqldb,</span><br><span class="line">DriverName: <span class="string">&quot;postgres&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">gormdb, _ := gorm.Open(dialector, &amp;gorm.Config&#123;</span><br><span class="line">Logger: logger.Default.LogMode(logger.Info),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> sqldb, gormdb, mock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DbMock</code> 方法使用 <code>sqlmock.New()</code> 方法创建 <code>sqldb</code> 和 <code>mock</code> 对象</li><li><code>sqldb</code> 对象主要用来模拟数据库，<code>mock</code> 对象用来设置预期的查询和结果</li><li>使用 <code>gorm.Open</code> 方法创建一个 PostgreSQL 数据库连接对象 <code>gormdb</code></li></ul><p>接下来我们来看下测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/db&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/DATA-DOG/go-sqlmock&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFindUserSuccess</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">sqldb, gormdb, mock := DbMock(t)</span><br><span class="line"><span class="keyword">defer</span> sqldb.Close()</span><br><span class="line"></span><br><span class="line">testName := <span class="string">&quot;user1&quot;</span></span><br><span class="line">testOrg := <span class="string">&quot;org1&quot;</span></span><br><span class="line">rows := sqlmock.NewRows([]<span class="type">string</span>&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;organization&quot;</span>&#125;).AddRow(<span class="number">1</span>, testName, testOrg)</span><br><span class="line">mock.ExpectQuery(<span class="string">`SELECT`</span>).WillReturnRows(rows)</span><br><span class="line"></span><br><span class="line">ctx := context.TODO()</span><br><span class="line">repo := &amp;userRepo&#123;</span><br><span class="line">Instance: &amp;db.Instance&#123;DB: gormdb&#125;,</span><br><span class="line">&#125;</span><br><span class="line">user, err := repo.FindUser(ctx, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">assert.NoError(t, err)</span><br><span class="line">assert.Equal(t, testName, user.Name)</span><br><span class="line">assert.Equal(t, testOrg, user.Organization)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在测试函数中，我们首先调用 <code>DbMock</code> 方法创建返回几个数据库 Mock 对象</li><li>然后使用 <code>sqlmock</code> 设置数据库查询的预期结果，我们使用用户表的 3 个字段设置了一条记录</li><li>再使用 <code>mock</code> 对象模拟查询语句的执行结果，这里的查询语句使用了正则表达式的匹配方式，也就是说，这里的 <code>SELECT</code> 可以匹配任何以 <code>SELECT</code> 开头的 SQL 语句，包括 <code>SELECT * FROM users WHERE id = ?</code></li><li>使用模拟的 <code>gormdb</code> 实例化 <code>userRepo</code> 对象</li><li>最后调用 <code>FindUser</code> 方法，验证返回值是否符合预期</li></ul><h2 id="Http-请求-Mock"><a href="#Http-请求-Mock" class="headerlink" title="Http 请求 Mock"></a>Http 请求 Mock</h2><p>在 Web 开发中，我们经常会遇到对外部 HTTP 服务的调用，比如调用第三方 API、调用微服务等。在单元测试中，我们不可能对这些外部服务进行真实的调用，这样会使得单元测试变得缓慢且不稳定，我们需要对这些 HTTP 请求进行 Mock，这样就可以模拟外部服务的行为，从而使得单元测试更加高效和可靠。</p><p><a href="https://pkg.go.dev/net/http/httptest">httptest</a> 是 Go 语言标准库中提供的一个 HTTP 服务测试工具，它可以模拟 HTTP 请求和响应，用于测试 HTTP 服务的功能和性能。httptest 包中的 <code>NewRequest</code> 和 <code>NewRecorder</code> 方法可以模拟 HTTP 请求和响应，我们可以使用这两个方法来模拟 HTTP 请求和响应，从而实现对 HTTP 服务的 Mock。</p><p>下面我们来看下如何使用 httptest 对 HTTP 请求进行 Mock，以常用的 Web 开发框架 <a href="https://github.com/gin-gonic/gin">Gin</a> 为例，下面是一个 Gin 的 Controller 例子，Controller 中有一个 <code>Login</code> 方法，用于处理用户登录请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/dto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">controller <span class="keyword">struct</span> &#123;</span><br><span class="line">service FooService</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *controller)</span></span> Login(c *gin.Context) &#123;</span><br><span class="line">req := <span class="built_in">new</span>(dto.ReqLogin)</span><br><span class="line"><span class="keyword">if</span> err := c.BindJSON(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Error(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := re.service.Login(c, *req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Error(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Login</code> 方法从请求 Body 中获取数据并转换为 <code>ReqLogin</code> 对象</li><li>然后调用 service 中的 <code>Login</code> 方法处理登录逻辑</li><li>最后将 server 方法的返回结果序列化为 JSON 返回给客户端</li></ul><p>下面我们来看下如何对 Controller 的 <code>Login</code> 方法进行单元测试，这里我们需要使用 GoMock 对 <code>service</code> 进行 Mock，同时使用 httptest 对 HTTP 请求进行 Mock：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/http/httptest&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/org/proj/server/dto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/golang/mock/gomock&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestResourceLoginSuccess</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctrl := gomock.NewController(t)</span><br><span class="line"><span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">jsonBody := []<span class="type">byte</span>(<span class="string">`&#123; &quot;account&quot;: &quot;foo&quot;, &quot;password&quot;: &quot;baz&quot; &#125;`</span>)</span><br><span class="line">req := httptest.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/login&quot;</span>, bytes.NewBuffer(jsonBody))</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">w := httptest.NewRecorder()</span><br><span class="line">ctx, _ := gin.CreateTestContext(w)</span><br><span class="line">ctx.Request = req</span><br><span class="line"></span><br><span class="line">mockService := NewMockOAuthService(ctrl)</span><br><span class="line">expectedResp := &amp;dto.RespLogin&#123;</span><br><span class="line">Account:      <span class="string">&quot;test-account&quot;</span>,</span><br><span class="line">Organization: <span class="string">&quot;test-org&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">mockService.EXPECT().Login(ctx, gomock.Any()).Return(expectedResp, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">cd := &amp;controller&#123;</span><br><span class="line">service: mockService,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cd.Login(ctx)</span><br><span class="line"></span><br><span class="line">assert.Equal(t, http.StatusOK, ctx.Writer.Status())</span><br><span class="line">assert.Nil(t, ctx.Errors)</span><br><span class="line"></span><br><span class="line">resp := &amp;dto.RespLogin&#123;&#125;</span><br><span class="line">err := json.Unmarshal(w.Body.Bytes(), resp)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">assert.Equal(t, expectedResp, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先使用 <code>httptest.NewRequest</code> 方法创建一个 URL 为 <code>/login</code> 的 POST 请求，请求 Body 为一个我们设置好的 JSON 数据</li><li>然后使用 <code>httptest.NewRecorder</code> 方法创建一个 Response 对象，用于保存请求的返回结果，使用 <code>gin.CreateTestContext</code> 方法创建一个测试上下文对象，将 Request 对象赋值给上下文对象</li><li>接着使用 GoMock 对 <code>service</code> 的 <code>Login</code> 方法进行 Mock，设置预期的返回值</li><li>调用 Controller 的 <code>Login</code> 方法，传入上下文对象</li><li>在验证阶段，先验证返回状态码和 <code>ctx.Errors</code> 是否正确</li><li>最后验证被测方法中 <code>c.JSON(http.StatusOK, resp)</code> 返回的 JSON 数据是否符合预期，这个 JSON 在原方法中被添加到了 <code>ctx.Writer</code> 中，我们可以通过 <code>w.Body.Bytes()</code> 获取到这个 JSON 数据</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们介绍了在 Golang 中对不同测试对象进行 Mock 的 5 种方法，包括常用的测试工具库 Testify Mock 和 GoMock，以及如何 Mock 引用包、数据库和 HTTP 请求。通过这些 Mock 技术，我们能够灵活替换外部依赖，定制其行为和返回值，确保测试环境的可控性。掌握了这些 Mock 技术，以后无论是模拟任何数据或方法，都能让你的单元测试更加高效和可靠。</p><p>关注我，一起学习最新的开发编程新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍在 Golang 中对不同测试对象进行 Mock 的 5 种方法</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="golang" scheme="https://zhaozhiming.github.io/tags/golang/"/>
    
    <category term="mock" scheme="https://zhaozhiming.github.io/tags/mock/"/>
    
    <category term="unit-test" scheme="https://zhaozhiming.github.io/tags/unit-test/"/>
    
    <category term="sql-mock" scheme="https://zhaozhiming.github.io/tags/sql-mock/"/>
    
    <category term="httpmock" scheme="https://zhaozhiming.github.io/tags/httpmock/"/>
    
  </entry>
  
  <entry>
    <title>部署 AWS ECS 超详细攻略</title>
    <link href="https://zhaozhiming.github.io/2024/10/04/use-github-action-to-deploy-aws-ecs/"/>
    <id>https://zhaozhiming.github.io/2024/10/04/use-github-action-to-deploy-aws-ecs/</id>
    <published>2024-10-04T14:10:05.000Z</published>
    <updated>2024-10-14T13:16:59.047Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/10/github-deploy-aws-ecs.jpg" class="" width="400" height="300"><p>随着云计算和容器化的广泛普及，越来越多的团队选择使用 <a href="https://aws.amazon.com/">AWS</a> ECS（Elastic Container Service）来运行他们的应用服务。同时，通过 GitHub Action 自动化 CI&#x2F;CD 流程可以极大地提高开发效率。本文将详细介绍如何结合 GitHub Action 和 AWS ECS，将代码从仓库无缝部署到生产环境中。</p><span id="more"></span><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><img src="/images/post/2024/10/github-action-deploy-ecs-flow.png" class="" width="1000" height="600"><p>在使用 GitHub Action 部署 AWS ECS 的过程中，整体流程可以分为以下几个步骤：</p><ul><li>创建 ECR 资源：首先需要在 AWS ECR（Elastic Container Registry）中创建镜像仓库，用于存储应用程序的 Docker 镜像。通过 ECR，我们可以轻松地管理镜像的版本和更新，确保每次部署都能拉取到最新的稳定镜像。</li><li>配置 IAM 角色和权限：然后是配置好必要的 IAM 角色和权限，以便在整个流程中授权不同的服务执行所需的操作。这些角色包括 ECS 任务角色、执行角色以及 GitHub Action 的执行角色。</li><li>创建 ECS 资源：接着需要在 AWS 中创建 ECS 资源，包括 ECS 集群、服务和任务定义。这些资源用于运行容器化的应用程序，确保应用程序能够在容器中稳定运行。</li><li>创建 GitHub 工作流：在代码仓库中编写 GitHub Action 工作流，用于自动化构建和部署流程，通过 YAML 文件定义工作流步骤。</li></ul><h2 id="创建-ECR-资源"><a href="#创建-ECR-资源" class="headerlink" title="创建 ECR 资源"></a>创建 ECR 资源</h2><p>在部署 ECS 容器应用时，我们需要一个地方存放容器镜像，AWS ECR 正是用于存放 Docker 镜像的服务。AWS ECR 是一个完全托管的 Docker 容器注册表，集成了 AWS 的身份验证与访问控制，确保镜像的安全性。</p><p>ECR 提供了镜像仓库的功能，可以将应用的 Docker 镜像推送到 ECR 中。在部署 ECS 服务时，ECR 充当镜像存储库，ECS 会从中拉取镜像来启动任务。通过 ECR，我们可以轻松地管理镜像的版本和更新，确保每次部署都能拉取到最新的稳定镜像。同时，ECR 支持生命周期策略，可以自动清理旧的和不再使用的镜像，以节省存储成本。</p><p>在 AWS 管理控制台上创建镜像仓库的步骤如下：</p><ul><li>登录到 AWS 管理控制台，然后导航到 Amazon ECR 服务页面。</li><li>在左侧导航栏中，选择 <code>Private registry</code> 或 <code>Public registry</code>，然后点击 <code>Repositories</code>。</li><li>点击右上角的 <code>Create repository</code> 按钮，如截图中所示。</li></ul><img src="/images/post/2024/10/aws-ecr-create-repository.png" class="" width="1000" height="600"><h2 id="配置-IAM-角色和权限"><a href="#配置-IAM-角色和权限" class="headerlink" title="配置 IAM 角色和权限"></a>配置 IAM 角色和权限</h2><p>在部署 AWS ECS 的过程中，有 3 种 IAM（Identity and Access Management） 角色需要配置：</p><ul><li>ECS 任务角色：用于授予 ECS 内部的任务权限，一般用来访问其他 AWS 服务，此角色应赋予容器内的应用程序所需的最小权限。</li><li>ECS 执行角色：用于授予 ESC 执行的任务权限，一般是从 ECR 拉取镜像和写入 CloudWatch 日志，此角色同样应赋予最小权限。</li><li>GitHub Action 执行角色：用于在 GitHub Action 中执行 AWS 操作，一般是推送镜像到 ECR 和更新 ECS 服务。</li></ul><h3 id="ECS-任务角色"><a href="#ECS-任务角色" class="headerlink" title="ECS 任务角色"></a>ECS 任务角色</h3><p>ECS 任务角色允许运行在 ECS 中的任务访问其他 AWS 服务。例如，如果任务中的容器需要访问 S3 存储，这时就需要配置合适的任务角色来访问 S3。任务角色的主要作用是授予容器内的应用程序权限，以便它们能够与其他 AWS 服务进行交互。为了提升安全性，任务角色应在满足应用程序需求的同时赋予最小权限。</p><p>以下是一个任务角色的最小权限策略示例，该角色允许操作 Lambda 函数和 Secrets Manager：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;lambda:InvokeFunction&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lambda:GetFunctionConfiguration&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:GetSecretValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:DescribeSecret&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="ECS-执行角色"><a href="#ECS-执行角色" class="headerlink" title="ECS 执行角色"></a>ECS 执行角色</h3><p>ECS 执行角色是 ECS 用来执行任务时的角色，主要用于拉取镜像（例如从 ECR 拉取镜像）以及写入 CloudWatch 日志。执行角色确保 ECS 能够顺利执行任务的相关操作，正确配置执行角色可以确保任务运行过程中能够顺利访问必要的资源，特别是在自动化部署和扩展过程中起到关键作用。</p><p>为了配置执行角色的最小权限，可以使用 AWS 的预定义策略 <code>AmazonECSTaskExecutionRolePolicy</code>（权限策略如下所示），这样可以确保角色具备最低限度的权限来完成必要的任务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;ecr:GetAuthorizationToken&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:BatchCheckLayerAvailability&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:GetDownloadUrlForLayer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:BatchGetImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;logs:CreateLogStream&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;logs:PutLogEvents&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="GitHub-Action-执行角色"><a href="#GitHub-Action-执行角色" class="headerlink" title="GitHub Action 执行角色"></a>GitHub Action 执行角色</h3><p>在一些 Github Action 部署文档中（包括 <a href="https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-amazon-elastic-container-service">Github 官方的文档</a>），都会使用 AWS 的 IAM 用户来作为访问 AWS 的凭证（提供用户的 SECRET ACCESS KEY 和 SECRET ACCESS KEY），但<strong>这种方式并不是最佳实践</strong>，因为这样会暴露用户的凭证，更好的方式是创建一个角色来授权 Github Action 来访问 AWS 的资源。该角色需要有足够的权限来推送镜像到 ECR，并更新 ECS 服务的任务定义或服务。</p><p>以下是一个 GitHub Action 执行角色权限策略示例，并对示例中的策略进行说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VisualEditor0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecs:RegisterTaskDefinition&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iam:PassRole&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iam::&lt;account-id&gt;:role/&lt;task-role&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iam::&lt;account-id&gt;:role/&lt;task-execution-role&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ecs:DescribeServices&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ecs:UpdateService&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:ecs:&lt;region&gt;:&lt;account-id&gt;:service/&lt;ecs-cluster&gt;/&lt;esc-service&gt;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;ecr:GetAuthorizationToken&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:BatchCheckLayerAvailability&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:InitiateLayerUpload&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:UploadLayerPart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:CompleteLayerUpload&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ecr:PutImage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>ECS 任务定义注册权限：允许注册 ECS 任务定义，主要用于创建或更新任务定义，使其能够包含新的应用配置和容器信息。</li><li>IAM 角色传递权限：允许将 IAM 角色传递给 ECS 服务。这意味着该角色可以在执行任务时传递其他 IAM 角色的权限，这里将权限传递给了我们之前创建的 2 个 ECS 角色——任务角色和执行角色，以便这些任务可以访问必要的 AWS 资源。</li><li>ECS 服务描述和更新权限：允许查看指定 ECS 服务的状态和配置信息，允许更新 ECS 服务配置，例如更改使用的任务定义，或调整服务的副本数量。这里的资源填写的是 ECS 服务的 ARN，ECS 服务我们在下面会介绍如何创建。</li><li>ECR 镜像操作权限：允许获取 ECR 访问令牌、检查镜像层是否存在、上传镜像层以及推送镜像到 ECR，以供 ECS 使用。</li></ul><h2 id="创建-ECS-资源"><a href="#创建-ECS-资源" class="headerlink" title="创建 ECS 资源"></a>创建 ECS 资源</h2><p>AWS ECS 是 AWS 提供的一种容器管理服务，它使得运行、停止和管理 Docker 容器变得更加简单。在部署 AWS ECS 服务之前，我们需要先创建 ECS 集群和服务。</p><h3 id="创建集群和服务"><a href="#创建集群和服务" class="headerlink" title="创建集群和服务"></a>创建集群和服务</h3><ul><li>进入 ECS 控制台，点击 <code>Create Cluster</code>，选择适合的运行类型（如 Fargate 或 EC2），配置集群的相关参数，确认后点击 <code>Create</code> 按钮完成集群的创建。</li><li>在集群创建完成后，点击 <code>Create Service</code>，选择服务类型，配置服务的相关参数，确认后点击 <code>Create</code> 按钮完成创建。</li></ul><img src="/images/post/2024/10/aws-ecs-create-cluster.png" class="" width="1000" height="600"><img src="/images/post/2024/10/aws-ecs-create-service.png" class="" width="1000" height="600"><h3 id="创建任务定义"><a href="#创建任务定义" class="headerlink" title="创建任务定义"></a>创建任务定义</h3><p>任务定义是 ECS 中的核心概念之一，可以看作是应用的蓝图。它定义了容器的配置，包括镜像的来源、CPU 和内存的资源需求、端口配置等。每次启动任务时，都会根据任务定义运行相应的容器。任务定义的创建需要非常细致和准确，以确保部署的应用程序符合需求，例如可以设置环境变量、挂载卷和定义日志记录等。正确配置任务定义是确保应用程序在容器中稳定运行的基础。</p><p>以下是一个任务定义的 JSON 文件示例，并对示例中的代码进行说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;containerDefinitions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-task-definition-name&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;organization&gt;/&lt;image-name&gt;:&lt;image-tag&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;portMappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;supplier-8080-tcp-port&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;containerPort&quot;</span><span class="punctuation">:</span> <span class="number">8080</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;hostPort&quot;</span><span class="punctuation">:</span> <span class="number">8080</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;appProtocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;essential&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environmentFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mountPoints&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;volumesFrom&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ulimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logConfiguration&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;logDriver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;awslogs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;awslogs-group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/ecs/&lt;ecs-service&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;awslogs-create-group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;awslogs-region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;region&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;awslogs-stream-prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecs&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;secretOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;systemControls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;family&quot;</span><span class="punctuation">:</span> <span class="string">&quot;myserver-defs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;taskRoleArn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:iam::&lt;account-id&gt;:role/&lt;task-role-name&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;executionRoleArn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:iam::&lt;account-id&gt;:role/&lt;task-execution-role-name&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;networkMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;awsvpc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;placementConstraints&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;requiresCompatibilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;FARGATE&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="string">&quot;512&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2048&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runtimePlatform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cpuArchitecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;X86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;operatingSystemFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LINUX&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>containerDefinitions 属性：定义了容器的详细配置，包括容器名称、镜像来源、CPU 和内存的分配、端口映射等。在此示例中，容器名称为 <code>my-task-definition-name</code>，镜像是我们刚才创建的 ECR 镜像仓库中的镜像名称，并将容器的 8080 端口映射到主机的 8080 端口。</li><li>logConfiguration 属性：指定了日志配置，使用 AWS CloudWatch Logs 记录容器的日志信息。日志组名称为 <code>/ecs/&lt;ecs-service&gt;</code>，并且在必要时会自动创建日志组。</li><li>taskRoleArn 和 executionRoleArn 属性：分别指定了 ECS 任务角色和执行角色的 ARN，也就是我们刚才创建的 2 个 ECS 角色，它们用于控制容器内的应用访问其他 AWS 服务的权限，以及任务执行过程中所需的权限。</li><li>networkMode 属性：指定网络模式为 <code>awsvpc</code>，表示容器将使用 AWS VPC 网络模式，这对于 Fargate 类型（无服务器计算引擎，用于简化容器部署）的任务是必需的。</li><li>requiresCompatibilities 属性：指定任务兼容性为 <code>FARGATE</code>，表示此任务将在 AWS Fargate 上运行。</li><li>cpu 和 memory 属性：定义了任务的 CPU 和内存配置。在此示例中，任务分配了 512 个 CPU 单位（0.5 个 vCPU）和 2048 MB 的内存。</li><li>runtimePlatform 属性：指定了运行平台的架构和操作系统类型，确保任务在合适的环境中运行。</li></ul><h2 id="创建-GitHub-工作流"><a href="#创建-GitHub-工作流" class="headerlink" title="创建 GitHub 工作流"></a>创建 GitHub 工作流</h2><p>GitHub Action 是 GitHub 提供的自动化工作流工具，可以用于构建、测试和部署代码。在我们的场景中，GitHub Action 可以被用来自动化构建 Docker 镜像并将其推送到 ECR，然后更新 ECS 服务。通过 GitHub Action，开发人员可以定义一套自动化的工作流，从代码提交到服务部署，全程无需人工干预。</p><p>GitHub Action 的工作流通过配置文件（通常是 <code>.github/workflows</code> 目录下的 YAML 文件）进行定义。</p><p>我们首先来看下构建和推送 Docker 镜像到 ECR 镜像仓库的工作流步骤示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build-push:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ECR</span> <span class="string">build</span> <span class="string">and</span> <span class="string">push</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">outputs:</span></span><br><span class="line">    <span class="attr">aws_ecr_image_tag:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.build-push-step.outputs.aws_ecr_image_tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">AWS</span> <span class="string">Credentials</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">aws-credentials</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">aws-actions/configure-aws-credentials@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">role-to-assume:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_GITHUB_ACTION_ROLE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">aws-region:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_REGION</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Log</span> <span class="string">in</span> <span class="string">to</span> <span class="string">Amazon</span> <span class="string">ECR</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">ecr-login</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">aws-actions/amazon-ecr-login@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">mask-password:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">registry-type:</span> <span class="string">private</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">build-push-step</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">AWS_ECR_REGISTRY:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.ecr-login.outputs.registry</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">AWS_ECR_REPOSITORY:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_ECR_REPOSITORY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export AWS_ECR_IMAGE_TAG=$AWS_ECR_REGISTRY/$AWS_ECR_REPOSITORY:$(git rev-parse --short HEAD)</span></span><br><span class="line"><span class="string">        docker build -f ./server/build/Dockerfile -t $AWS_ECR_IMAGE_TAG ./server</span></span><br><span class="line"><span class="string">        docker push $AWS_ECR_IMAGE_TAG</span></span><br><span class="line"><span class="string">        echo &quot;aws_ecr_image_tag=$AWS_ECR_IMAGE_TAG&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;</span></span><br></pre></td></tr></table></figure><ul><li>从 GitHub 仓库中检出最新代码，以便进行构建。</li><li>配置 AWS 凭据，通过 <code>role-to-assume</code> 设定需要承担的 AWS 角色，以及目标区域。<code>role-to-assume</code> 填写的是我们之前创建的 Github Action 执行角色的 ARN，可以将其配置到 Github 仓库的 Variables 中，确保在工作流中可以使用这些信息。</li><li>登录到 AWS ECR，并确保凭据安全，使用的是上一步骤中配置的 AWS 凭据。</li><li>设置环境变量，如 ECR 注册表和镜像仓库名，环境变量的值同样可以配置到 Github 仓库的 Variables 中。然后生成包含 Git 提交短哈希的镜像标签，构建镜像并推送到 ECR，然后输出镜像标签供后续使用。</li></ul><p>下面是 Github 仓库的 Secret 和  Variables 配置页面：</p><img src="/images/post/2024/10/github-setting-secret.png" class="" width="1000" height="600"><p>我们再来看 ECS 部署的工作流步骤示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ecs-deploy:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ECS</span> <span class="string">deployment</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">build-push</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">AWS_ECR_IMAGE_TAG:</span> <span class="string">$&#123;&#123;</span> <span class="string">needs.build-push.outputs.aws_ecr_image_tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">AWS</span> <span class="string">Credentials</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">aws-credentials</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">aws-actions/configure-aws-credentials@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">role-to-assume:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_GITHUB_ACTION_ROLE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">aws-region:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_REGION</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Render</span> <span class="string">Amazon</span> <span class="string">ECS</span> <span class="string">task</span> <span class="string">definition</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">render-task-def</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">aws-actions/amazon-ecs-render-task-definition@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">task-definition:</span> <span class="string">your/task/definition/file.json</span></span><br><span class="line">        <span class="attr">container-name:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_ECS_CONTAINER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.AWS_ECR_IMAGE_TAG</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">environment-variables:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          FOO=$&#123;&#123; vars.FOO &#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Amazon</span> <span class="string">ECS</span> <span class="string">task</span> <span class="string">definition</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy-task-def</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">aws-actions/amazon-ecs-deploy-task-definition@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">task-definition:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.render-task-def.outputs.task-definition</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">service:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_ECS_SERVICE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">cluster:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.AWS_ECS_CLUSTER</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>ecs-deploy</code> 步骤中，将构建好的 Docker 镜像部署到 Amazon ECS 服务，依赖于前一步的 <code>build-push</code> 步骤，使用构建步骤的输出值 <code>aws_ecr_image_tag</code> 作为镜像标签。</li><li>检出代码，以便在部署过程中使用最新的代码版本。</li><li>配置 AWS 凭据，通过 <code>role-to-assume</code> 来承担之前配置好的 GitHub Action 执行角色，并指定 AWS 区域。</li><li>渲染任务定义文件，更新其中的容器镜像、环境变量等配置。这里的任务定义文件为 <code>your/task/definition/file.json</code>， 这个 JSON 文件相当于我们刚才介绍的任务定义示例文件，并替换容器镜像和其他必要的环境变量。</li><li>将渲染后的任务定义部署到指定的 ECS 服务和集群中，确保最新的代码和配置能够进行正确部署。这里用到了我们之前创建的 ECS Cluster 和 Service，可以将它们的名字配置到 Github 仓库的 Variables 中。</li></ul><p>通过这种方式，代码一旦合并到主分支，就可以触发 GitHub Action 完成从构建到部署的一系列操作，极大地简化了手动部署的复杂度，同时保证了每次部署的一致性和可重复性。工作流的配置可以根据团队的需求进行扩展，例如加入单元测试、静态代码分析、通知等，以确保代码质量和部署的可靠性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了部署 AWS ECS 所需的资源和权限，以及通过自动化工作流实现无缝部署。整体流程包括创建 ECR 资源、配置 IAM 角色和权限、创建 ECS 资源，以及编写 GitHub Action 工作流，实现从代码检出到容器部署的完整自动化。通过这种方式，开发团队可以提高部署效率，确保每次部署的一致性和可重复性，同时增强安全性和代码质量控制。</p><p>关注我，一起学习最新的开发编程新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">详尽介绍使用 AWS 角色在 GitHub Action 中部署 AWS ECS 服务</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="github" scheme="https://zhaozhiming.github.io/tags/github/"/>
    
    <category term="aws" scheme="https://zhaozhiming.github.io/tags/aws/"/>
    
    <category term="role" scheme="https://zhaozhiming.github.io/tags/role/"/>
    
    <category term="ecs" scheme="https://zhaozhiming.github.io/tags/ecs/"/>
    
    <category term="github-action" scheme="https://zhaozhiming.github.io/tags/github-action/"/>
    
  </entry>
  
  <entry>
    <title>使用 AWS 角色隔离资源和权限</title>
    <link href="https://zhaozhiming.github.io/2024/10/03/use-aws-role-to-isolate-resources-and-privilege/"/>
    <id>https://zhaozhiming.github.io/2024/10/03/use-aws-role-to-isolate-resources-and-privilege/</id>
    <published>2024-10-03T08:56:11.000Z</published>
    <updated>2024-10-06T10:30:25.508Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/10/aws-role.jpg" class="" width="400" height="300"><p>AWS 是目前全球最大的云服务提供商，提供了丰富的云服务，开发 Web 应用时经常会用到 AWS 的各种服务。在开发这种应用时，有时候开发人员为了图方便省事，只创建一个 AWS 角色来管理应用所涉及的所有 AWS 资源，这样不仅不利于 AWS 资源的管理，而且还会因为权限不当导致系统的安全性受到威胁。本文将介绍 AWS 角色中权限相关的内容，以及如何使用 AWS 角色策略对资源和权限进行隔离。</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>假设一家初创公司在开发他们的电商平台时，决定使用 AWS 提供的几种服务，包括 Amazon S3 存储产品图片，Amazon RDS 存储用户数据，以及 Amazon Lambda 处理后台任务。为了快速开发和部署，开发人员创建了一个单一的 AWS 角色，这个角色被赋予了完全访问 S3、RDS 和 Lambda 的权限，以便可以无障碍地调用这些服务。这意味着所有用户共享相同的权限，没有进行细粒度的权限控制，导致潜在的安全隐患。</p><img src="/images/post/2024/10/source-aws-design.png" class="" width="1000" height="600"><p>如果有坏人进入了这个应用程序，他们将能够访问所有的 AWS 资源，包括 S3、RDS 和 Lambda。这种情况下，坏人可以下载 S3 中所有的图片，删除 RDS 中的用户数据，或者通过 Lambda 执行恶意代码，造成严重的安全隐患。</p><img src="/images/post/2024/10/source-aws-design-danger.png" class="" width="1000" height="600"><p>在这种情况下，我们可以使用 AWS 角色策略对资源和权限进行隔离。用户通过应用程序使用各自的 AWS 角色来访问 AWS 资源。每个角色被分配了相对应最低限度的权限，每个角色只能访问其对应的资源，而不能访问其他角色的资源。通过这种方式，每个用户只能访问与其相关的资源，避免了权限的滥用和安全隐患。</p><img src="/images/post/2024/10/complete-aws-design.png" class="" width="1000" height="600"><h2 id="AWS-角色"><a href="#AWS-角色" class="headerlink" title="AWS 角色"></a>AWS 角色</h2><p>在 AWS 的 IAM（Identity and Access Management）服务中，角色是一个 AWS 身份，它不是与特定用户或组关联的，而是与 AWS 服务关联的。角色定义了一个实体，它可以代表一个用户、一个应用程序或者一个服务，以便可以访问 AWS 资源。角色可以通过权限策略来控制对资源的访问权限，以及信任关系来控制角色的使用者。</p><h3 id="权限属性"><a href="#权限属性" class="headerlink" title="权限属性"></a>权限属性</h3><p>在日常使用中，<em>权限策略（Permission Policy）</em>和<em>信任关系（Trust Relationship）</em>是 AWS 角色权限最常用和最核心的两个属性。</p><p><strong>权限策略</strong></p><ul><li>定义：权限策略是一个以 JSON 格式编写的文档，定义了角色被授予的具体权限。它描述了角色可以对哪些 AWS 资源执行哪些操作。</li><li>作用：控制角色在 AWS 中<em>可以做什么</em>。例如，允许角色访问特定的 S3 存储桶、启动 EC2 实例、或调用特定的 Lambda 函数等。</li></ul><p><strong>信任关系</strong></p><ul><li>定义：信任关系也是一个以 JSON 格式编写的文档，定义了哪些实体（如用户、角色、服务）被允许扮演（Assume） 该角色。它指定了可以获得该角色临时凭证的主体。</li><li>作用：控制<em>谁可以扮演这个角色</em>。例如，允许特定的 IAM 用户、其他角色或者 AWS 服务（如 EC2、Lambda）来扮演该角色。</li></ul><p>这两者共同构成了 IAM 角色的安全模型，权限策略确保角色只能执行被授予的操作，信任关系确保只有被信任的主体才能扮演该角色。</p><h3 id="操作资源"><a href="#操作资源" class="headerlink" title="操作资源"></a>操作资源</h3><p>AWS 角色可以被授予访问任何 AWS 服务和资源的权限，具体取决于添加到该角色的权限策略，可操作的资源包括但不限于：</p><ul><li>AWS Lambda：创建、更新、调用函数；配置触发器和日志等。</li><li>Amazon EventBridge Scheduler：可以按照预定的时间或间隔来调度任务或操作。</li><li>AWS KMS（密钥管理服务）：创建和管理加密密钥；控制密钥的使用权限等</li></ul><p>还有很多其他 AWS 服务和资源没有列出来，这里只列出比较常用的几种 AWS 资源，我们在下面的示例也会着重介绍如何通过角色策略来控制这些资源的访问权限。</p><h2 id="添加信任关系"><a href="#添加信任关系" class="headerlink" title="添加信任关系"></a>添加信任关系</h2><p>在 AWS 角色中，信任关系是一个非常重要的属性，它定义了哪些实体被允许扮演该角色。信任关系是一个以 JSON 格式编写的文档，它指定了可以获得该角色临时凭证的主体。这些实体可以是 AWS 服务或者 IAM 用户 。</p><p>下面的信任关系中添加了 <code>event</code>、<code>lambda</code> 和 <code>scheduler</code> 3 个 AWS 服务，这意味着这些服务可以扮演该角色。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Service&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;events.amazonaws.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;scheduler.amazonaws.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;lambda.amazonaws.com&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sts:AssumeRole&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>下面的信任关系中添加了 IAM 用户 <code>user1</code> 作为扮演该角色的主体，这意味着 <code>user1</code> 可以扮演该角色。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/user1@org1.com&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sts:AssumeRole&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 <code>Statement</code> 是一个数组，这意味着你可以将多个实体添加到信任关系中，比如同时添加其他 AWS 服务和 IAM 用户。</p><h2 id="添加权限策略"><a href="#添加权限策略" class="headerlink" title="添加权限策略"></a>添加权限策略</h2><p>在 AWS 角色中添加权限策略是控制角色对资源的访问权限的关键，我们可以通过以下两种方式来添加权限策略：</p><img src="/images/post/2024/10/aws-role-permission.png" class="" width="1000" height="600"><h3 id="添加预定义策略"><a href="#添加预定义策略" class="headerlink" title="添加预定义策略"></a>添加预定义策略</h3><p>AWS 提供了一些预定义的策略，可以直接添加到角色中，这些策略包括了一些常用的权限，比如只读、只写、完全访问等。以 Lambda 服务为例，你可以在 AWS 控制台中选择<code>AWSLambda_FullAccess</code>、<code>AWSLambda_ReadOnlyAccess</code>、<code>AWSLambdaBasicExecutionRole</code> 等预定义策略，然后将其添加到角色中。</p><p>添加预定义策略的好处是你不必了解所有的权限细节，比如你要添加 Lambda 函数的权限，你可以直接添加 <code>AWSLambda_FullAccess</code> 策略，这样就可以访问 Lambda 服务的所有权限。虽然这样做十分方便，，但是每个预定义策略的权限范围可能比你所需的权限更广泛或者更窄，甚至有时候为了添加几个不同资源的权限而添加了很多个预定义策略。</p><h3 id="创建自定义策略"><a href="#创建自定义策略" class="headerlink" title="创建自定义策略"></a>创建自定义策略</h3><p>自定义策略就比预定义策略灵活的多，你可以根据自己的需求将不同 AWS 服务的权限添加到一个策略中，比如下面这个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;lambda:InvokeFunction&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lambda:GetFunction&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:GetSecretValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:DescribeSecret&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个自定义策略允许角色执行 Lambda 函数的 <code>InvokeFunction</code> 和 <code>GetFunction</code> 操作，同时允许角色获取 Secrets Manager 中的 <code>GetSecretValue</code> 和 <code>DescribeSecret</code> 操作。不必添加诸如 AWS Lambda 和 Secrets Manager 的预定义策略，而且权限范围更加精准，更加符合你的实际需求。</p><h2 id="权限隔离"><a href="#权限隔离" class="headerlink" title="权限隔离"></a>权限隔离</h2><p>下面我们再来介绍一下如何为 AWS 角色或者资源进行权限隔离，以保证资源和权限的安全性，下面以 Lambda 函数和 Secrets Manager 这两种资源为例进行介绍。</p><h3 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h3><p>在刚才的示例中，我们为角色添加了访问 Lambda 函数的权限策略，这意味着角色可以调用 Lambda 函数，但如果我们想控制角色<strong>只能调用特定的 Lambda 函数</strong>，那么我们就需要在权限策略中添加特定的 Lambda 函数的 ARN（Amazon 资源名称）。下面是一个示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;lambda:InvokeFunction&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lambda:GetFunction&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:lambda:us-west-1:123456789012:function:role1-*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以使用角色名称作为前缀来命名 Lambda 函数，然后在权限策略中添加限制，仅能调用以该前缀命名的 Lambda 函数，通过这种方式，可以保证该角色仅能调用属于自己的 Lambda 函数。假设我们的 AWS 角色名称为 <code>role1</code>，那么我们可以将 Lambda 函数的名称以 <code>role1-</code> 作为前缀，然后在角色的权限策略中添加只能调用以 <code>role1-</code> 为前缀的 Lambda 函数，这样就不会担心该角色调用其他 Lambda 函数。</p><p>还有另外一种方法，我们也可以在 Lambda 函数权限中设置可访问的角色，这样确保该 Lambda 函数只能被某个角色调用。在 AWS 上设置 Lambda 函数权限的具体路径为：<code>Lambda -&gt; Functions -&gt; Your Lambda Function -&gt; Configuration -&gt; Permissions -&gt; Add Permission</code>。</p><img src="/images/post/2024/10/aws-lambda-func-permission.png" class="" width="1000" height="600"><p>这两种方式都可以起到相同的作用，选择哪种方式取决于你的具体需求。当然你也可以同时使用这两种方式，这样可以让权限更加精确，但请确保这两者之间的权限不冲突。AWS 将同时评估两者，只有在两者都允许的情况下，访问才会被授予。</p><h3 id="Secret-Manager"><a href="#Secret-Manager" class="headerlink" title="Secret Manager"></a>Secret Manager</h3><p>为 Secrets Manager 添加权限策略也是一样的，我们在角色的权限策略中对资源进行限制，让其只能访问特定的 Secret，而不能访问其他 Secret。下面是一个示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:GetSecretValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:DescribeSecret&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:secretsmanager:us-west-1:123456789012:secret:role1-*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们将 Secret 的名字同样以角色名称为前缀，然后在权限策略中添加权限，只能访问以该前缀命名的 Secret，这样就可以确保该角色只能访问属于自己的 Secret。</p><p>同样地，我们也可以在 Secret 的权限中设置中可访问的角色，这样确保该 Secret 只能被某些角色访问。相比 Lambda 函数，Secret 的权限策略更加灵活，Secret 可以支持设置多个角色对其进行访问，而 Lambda 函数只能设置一个角色。下面是 Secret 的权限设置示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:iam::123456789012:role/role1&quot;</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:GetSecretValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;secretsmanager:DescribeSecret&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:secretsmanager:us-west-1:123456789012:secret:role1-SEC-wBO2wW&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Deny&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;secretsmanager:GetSecretValue&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:secretsmanager:us-west-1:123456789012:secret:role1-SEC-wBO2wW&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;StringNotEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;aws:PrincipalArn&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:iam::123456789012:role/role1&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个 Secret 的权限设置中，我们允许 <code>role1</code> 角色访问该 Secret，同时拒绝其他角色访问该 Secret。这样就保证了只有 <code>role1</code> 角色可以访问该 Secret，其他角色无法访问。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>如果手动来创建角色并设置权限策略，可能会比较繁琐，特别是当需要创建多个角色和资源的时候。为了提高效率，我们可以使用 AWS SDK 来快速执行这些操作。</p><p>下面我们通过 Go 语言来演示如何使用 <a href="https://aws.amazon.com/sdk-for-go/">AWS SDK</a> 来创建角色、Lambda 函数和 Secret，并设置权限策略。</p><h3 id="创建角色并设置权限策略"><a href="#创建角色并设置权限策略" class="headerlink" title="创建角色并设置权限策略"></a>创建角色并设置权限策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go/aws&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go/service/iam&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAwsRole</span><span class="params">(c context.Context, amazonConfig aws.Config)</span></span> (*iam.CreateRoleOutput, <span class="type">error</span>) &#123;</span><br><span class="line">roleName := <span class="string">&quot;role1&quot;</span></span><br><span class="line">assumeRolePolicyDocument := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;Version&quot;: &quot;2012-10-17&quot;,</span></span><br><span class="line"><span class="string">&quot;Statement&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">&quot;Principal&quot;: &#123;</span></span><br><span class="line"><span class="string">&quot;Service&quot;: [</span></span><br><span class="line"><span class="string">&quot;lambda.amazonaws.com&quot;,</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&quot;Action&quot;: &quot;sts:AssumeRole&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">createRoleInput := &amp;iam.CreateRoleInput&#123;</span><br><span class="line">RoleName:                 aws.String(roleName),</span><br><span class="line">AssumeRolePolicyDocument: aws.String(assumeRolePolicyDocument),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iamClient := iam.NewFromConfig(amazonConfig)</span><br><span class="line">role, err := iamClient.CreateRole(c, createRoleInput)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;create aws role occurred error: %s&quot;</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> role, err</span><br></pre></td></tr></table></figure><ul><li>在 <code>CreateRole</code> 的方法中，我们创建了一个名为 <code>role1</code> 的 AWS 角色，该角色的信任关系允许 Lambda 服务扮演该角色，这意味着该角色下的 Lambda 函数拥有该角色资源权限，比如该角色下的 Lambda 函数可以访问该角色下的 Secret。</li><li>创建 AWS 角色需要 2 个参数，一个是角色名称 <code>role1</code>，另一个是信任关系文档 <code>assumeRolePolicyDocument</code>。</li></ul><p>然后我们再为这个角色添加权限策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutRolePolicy</span><span class="params">(c context.Context, amazonConfig aws.Config, roleName <span class="type">string</span>)</span></span> (<span class="type">error</span>) &#123;</span><br><span class="line">policyDocument := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;Version&quot;: &quot;2012-10-17&quot;,</span></span><br><span class="line"><span class="string">&quot;Statement&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">&quot;Action&quot;: [</span></span><br><span class="line"><span class="string">&quot;lambda:InvokeFunction&quot;,</span></span><br><span class="line"><span class="string">&quot;lambda:GetFunction&quot;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">&quot;Resource&quot;: &quot;arn:aws:lambda:us-west-1:123456789012:function:role1-*&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">&quot;Action&quot;: [</span></span><br><span class="line"><span class="string">&quot;secretsmanager:GetSecretValue&quot;,</span></span><br><span class="line"><span class="string">&quot;secretsmanager:DescribeSecret&quot;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">            &quot;Resource&quot;: &quot;arn:aws:secretsmanager:us-west-1:123456789012:secret:role1-*&quot;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span>,</span><br><span class="line">putRolePolicyInput := &amp;iam.PutRolePolicyInput&#123;</span><br><span class="line">PolicyName:     aws.String(fmt.Sprintf(<span class="string">&quot;%s-policy&quot;</span>, roleName)),</span><br><span class="line">PolicyDocument: aws.String(policyDocument),</span><br><span class="line">RoleName:       aws.String(roleName),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iamClient := iam.NewFromConfig(amazonConfig)</span><br><span class="line">_, err = iamClient.PutRolePolicy(c, putRolePolicyInput)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(fmt.Sprintf(<span class="string">&quot;put role policy for aws role occurred error: %s&quot;</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>PutRolePolicy</code> 的方法中，我们为 <code>role1</code> 角色添加了权限策略</li><li>权限策略中允许该角色调用名称以 <code>role1-</code> 为前缀的 Lambda 函数</li><li>权限策略中允许该角色访问名称以 <code>role1-</code> 为前缀的 Secret</li><li>创建权限策略需要 3 个参数，一个是角色名称 <code>role1</code>，另一个是权限策略文档 <code>policyDocument</code>，最后一个是权限策略名称，这里我们使用角色名称加上 <code>-policy</code> 作为权限策略名称。</li></ul><h3 id="创建-Lambda-函数并设置角色权限"><a href="#创建-Lambda-函数并设置角色权限" class="headerlink" title="创建 Lambda 函数并设置角色权限"></a>创建 Lambda 函数并设置角色权限</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go/aws&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go/service/lambda&quot;</span></span><br><span class="line">    lambTypes <span class="string">&quot;github.com/aws/aws-sdk-go/service/lambda/types&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReqFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    _     <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Bytes []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLambdaFunction</span><span class="params">(c context.Context, file *ReqFile, roleName <span class="type">string</span>, roleARN <span class="type">string</span>, amazonConfig aws.Config)</span></span> (*lambda.CreateFunctionOutput, <span class="type">error</span>) &#123;</span><br><span class="line">splits := strings.Split(file.Name, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">fileName := splits[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">lambdaClient := lambda.NewFromConfig(amazonConfig)</span><br><span class="line">lambdaFun, err := lambdaClient.RegisterLambda(</span><br><span class="line">c,</span><br><span class="line">&amp;lambda.CreateFunctionInput&#123;</span><br><span class="line">Code: &amp;lambTypes.FunctionCode&#123;</span><br><span class="line">ZipFile: file.Bytes,</span><br><span class="line">&#125;,</span><br><span class="line">FunctionName: aws.String(fmt.Sprintf(<span class="string">&quot;%s-%s&quot;</span>, roleName, fileName)),</span><br><span class="line">Role:        aws.String(roleARN),</span><br><span class="line">Runtime:     lambTypes.RuntimeNodejs20x,</span><br><span class="line">Timeout:     aws.Int32(<span class="number">30</span>),</span><br><span class="line">Description: <span class="literal">nil</span>,</span><br><span class="line">Handler:     aws.String(fmt.Sprintf(<span class="string">&quot;%s.handler&quot;</span>, fileName)),</span><br><span class="line">PackageType: lambTypes.PackageTypeZip,</span><br><span class="line">Publish:     <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(opt *lambda.Options)</span></span> &#123;&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;failed to create lambda function: %s, err: %s&quot;</span>, fileName, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lambdaFun, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>CreateLambdaFunction</code> 的方法中，我们创建了一个 Lambda 函数</li><li>AWS SDK 的 <code>RegisterLambda</code> 方法需要多个参数，其中 <code>Role</code> 参数是角色的 ARN，就是我们刚才创建的那个角色</li><li>Lambda 函数需要一个 Zip 格式的文件，这个文件包含了 Lambda 函数的代码，代码中的主要执行函数是 <code>handler</code>，这个函数需要在 <code>Handler</code> 参数中指定</li><li>Lambda 函数的名称是角色名称加上文件名作为前缀，这样就保证了 Lambda 函数只能被该角色调用</li></ul><h3 id="创建-Secret-并设置角色权限"><a href="#创建-Secret-并设置角色权限" class="headerlink" title="创建 Secret 并设置角色权限"></a>创建 Secret 并设置角色权限</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go/aws&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-sdk-go/service/secretsmanager&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAwsSecretKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">c context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">awsRole *iam.CreateRoleOutput,</span></span></span><br><span class="line"><span class="params"><span class="function">amazonConfig aws.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*secretsmanager.CreateSecretOutput, <span class="type">error</span>) &#123;</span><br><span class="line">secretName := fmt.Sprintf(<span class="string">&quot;%s-Sec&quot;</span>, awsRole.Name)</span><br><span class="line">secretValue := <span class="string">&quot;secret-value&quot;</span></span><br><span class="line">input := &amp;secretsmanager.CreateSecretInput&#123;</span><br><span class="line">Name:         aws.String(secretName),</span><br><span class="line">SecretString: aws.String(secretValue),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secretManagerClient := secretsmanager.NewFromConfig(amazonConfig)</span><br><span class="line">awsSecretKey, err := secretManagerClient.CreateSecret(c, input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;create aws secret key occurred error: %s&quot;</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> awsSecretKey, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>CreateAwsSecretKey</code> 的方法中，我们创建了一个 Secret</li><li>参数 <code>awsRole</code> 是我们刚才创建的 AWS 角色，包含了角色的名称和 ARN</li><li>创建 Secret 需要 2 个参数，一个是 Secret 名称，另一个是 Secret 值</li><li>创建 Secret 名称时，我们使用角色名称加上 <code>-Sec</code> 作为 Secret 名称，这样就保证了 Secret 只能被该角色访问</li></ul><p>然后我们再为这个 Secret 添加资源策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutResourcePolicyForAwsSecretKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">c context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">roleARN <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">awsSecretKey *secretsmanager.CreateSecretOutput,</span></span></span><br><span class="line"><span class="params"><span class="function">amazonConfig aws.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">resourcePolicy := fmt.Sprintf(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;Version&quot;: &quot;2012-10-17&quot;,</span></span><br><span class="line"><span class="string">&quot;Statement&quot;: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Allow&quot;,</span></span><br><span class="line"><span class="string">&quot;Principal&quot;: &#123;</span></span><br><span class="line"><span class="string">&quot;AWS&quot;: [ &quot;%s&quot;  ]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&quot;Action&quot;: [ &quot;secretsmanager:GetSecretValue&quot;, &quot;secretsmanager:DescribeSecret&quot; ],</span></span><br><span class="line"><span class="string">&quot;Resource&quot;: &quot;%s&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;Effect&quot;: &quot;Deny&quot;,</span></span><br><span class="line"><span class="string">&quot;Principal&quot; : &quot;*&quot;,</span></span><br><span class="line"><span class="string">&quot;Action&quot; : &quot;secretsmanager:GetSecretValue&quot;,</span></span><br><span class="line"><span class="string">&quot;Resource&quot; : &quot;%s&quot;,</span></span><br><span class="line"><span class="string">&quot;Condition&quot;: &#123;</span></span><br><span class="line"><span class="string">&quot;StringNotEquals&quot;: &#123;</span></span><br><span class="line"><span class="string">&quot;aws:PrincipalArn&quot;: [ &quot;%s&quot; ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;`</span>,</span><br><span class="line">        roleARN,</span><br><span class="line">        awsSecretKey.ARN,</span><br><span class="line">        awsSecretKey.ARN,</span><br><span class="line">        roleARN,</span><br><span class="line">    )</span><br><span class="line">policyInput := &amp;secretsmanager.PutResourcePolicyInput&#123;</span><br><span class="line">SecretId:       aws.String(awsSecretKey.Name),</span><br><span class="line">ResourcePolicy: aws.String(resourcePolicy),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secretManagerClient = secretsmanager.NewFromConfig(amazonConfig)</span><br><span class="line">_, err = secretManagerClient.PutResourcePolicy(c, policyInput)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(fmt.Sprintf(<span class="string">&quot;put resource policy for aws secret key occurred error: %s&quot;</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>PutResourcePolicyForAwsSecretKey</code> 的方法中，我们为 Secret 添加了资源策略</li><li>参数 <code>awsSecret</code> 是我们刚才创建的 AWS Secret，包含了 Secret 的名称和 ARN 等信息</li><li>权限策略中允许 <code>role1</code> 角色访问该 Secret，同时拒绝其他角色访问该 Secret</li><li>添加 Secret 权限策略需要 2 个参数，一个是 Secret 名字，另一个是权限策略文档 <code>resourcePolicy</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们讨论了在开发 AWS 应用时遇到的普遍问题，以及解决这一问题的主要方法。在这个过程中，我们还介绍了 AWS 角色的权限属性，包括权限策略和信任关系，以及如何使用这些属性来隔离资源。最后我们通过 Go 语言代码示例演示了如何创建 AWS 角色、Lambda 函数和 Secret，并设置权限策略。通过代码的方式，我们可以快速创建和设置 AWS 资源，保证资源和权限的安全性。</p><p>关注我，一起学习最新的开发编程新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍如何使用 AWS 角色策略对资源和权限进行隔离</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="go-lang" scheme="https://zhaozhiming.github.io/tags/go-lang/"/>
    
    <category term="aws" scheme="https://zhaozhiming.github.io/tags/aws/"/>
    
    <category term="role" scheme="https://zhaozhiming.github.io/tags/role/"/>
    
    <category term="policy" scheme="https://zhaozhiming.github.io/tags/policy/"/>
    
    <category term="permission" scheme="https://zhaozhiming.github.io/tags/permission/"/>
    
  </entry>
  
  <entry>
    <title>Cursor 让我一天上手 Go 语言</title>
    <link href="https://zhaozhiming.github.io/2024/09/21/Cursor-helped-me-get-up-to-speed-with-Go-in-just-one-day/"/>
    <id>https://zhaozhiming.github.io/2024/09/21/Cursor-helped-me-get-up-to-speed-with-Go-in-just-one-day/</id>
    <published>2024-09-21T00:41:11.000Z</published>
    <updated>2024-10-03T08:49:29.889Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/09/cursor-ai-ide.jpg" class="" width="400" height="300"><p>最近看到网上不少人在讨论 <a href="https://www.cursor.com/">Cursor</a> 这款 AI 代码编辑器，我开始时还不以为然，因为在去年 Cursor 刚推出时我就试用了，当时并没有觉得特别惊艳，感觉和 Github 的 <a href="https://github.com/features/copilot">Copilot</a> 差不多，甚至还不如 Copilot 好用。但最近我被要求去开发一个新项目，我就想在新项目里尝试使用 Cursor 来开发，看看它是否有网上说的那么强大。今天我将为大家讲述我在这个新项目中使用 Cursor 的真实经历，并分享一些我的使用心得和体会。</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近被要求去开发一个新项目，这个项目是另外一位同事用 Go 语言开发的，已经开发了一段时间，但开发进度比原计划落后比较大，所以希望增加开发人手，希望我的加入能够在项目的里程碑节点完成开发工作。但尴尬的是，我之前并没有真正地写过 Go 语言。</p><img src="/images/post/2024/09/cursor-what.jpg" class="" width="600" height="400"><p>虽然我之前没有真正的写过 Go 语言，但或多或少看过一些 Go 语言的代码，而且我有其他语言的开发经验，我相信我可以很快上手 Go 语言，所以我决定接受这个挑战。</p><h2 id="决定使用-Cursor"><a href="#决定使用-Cursor" class="headerlink" title="决定使用 Cursor"></a>决定使用 Cursor</h2><p>在决定加入这个项目的这段时间，我经常在网上看到关于 Cursor 的宣传，我开始时并没有太在意，因为我觉得我已经有了 Github 的 Copilot，而且我去年也试用过 Cursor，没有觉得特别惊艳。但很多人跟我说 Cursor 和以前非常不一样了，强大了很多，被多次洗脑后，我决定尝试在新项目中使用 Cursor。</p><img src="/images/post/2024/09/cursor-strong.jpeg" class="" width="500" height="300"><h3 id="第一天的编码"><a href="#第一天的编码" class="headerlink" title="第一天的编码"></a>第一天的编码</h3><p>在使用 Cursor 之前，我看过一些关于 Cursor 的介绍，其中它的一个功能让我印象深刻，就是它在回答我们问题时可以基于整个代码库的代码来回答，而不是像 Copilot 那样只能基于当前文件的代码来回答。于是我使用 Cursor 开发新项目的第一件事，就是让它帮我介绍这个项目，然后它开始扫描项目的每个文件，给我了下面的回答：</p><img src="/images/post/2024/09/cursor-chat-with-codebase.png" class="" width="1000" height="600"><p>这使我我了解到项目的基本信息：</p><ul><li>项目分为客户端和服务端，都是用 Go 语言开发的</li><li>服务端使用了 <a href="https://github.com/gin-gonic/gin">Gin</a> 开发框架，数据库使用的是 <a href="https://www.postgresql.org/">PostgresSQL</a></li><li>客户端使用了 <a href="https://github.com/spf13/cobra">Cobra</a> 库，用于命令行工具的开发</li></ul><img src="/images/post/2024/09/cursor-wow.png" class="" width="600" height="400"><p>了解了项目的基本情况后，我开始尝试开发一个删除用户的小功能，首先我找到要修改的文件，然后在我要修改的地方按了一下回车，接着神奇地发现 Cursor 已经帮我补全了方法签名，并且 Cursor 知道这是我要添加的功能，然后我再按下 Tab 键，方法的实现代码就出现了，而且是根据项目的代码风格来的，这让我非常惊讶。</p><img src="/images/post/2024/09/cursor-code-complete.png" class="" width="1000" height="600"><p>我怀疑是我在修改代码之前查看了其他关于删除用户的代码，或者是在检索代码片段时使用了一些关键字，让 Cursor 知道了我要添加的功能是什么。</p><p>当然，你不可能所有事情都依赖 Cursor，在修改代码之前，你需要了解项目的基本结构、需要改动哪些文件、需求的业务逻辑等，然后再让 Cursor 帮你补全代码。当代码补全后，我们需要对代码进行检查，看看是否是我们想要的功能，如果有错误，我们需要对代码进行手动修改。</p><p>于是我就用这种方式开始了我的 Go 语言开发之旅，找到修改代码的位置，然后让 Cursor 帮我补全代码，然后我再对代码进行检查，如果有问题则修改，没有问题则进行测试，一直重复这个过程，直到功能开发完成为止。</p><p>这种方式能让我快速地使用 Go 语言开发功能，而且能够快速的学习 Go 语言，在开发过程中，如果对以前的代码或者生成的代码不清楚，我就随时和 Cursor 进行对话，让它帮我解答问题。</p><img src="/images/post/2024/09/cursor-perfect.jpg" class="" width="600" height="400"><h3 id="短暂的快乐"><a href="#短暂的快乐" class="headerlink" title="短暂的快乐"></a>短暂的快乐</h3><p>愉快的时光总是短暂的，在我的频繁使用下很快就超过了 Cursor 的免费限制，当 Cursor 提示我无法再进行代码补全时，我开始考虑是否要充值。因为 Cursor 的价格整整是 Copilot 的 2 倍（Copilot 是 10 美元一个月，而 Cursor 是 20 美元一个月），而且我前段时间刚购买了一年的 Copilot，我真的需要两个 AI 代码编辑器吗？</p><img src="/images/post/2024/09/cursor-choice.png" class="" width="400" height="600"><p>经过反复权衡和艰难抉择，我还是决定充值一个月的 Cursor 试试，因为短暂的使用让我感觉到了 Cursor 的强大，我相信它能帮我更快地完成这个项目。同时我也有点后悔购买了一年的 Copilot，应该按月购买，这样可以灵活更换到其他服务，虽然这样会贵一点，但至少不会浪费。</p><p>如果让我重新选择的话，我会选择 Cursor，因为 Copilot 有的功能 Cursor 都有，而 Cursor 有的功能 Copilot 并没有，而且在整体使用体验上，我更喜欢 Cursor。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>到目前为止，我已经使用了 Cursor 2 个星期了，项目进度进展顺利，Go 语言的基础也掌握的差不多了，现在我已经能独立开发一个完整且比较复杂的前后端功能。在这个过程中，我之所以能够快速掌握 Go 语言，我想有这么几个原因：</p><ul><li>我有过其他语言开发经验，这样阅读 Go 语言的代码并不会觉得特别困难</li><li>项目之前的代码写的比较清晰规范，让人阅读起来比较容易</li><li>Cursor 真的给我很大的帮助，不管是代码补全还是 AI 问答，都能让我快速地学习</li></ul><img src="/images/post/2024/09/cursor-happy-end.jpg" class="" width="600" height="400"><hr><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><p>这里介绍一下我在使用 Cursor 这段时间的一些心得和体会，因为我之前也使用过 Copilot，所以我会和 Copilot 进行一些对比。</p><h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p>Cursor 给我第一个直观的感受就是<strong>快</strong>，在代码补全方面基本上是秒出结果，而我在使用 Copilot 时，经常看到右下角的 Copilot 图标在转圈，需要让我等待。我认为速度是代码编辑器的一个关键因素，因为在编码过程中，我们希望工具能够高效响应，避免任何卡顿或延迟，以保持开发效率。</p><h3 id="兼容-VSCode"><a href="#兼容-VSCode" class="headerlink" title="兼容 VSCode"></a>兼容 VSCode</h3><p>Cursor 兼容 <a href="https://code.visualstudio.com/">VSCode</a>，可以导入 VSCode 的所有配置信息，包括快捷键设置、代码模板、插件等，因为我之前主要使用 VSCode 进行开发，所以 Cursor 能让我无缝切换到它上面。</p><h3 id="每个项目有单独的对话历史"><a href="#每个项目有单独的对话历史" class="headerlink" title="每个项目有单独的对话历史"></a>每个项目有单独的对话历史</h3><p>在 Cursor 中与 AI 进行对话后，Cursor 会保存每一次对话记录，这样你可以随时查看之前的对话记录，而且这些对话记录是按照项目来保存的，这样不会将不同的项目的对话记录混在一起，非常方便。后面我看了一下 Copilot，发现 Copilot 也有这个功能，但我之前并没有发现。</p><h3 id="代码补全在中间也可以补全"><a href="#代码补全在中间也可以补全" class="headerlink" title="代码补全在中间也可以补全"></a>代码补全在中间也可以补全</h3><p>在 Cursor 中，代码补全不仅可以在代码的末尾补全，还可以在代码的中间补全，而这一点 Copolit 就无能为力了，后者只能在代码的末尾补全。</p><img src="/images/post/2024/09/cursor-middle-complete.png" class="" width="1000" height="600"><h3 id="可以设置系统提示词"><a href="#可以设置系统提示词" class="headerlink" title="可以设置系统提示词"></a>可以设置系统提示词</h3><p>Cursor 可以设置 AI 问答的系统提示词，比如像我们母语为中文的开发人员，我们可以让 AI 都用中文来回答问题，而这一点 Copilot 也是不支持的。</p><img src="/images/post/2024/09/cursor-rule.png" class="" width="1000" height="600"><h3 id="随时随地和-AI-聊天"><a href="#随时随地和-AI-聊天" class="headerlink" title="随时随地和 AI 聊天"></a>随时随地和 AI 聊天</h3><p>Cursor 可以随时随地和 AI 进行对话，不管你是否有在编码，它主要通过以下几种方式进行对话：</p><ul><li>使用快捷键 CMD + L 随时开启对话（同样的快捷键也可以关闭对话），如果选中代码再按快捷键，选中的代码会作为问题的上下文</li><li>使用快捷键 CMD + SHIFT + L 可以将选中的代码追加到当前对话中，并进行提问</li><li>如果代码有报错或者警告信息，将鼠标移动到代码处，Cursor 会提示咨询 AI，这样可以将报错或警告信息作为问题的上下文，然后进行提问</li></ul><img src="/images/post/2024/09/cursor-fix-chat.png" class="" width="1000" height="600"><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>在 VSCode 中有代码重构的功能，但操作起来比较复杂，而 Cursor 利用代码补全功能，可以很方便地进行重构。比如重命名一个变量，只需要简单的改名字，然后一路按 Tab 键就可以了，如果在补全过程中发现代码格式不对，按 Tab 键时还可以自动格式化代码。</p><img src="/images/post/2024/09/cursor-refactor.png" class="" width="1000" height="600"><hr><h2 id="并非无所不能"><a href="#并非无所不能" class="headerlink" title="并非无所不能"></a>并非无所不能</h2><p>Cursor 并非无所不能，也有很多东西它是做不到的。之前我尝试了一个比较复杂的问题，我将前端项目和后端项目一起放到 Cursor 中，然后在 AI 问答中上传了前端页面的图，<strong>咨询 AI 图中的某个按钮对应的后端 API 代码在哪个文件</strong>，基于整个代码库的方式进行提问。</p><p>结果给 Cursor 不仅找不到对应的后端文件，还编造了一些后端文件。然后我降低了问题的难度，只让 Cursor 找出图片中按钮的前端代码，同样地，Cursor 也没有找到对应的前端文件，还是编造了一些前端文件。</p><p>从目前情况看，Cursor 可能在<strong>图片解析方面还有问题，或者在大而复杂的问题上不够聪明</strong>，并不能像人类一样理解问题的意图，但我相信随着 AI 技术的发展，这些问题都会逐渐解决。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>未来的编程趋势将显著受到 AI 技术的影响，随着 AI 技术的快速发展，越来越多的编程工具开始集成智能代码生成能力。AI 生成代码不仅能够加快开发速度，还能帮助开发者减少重复性劳动，使他们能够将更多时间投入到创新和复杂问题的解决中。但 AI 生成的代码可能存在逻辑错误、安全漏洞或不符合项目特定需求的问题，因此开发者需要对 AI 生成的代码进行仔细的审查和测试，确保其质量和可靠性。所以以后的编码过程可能是<strong>代码完全由 AI 生成，人类对生成的代码进行审查</strong>，然后让 AI 不断按照人类的要求进行修改，直到生成最终的代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我分享了我在使用 Cursor 开发新项目时的一些心得和体会，我认为 Cursor 是一个非常强大的 AI 代码编辑器，它可以帮助开发者快速地学习新技术和开发新项目，提高开发效率。虽然 Cursor 也有一些不足之处，但我相信随着 AI 技术的发展，这些问题都会逐渐解决。我希望未来的编程工具能够更加智能，让开发者能够更加高效地进行编程工作。</p><p>关注我，一起学习各种人工智能和 GenAI 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍在使用 Cursor 开发新项目时的一些心得和体会</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/tags/ai/"/>
    
    <category term="cursor" scheme="https://zhaozhiming.github.io/tags/cursor/"/>
    
    <category term="go-lang" scheme="https://zhaozhiming.github.io/tags/go-lang/"/>
    
  </entry>
  
  <entry>
    <title>一步一步发布公司的 NPM 包</title>
    <link href="https://zhaozhiming.github.io/2024/09/15/publish-company-npm-package-guide/"/>
    <id>https://zhaozhiming.github.io/2024/09/15/publish-company-npm-package-guide/</id>
    <published>2024-09-15T07:18:54.000Z</published>
    <updated>2024-10-03T08:49:29.889Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/09/publish-company-npm.jpeg" class="" width="400" height="300"><p>在项目开发中，有时候需要将自研的 NPM 包会发布到 NPM 的<a href="https://registry.npmjs.org/">公共注册表</a>让别人进行使用，NPM 的公共注册表是一个全球性的包管理库，任何用户都可以访问和下载你发布的公开包。如果你发布的是个人的 NPM 包，那么直接发布就可以了，但是如果你发布的是公司的 NPM 包，那么就需要通过一些流程和规范，来和公司其他同事进行协同合作。本文将为你介绍如何从零开始一步一步发布公司的 NPM 包，如果你的公司现在或以后也有这种需求，那么请跟我一起来学习吧。</p><span id="more"></span><h2 id="什么是-NPM"><a href="#什么是-NPM" class="headerlink" title="什么是 NPM"></a>什么是 NPM</h2><p>NPM 是 Node Package Manager 的缩写，它是一个针对 NPM 编程语言的包管理工具。它是随 Node.js 一起安装的，用于管理和分享 NPM 代码包（modules）。NPM 允许开发者轻松下载、安装、更新、删除各种开源的 NPM 包，并且可以轻松管理项目中的依赖关系。</p><h2 id="人员角色"><a href="#人员角色" class="headerlink" title="人员角色"></a>人员角色</h2><p>在发布公司 NPM 包的过程中，有以下人员或角色，他们主要负责以下工作：</p><ul><li>管理员：负责管理公司 NPM 组织，添加和删除 NPM 组织成员，处理 NPM 包发布权限申请等，可能会有多个管理员。</li><li>开发人员: 指公司内部所有的开发人员，负责开发公司的 NPM 包，发布公司的 NPM 包到 NPM 包管理库。</li></ul><img src="/images/post/2024/09/npm-flow.png" class="" width="1000" height="600"><h2 id="创建公司邮箱群组"><a href="#创建公司邮箱群组" class="headerlink" title="创建公司邮箱群组"></a>创建公司邮箱群组</h2><p>发布 NPM 包需要 NPM 账号，而注册 NPM 账号需要邮箱，如果是发布个人 NPM 包的话直接使用个人邮箱注册就可以了，但是如果是发布公司的 NPM 包，那么要注册 NPM 账号的邮箱就不能是个人邮箱，而应该是一个公司邮箱群组。邮箱群组是一个包含多个员工电子邮箱地址的统一地址，用于向所有成员同时发送邮件。</p><p>使用邮箱群组是出于多方面的考虑，一方面是安全，注册 NPM 账号的邮箱主要是用来接收 NPM 的通知邮件，比如发布 NPM 包成功后的通知。假设有人用公司的名义发了一个恶意的 NPM 包，那么公司的邮箱群组会收到 NPM 的通知邮件，这样公司的管理员们可以及时发现问题，如果是个人邮箱的话，那么就只有个人知道，这样就会增加安全风险。</p><p>另一方面单点问题，设想一下，如果是个人邮箱管理公司的 NPM 包，那么如果这个人离职了，那么这个人的邮箱就作废了，从而导致 NPM 上的组织也作废了，公司需要重新使用新邮箱注册 NPM 账号，重新在 NPM 上面创建组织。而最麻烦的是，以前的 NPM 包公司已经无法管理了，无法再对老的 NPM 包进行升级或者删除。</p><p>所以建议公司在注册 NPM 账号时，使用公司邮箱群组来注册，这样可以避免上述问题。邮箱群组的名字建议叫 <code>npm@公司域名</code>，比如 <code>npm@your-company.com</code>，这样可以清晰的表明这个邮箱群组是用来注册 NPM 账号的。</p><h2 id="管理员创建-NPM-账号与组织"><a href="#管理员创建-NPM-账号与组织" class="headerlink" title="管理员创建 NPM 账号与组织"></a>管理员创建 NPM 账号与组织</h2><p>有了邮箱群组后，管理员首先到 <a href="https://www.npmjs.com/">NPM 网站</a>上创建一个账号，NPM 账号创建可以<a href="https://docs.npmjs.com/creating-a-new-npm-user-account">参考 NPM 的官方文档</a>进行创建。</p><p>创建完 NPM 账号后，管理员需要创建一个 NPM 组织，NPM 组织是一个用于管理公司 NPM 包的组织，公司内部的所有 NPM 包都会发布到这个组织下。NPM 组织的创建可以<a href="https://docs.npmjs.com/creating-an-organization">参考 NPM 的官方文档</a>进行创建。</p><h2 id="开启双因子认证"><a href="#开启双因子认证" class="headerlink" title="开启双因子认证"></a>开启双因子认证</h2><p>对于公司的 NPM 账号，安全性是非常重要的，谁也不想看到有天公司的 NPM 包被别人恶意篡改了。为了增加账号的安全性，建议开启<a href="https://docs.npmjs.com/about-two-factor-authentication">双因子认证</a>。</p><blockquote><p>双因子认证（Two-Factor Authentication，简称 2FA）是一种增强账户安全性的验证方法，通过要求用户在登录或进行敏感操作时提供两种不同类型的认证因素，从而确保用户身份的真实性。与仅依赖单一密码相比，双因子认证显著提高了账户的安全性，减少了未经授权访问的风险。</p></blockquote><p>NPM 上的双因子认证可以通过安全密钥或 TOTP（Time-based One-time Password）来实现。</p><ul><li>安全密钥允许使用生物识别设备（ 比如苹果的 <a href="https://support.apple.com/en-gb/HT204587">Touch ID</a>）进行认证</li><li>TOTP 需要在移动设备上安装认证应用程序（比如 <a href="https://support.google.com/accounts/answer/1066447">Google Authenticator</a>） 来生成验证码</li></ul><h3 id="多管理员设置双因子认证"><a href="#多管理员设置双因子认证" class="headerlink" title="多管理员设置双因子认证"></a>多管理员设置双因子认证</h3><p>对于多管理员的 NPM 账号来说，使用 TOTP 不太方便，因为每个管理员都需要在自己的手机上安装认证应用程序，这样就会增加管理的复杂度。所以建议使用安全密钥的方式来开启双因子认证。</p><p><strong>首个</strong>管理员开启双因子认证后，需要创建<strong>恢复码</strong>，然后将恢复码分享给<strong>其他</strong>管理员，其他管理员<strong>首次登录</strong>可以使用恢复码来登录 NPM 网站，然后设置自己的安全密钥。</p><p>在账号的<code>Profile</code> -&gt; <code>Account</code> -&gt; <code>Two-factor authentication</code> 页面可以设置安全密钥和恢复码。</p><img src="/images/post/2024/09/npm-2fa.png" class="" width="1000" height="600"><p><strong>注意</strong>：NPM 每次可以生成 5 个恢复码，这些恢复码通常用于在无法进行双因子认证时登录账户。一旦您使用某个恢复码成功登录，系统将自动使该恢复码<strong>无效</strong>以防止重复使用。所以当其他管理员使用了恢复码登录后，建议尽快生成新的恢复码，并告知其他管理员。</p><img src="/images/post/2024/09/npm-recover-code.png" class="" width="1000" height="600"><p>其他管理员使用恢复码登录后，可以设置自己的安全密钥，比如使用 Apple Touch ID 作为安全密钥，这样在下次登录时就可以直接使用 Touch ID 而不需要输入恢复码了。</p><h2 id="邀请组织成员"><a href="#邀请组织成员" class="headerlink" title="邀请组织成员"></a>邀请组织成员</h2><p>创建好组织后，就可以邀请开发人员加入组织了，邀请流程如下：</p><ul><li>进入用户设置页面，选择组织名称，比如<code>your-organization</code></li><li>选择<code>成员</code>标签，然后点击<code>邀请成员</code></li><li>输入开发人员的邮箱并点击<code>邀请</code>按钮，NPM 将向开发人员发送一封邮件</li><li>开发人员点击邮件中的链接后，将加入 NPM 组织</li></ul><img src="/images/post/2024/09/npm-invite-member.png" class="" width="1000" height="600"><h2 id="开发人员注册账号"><a href="#开发人员注册账号" class="headerlink" title="开发人员注册账号"></a>开发人员注册账号</h2><p>开发人员也需要到 NPM 网站上创建一个账号，发布 NPM 包需要使用账号进行发布，有以下注意事项：</p><ul><li>建议使用公司邮箱进行注册</li><li>创建账号完成后，开启双因子认证</li></ul><h2 id="发布权限申请"><a href="#发布权限申请" class="headerlink" title="发布权限申请"></a>发布权限申请</h2><p>创建完 NPM 账号后，开发人员需要申请公司 NPM 包发布权限，否则无法发布公司的 NPM 包，申请流程为：</p><ul><li>找管理员将开发人员的 NPM 账号添加到公司的 NPM 组织</li><li>开发人员需要提供 NPM 账号名或注册邮箱给管理员</li><li>管理员邀请开发人员的 NPM 账号到公司的 NPM 组织后，开发人员的邮箱会收到一封邀请邮件</li><li>开发人员点击邮件中的链接后，将加入 NPM 组织</li></ul><p>这样开发人员就拥有了发布公司 NPM 包的权限。</p><img src="/images/post/2024/09/npm-join-org.png" class="" width="1000" height="600"><h2 id="发布-NPM-包"><a href="#发布-NPM-包" class="headerlink" title="发布 NPM 包"></a>发布 NPM 包</h2><p>开发人员申请了公司 NPM 包发布权限后，就可以发布公司的 NPM 包了。</p><h3 id="修改包名"><a href="#修改包名" class="headerlink" title="修改包名"></a>修改包名</h3><p>首先需要修改 NPM 包名称，公司的 NPM 包将以公司组织名称开头，比如 <code>@your-organization</code>。修改你项目中的 <code>package.json</code> 文件，将其中的 <code>name</code> 加上公司的 NPM 组织名称，假设你原来的 NPM 包名为 <code>foo</code>，那么修改后的内容如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@you-organization/foo&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用-NPM-CLI-登录"><a href="#使用-NPM-CLI-登录" class="headerlink" title="使用 NPM CLI 登录"></a>使用 NPM CLI 登录</h3><p>再使用 NPM 命令行工具在终端进行登录，在终端执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>命令执行后，会提示你按回车键打开浏览器链接，打开浏览器后会进入到 NPM 网站。如果你没有在 NPM 网站上登录，会提示输入用户名和密码进行登录。如果你设置了双因子认证，网页会提示你输入安全密钥或验证码。</p><img src="/images/post/2024/09/npm-cli-login.png" class="" width="1000" height="600"><p>完成以上操作后终端会提示你登录成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm login</span><br><span class="line">npm notice Log <span class="keyword">in</span> on https://registry.npmjs.org/</span><br><span class="line">Login at:</span><br><span class="line">https://www.npmjs.com/login?next=/login/cli/14939f9b-26fa-48df-ad2a-f4ac972897f9</span><br><span class="line">Press ENTER to open <span class="keyword">in</span> the browser...</span><br><span class="line"></span><br><span class="line">Logged <span class="keyword">in</span> on https://registry.npmjs.org/.</span><br></pre></td></tr></table></figure><h3 id="执行发布命令"><a href="#执行发布命令" class="headerlink" title="执行发布命令"></a>执行发布命令</h3><p>在终端登录了 NPM 账号后，执行以下命令进行 NPM 包发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：发布命令加上 <code>--access public</code> 参数，表示将 NPM 包发布到 NPM 的<strong>公开</strong>包管理库。如果不添加该参数的话，NPM 会默认将你的包发布到 NPM 的<strong>私有</strong>包管理库，这种类型的包管理库是 NPM 的收费服务，如果公司没有购买这种服务，那么发布到私有包管理库会导致发布失败。</p><p>开发人员也可以在 <code>pacakge.json</code> 文件中添加以下内容，然后直接通过 <code>npm publish</code> 命令进行发布，这种方法也会发布到 NPM 公开包管理库。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;publishConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;public&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>执行了发布命令后，跟登录命令一样，会提示你进入 NPM 网站进行双因子认证，认证成功后将发布 NPM 包到 NPM 的公开包管理库。</p><p>发布成功后可以在 NPM 官网的公司组织下查看包是否上传成功，以 <code>next</code> 组织为例，可以在浏览器地址 <code>https://www.npmjs.com/org/next</code> 上查看该组织的 NPM 包信息。</p><img src="/images/post/2024/09/npm-org-packages.png" class="" width="1000" height="600"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了发布公司 NPM 包的一系列流程和建议，包括作为管理员或者普通开发人员需要执行的一些操作，以及在安全方面需要注意的一些事项。此流程不仅适用于 NPM 包，也适用于其他包管理工具，比如 PIP 或者 Maven 等。如果你也正在发布公司的 NPM 包，那么希望这篇文章对你有所帮助。</p><p>关注我，一起学习各种人工智能和 GenAI 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍管理员如何管理公司的 NPM 账号，以及指导开发人员如何发布公司的 NPM 包</summary>
    
    
    
    <category term="code" scheme="https://zhaozhiming.github.io/categories/code/"/>
    
    
    <category term="javascript" scheme="https://zhaozhiming.github.io/tags/javascript/"/>
    
    <category term="npm" scheme="https://zhaozhiming.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之查询路由</title>
    <link href="https://zhaozhiming.github.io/2024/08/06/rag-query-router/"/>
    <id>https://zhaozhiming.github.io/2024/08/06/rag-query-router/</id>
    <published>2024-08-06T01:10:16.000Z</published>
    <updated>2024-10-03T08:49:29.889Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/08/rag-query-router.jpg" class="" width="400" height="300"><p>之前介绍 Self-RAG 的时候提到了其中的按需检索功能，就是根据用户的问题来判断是否需要进行文档检索，如果不需要检索的话则直接返回 LLM（大语言模型）生成的结果，这样不仅可以提升系统的性能，还可以提高用户的体验。在 Self-RAG 中按需检索是通过特殊训练后的 LLM 来实现的，但是在高级 RAG（Retrieval Augmented Generation）检索中我们可以使用<strong>查询路由</strong>来实现这个功能，借助查询路由我们可以轻松实现类似代码中的 If&#x2F;Else 功能。今天我们就来介绍查询路由的原理以及实现方式，并通过代码示例来了解查询路由在实际项目中的使用。</p><span id="more"></span><h2 id="查询路由"><a href="#查询路由" class="headerlink" title="查询路由"></a>查询路由</h2><p>查询路由是 RAG 中的一种智能查询分发功能，能够根据用户输入的语义内容，从多个选项中选择最合适的处理方式或数据源。查询路由能够显著提高 RAG 检索的相关性和效率，适用于各种复杂的信息检索场景，如将用户查询分发到不同的知识库。查询路由的灵活性和智能性使其成为构建高效 RAG 系统的关键组件。</p><img src="/images/post/2024/08/rag-router-flow.png" class="" width="1000" height="600"><h3 id="查询路由的类型"><a href="#查询路由的类型" class="headerlink" title="查询路由的类型"></a>查询路由的类型</h3><p>根据查询路由的实现原理我们可以将其分为两种类型：</p><ul><li>LLM Router：通过构建有效的提示词来让 LLM 判断用户问题的意图，现有的实现有 LlamaIndex Router 等。</li><li>Embedding Router: 通过 Embedding 模型将用户问题转为向量，然后通过相似性检索来判断用户问题的意图，现有的实现有 Semantic Router 等。</li></ul><p>下面我们就来了解这两种查询路由具体的实现原理。</p><h2 id="LLM-Router"><a href="#LLM-Router" class="headerlink" title="LLM Router"></a>LLM Router</h2><p>使用 LLM 来判断用户的意图目前是 RAG 中一种常见的路由方法，首先在提示词中列出问题的所有类别，然后让 LLM 将问题进行分类，最后根据分类结果来选择相应的处理方式。</p><p>LLM 应用框架 <a href="https://www.llamaindex.ai/">LlamaIndex</a> 使用的就是 LLM Router。在 LlamaIndex 中有几种查询路由的实现，比如路由检索器 <code>RouterRetriever</code>、路由查询引擎 <code>RouterQueryEngine</code>、流水线路由模块 <code>RouterComponent</code>，它们的实现原理基本一致，初始化时需要一个选择器和一个工具组件列表，通过选择器来得到工具组件序号，然后根据序号来选择相应的工具组件，最后执行工具组件的处理逻辑。以 <code>RouterQueryEngine</code> 为例，其示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> RouterQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.core.selectors <span class="keyword">import</span> LLMSingleSelector</span><br><span class="line"><span class="keyword">from</span> llama_index.core.tools <span class="keyword">import</span> QueryEngineTool</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize tools</span></span><br><span class="line">list_tool = QueryEngineTool.from_defaults(</span><br><span class="line">    query_engine=list_query_engine,</span><br><span class="line">    description=<span class="string">&quot;Useful for summarization questions related to the data source&quot;</span>,</span><br><span class="line">)</span><br><span class="line">vector_tool = QueryEngineTool.from_defaults(</span><br><span class="line">    query_engine=vector_query_engine,</span><br><span class="line">    description=<span class="string">&quot;Useful for retrieving specific context related to the data source&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize router query engine (single selection, llm)</span></span><br><span class="line">query_engine = RouterQueryEngine(</span><br><span class="line">    selector=LLMSingleSelector.from_defaults(),</span><br><span class="line">    query_engine_tools=[</span><br><span class="line">        list_tool,</span><br><span class="line">        vector_tool,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line">query_engine.query(<span class="string">&quot;&lt;query&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>首先我们构建 2 个工具 <code>list_tool</code> 和 <code>vector_tool</code>，分别用于总结问题和向量查询，<code>list_tool</code>使用 <code>SummaryIndex</code>来构建检索引擎，<code>vector_tool</code>使用 <code>VectorStoreIndex</code> 来构建检索引擎</li><li>然后初始化 <code>RouterQueryEngine</code>，传入选择器和工具列表</li><li>这里的选择器是 <code>LLMSingleSelector</code>，该选择器使用 LLM 判断用户问题意图并返回单个选择结果</li><li>最后调用 <code>query_engine.query</code> 方法传入用户问题，<code>RouterQueryEngine</code> 根据问题选择相应的工具并执行</li></ul><p>下面是 LlamaIndex Router 的流程图：</p><img src="/images/post/2024/08/llamaindex-router-flow.png" class="" width="400" height="600"><ul><li>首先选择器根据用户问题得到选择结果</li><li>对选择结果进行数据提取，得到工具组件序号</li><li>根据序号选择工具列表中的组件并执行</li></ul><p>在 LlamaIndex 中选择器有 4 种，如下图所示：</p><img src="/images/post/2024/08/llamaindex-selector.png" class="" width="1000" height="600"><p>这 4 种选择器都是通过 LLM 来判断用户问题的意图，按选择结果可以分为单个结果选择器和多个结果选择器，单个结果选择器只返回一个选择结果，多个结果选择器返回多个选择结果，然后会将多个结果合并为一个最终结果。</p><p>按解析结果可以分为文本结果选择器和对象结果选择器，文本结果选择器使用的是 LLM 的 completion API 来生成文本类型的选择结果，格式为：<code>&lt;index&gt;. &lt;reason&gt;</code>，<code>index</code>为选择结果的序号，<code>reason</code>为选择结果的原因。对象结果选择器使用的是 LLM 的 Function Calling API，将选择结果解析成一个 Python 对象，默认的对象为 <code>SingleSelection</code>，其定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleSelection</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A single selection of a choice.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    index: <span class="built_in">int</span></span><br><span class="line">    reason: <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>2 种解析结果示例如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Text selector</span></span><br><span class="line">2. Useful <span class="keyword">for</span> questions related to oranges</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object selector</span></span><br><span class="line">SingleSelection(index=2, reason=<span class="string">&quot;Useful for questions related to oranges&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用文本结果选择器得到选择结果后，还需要进行额外处理，比如提取出结果中的序号，而使用对象结果选择器则不需要额外处理，可以直接使用对象的属性得到结果。</p><p>我们再来看下选择器的提示词模板：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_SINGLE_SELECT_PROMPT_TMPL = (</span><br><span class="line">    <span class="string">&quot;Some choices are given below. It is provided in a numbered list &quot;</span></span><br><span class="line">    <span class="string">&quot;(1 to &#123;num_choices&#125;), &quot;</span></span><br><span class="line">    <span class="string">&quot;where each item in the list corresponds to a summary.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;context_list&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;\n---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Using only the choices above and not prior knowledge, return &quot;</span></span><br><span class="line">    <span class="string">&quot;the choice that is most relevant to the question: &#x27;&#123;query_str&#125;&#x27;\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>这是 <code>LLMSingleSelector</code> 的默认提示词模板</li><li><code>&#123;num_choices&#125;</code> 为选择结果的数量</li><li><code>&#123;context_list&#125;</code> 为工具组件列表的文本描述，包括序号和描述</li><li><code>&#123;query_str&#125;</code> 为用户问题</li></ul><p>使用 LLM Router 的一个关键就是构建有效的提示词，如果使用的 LLM 足够强大，那么提示词不用很清晰也能达到我们想要的效果，但如果 LLM 不够强大，那么提示词需要不断调整才能得到满意的结果。笔者在使用 LlamaIndex Router 的过程中发现，在选择 OpenAI <code>gpt-3.5-turbo</code> 模型的情况下，使用 <code>LLMSingleSelector</code> 选择器时偶尔会出现解析失败的情况，而使用 <code>PydanticSingleSelector</code> 选择器则比较稳定。</p><p>最后得到选择结果的序号后就可以通过该序号来选择工具组件了，下面是 <code>RouterQueryEngine</code> 的代码片段：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RouterQueryEngine</span>(<span class="title class_ inherited__">BaseQueryEngine</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_query</span>(<span class="params">self, query_bundle: QueryBundle</span>) -&gt; RESPONSE_TYPE:</span><br><span class="line">        ......</span><br><span class="line">        result = <span class="variable language_">self</span>._selector.select(<span class="variable language_">self</span>._metadatas, query_bundle)</span><br><span class="line">        selected_query_engine = <span class="variable language_">self</span>._query_engines[result.ind]</span><br><span class="line">        final_response = selected_query_engine.query(query_bundle)</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><ul><li><code>RouterQueryEngine</code> 的 <code>_query</code> 方法中首先通过选择器得到选择结果</li><li>然后根据选择结果的序号在 <code>_query_engines</code> 中选择相应的检索引擎</li><li>最后调用检索引擎的 <code>query</code> 方法生成最终结果</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：方法简单，易于实现</li><li>缺点：需要一个比较强大的 LLM 才能正确判断用户问题的意图，如果要将选择结果解析为对象还需要 LLM 具备 Function Calling 的能力</li></ul><h2 id="Embedding-Router"><a href="#Embedding-Router" class="headerlink" title="Embedding Router"></a>Embedding Router</h2><p>查询路由的另外一种实现方式是使用 Embedding 模型将用户问题进行向量化，然后通过向量相似性来将用户问题进行分类，得到分类结果后再选择相应的处理方式。</p><p><a href="https://github.com/aurelio-labs/semantic-router">Semantic Router</a> 是基于该原理实现的一个路由工具，它旨在提供超快的 AI 决策能力，通过语义向量进行快速决策，以提高 LLM 应用和 AI Agent 的效率。 Semantic Router 使用非常简单，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> semantic_router <span class="keyword">import</span> Route</span><br><span class="line"><span class="keyword">from</span> semantic_router.encoders <span class="keyword">import</span> CohereEncoder, OpenAIEncoder</span><br><span class="line"><span class="keyword">from</span> semantic_router.layer <span class="keyword">import</span> RouteLayer</span><br><span class="line"></span><br><span class="line"><span class="comment"># we could use this as a guide for our chatbot to avoid political conversations</span></span><br><span class="line">politics = Route(</span><br><span class="line">    name=<span class="string">&quot;politics&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;isn&#x27;t politics the best thing ever&quot;</span>,</span><br><span class="line">        <span class="string">&quot;why don&#x27;t you tell me about your political opinions&quot;</span>,</span><br><span class="line">        <span class="string">&quot;don&#x27;t you just love the president&quot;</span>,</span><br><span class="line">        <span class="string">&quot;they&#x27;re going to destroy this country!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;they will save the country!&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this could be used as an indicator to our chatbot to switch to a more</span></span><br><span class="line"><span class="comment"># conversational prompt</span></span><br><span class="line">chitchat = Route(</span><br><span class="line">    name=<span class="string">&quot;chitchat&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;how&#x27;s the weather today?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;how are things going?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lovely weather today&quot;</span>,</span><br><span class="line">        <span class="string">&quot;the weather is horrendous&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let&#x27;s go to the chippy&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we place both of our decisions together into single list</span></span><br><span class="line">routes = [politics, chitchat]</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenAI Encoder</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&quot;&lt;YOUR_API_KEY&gt;&quot;</span></span><br><span class="line">encoder = OpenAIEncoder()</span><br><span class="line"></span><br><span class="line">rl = RouteLayer(encoder=encoder, routes=routes)</span><br><span class="line"></span><br><span class="line">rl(<span class="string">&quot;don&#x27;t you love politics?&quot;</span>).name</span><br><span class="line"><span class="comment"># politics</span></span><br><span class="line">rl(<span class="string">&quot;how&#x27;s the weather today?&quot;</span>).name</span><br><span class="line"><span class="comment"># chitchat</span></span><br></pre></td></tr></table></figure><ul><li>首先定义 2 个 Route，分别是 <code>politics</code> 和 <code>chitchat</code>，每个 Route 包含多个示例语句</li><li>然后创建一个 Encoder，这里使用的是 OpenAI 的 Encoder，利用 OpenAI 的 Embedding 模型来生成向量</li><li>最后创建一个 RouteLayer，传入 Encoder 和 Route 列表</li><li>调用 RouteLayer 方法传入用户问题，得到分类结果，<strong>注意</strong>：并不是每一个用户问题都会得到一个预设的分类结果，如果用户问题不在预设的分类中，那么分类结果可能为空</li></ul><p>OpenAI Encoder 默认使用的是 <code>text-embedding-3-small</code> Embedding 模型，它比 OpenAI 之前的 <code>text-embedding-ada-002</code> Embedding 模型效果更好且价格更便宜。同时 Semantic Router 还支持其他 Encoder，比如 Huggingface Encoder，它默认使用的是 <a href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2">sentence-transformers&#x2F;all-MiniLM-L6-v2</a> Embedding 模型，这是一个句子转换模型，它将句子和段落映射到一个 384 维度的向量空间，可用于分类或语义搜索等任务。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：只需要使用 Embedding 模型，相比 LLM Router 效率更高，消耗资源更少</li><li>缺点：需要提前录入一些示例语句，如果示例语句不够多或者不够全面，分类效果可能不太好</li></ul><h2 id="查询路由实践"><a href="#查询路由实践" class="headerlink" title="查询路由实践"></a>查询路由实践</h2><p>下面我们结合 LlamaIndex 和 Semantic Router 来实现一个查询路由，该路由会将用户的问题分发到不同的工具组件中，这些工具组件包括：使用 LLM 和用户进行闲聊，使用 RAG 流程检索文档并生成答案，以及使用 Bing 搜索引擎进行网络搜索。</p><img src="/images/post/2024/08/rag-router-practice.png" class="" width="1000" height="600"><p>首先我们定义一个与 LLM 闲聊的工具组件，这里我们使用 LlamaIndex 的 <a href="https://docs.llamaindex.ai/en/stable/examples/pipeline/query_pipeline/">Pipeline</a> 功能来构建一个查询流水线，更多的查询流水线功能可以参考我之前的<a href="https://zhaozhiming.github.io/2024/06/08/rag-module-pipeline/">这篇文章</a>，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.llms.openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> QueryPipeline, InputComponent</span><br><span class="line"></span><br><span class="line">llm = OpenAI(model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>, system_prompt=<span class="string">&quot;You are a helpful assistant.&quot;</span>)</span><br><span class="line">chitchat_p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">chitchat_p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;llm&quot;</span>: llm,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">chitchat_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;llm&quot;</span>)</span><br><span class="line">output = chitchat_p.run(<span class="built_in">input</span>=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Output: <span class="subst">&#123;output&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Output: assistant: Hello! How can I assist you today?</span><br></pre></td></tr></table></figure><ul><li>这里我们使用 OpenAI 的 <code>gpt-3.5-turbo</code> 模型来构建一个 LLM</li><li>然后使用 <code>QueryPipeline</code> 来构建一个查询流水线，添加 <code>input</code> 和 <code>llm</code> 两个模块，<code>input</code>模块是一个输入组件，默认输入参数键名称为 <code>input</code></li><li>接着添加两个模块的连接关系</li><li>最后调用 <code>run</code> 方法传入用户问题，得到回答</li></ul><p>然后我们再添加一个普通 RAG 的工具组件，同样是创建一个查询流水线，这里的测试文档还是用维基百科上的<a href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SimpleDirectoryReader, VectorStoreIndex</span><br><span class="line"><span class="keyword">from</span> llama_index.core.response_synthesizers.tree_summarize <span class="keyword">import</span> TreeSummarize</span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">retriever = index.as_retriever(similarity_top_k=<span class="number">2</span>)</span><br><span class="line">rag_p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">rag_p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;retriever&quot;</span>: retriever,</span><br><span class="line">        <span class="string">&quot;output&quot;</span>: TreeSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rag_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;retriever&quot;</span>)</span><br><span class="line">rag_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;query_str&quot;</span>)</span><br><span class="line">rag_p.add_link(<span class="string">&quot;retriever&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;nodes&quot;</span>)</span><br><span class="line">output = rag_p.run(<span class="built_in">input</span>=<span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Output: <span class="subst">&#123;output&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Output: Tony Stark <span class="keyword">and</span> Bruce Banner.</span><br></pre></td></tr></table></figure><ul><li>前面部分是 LlamaIndex 常用的检索器构建流程，使用 <code>SimpleDirectoryReader</code> 来加载测试文档，然后使用 <code>VectorStoreIndex</code> 来构建一个检索器</li><li>创建一个查询流水线，添加 <code>input</code>、<code>retriever</code> 和 <code>output</code> 三个模块，<code>output</code> 模块是一个树形总结组件</li><li>添加三个模块的连接关系，<code>output</code>模块需要使用到 <code>input</code> 模块和 <code>retirever</code> 模块的输出结果</li><li>最后调用 <code>run</code> 方法传入用户问题，得到回答</li></ul><p>接下来我们再添加一个使用 Bing 搜索引擎的工具组件，同样我们使用查询流水线来进行创建，但这一次需要用到自定义模块，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">web_p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">web_p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;web_search&quot;</span>: WebSearchComponent(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">web_p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;web_search&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>网络搜索工具比较简单，只有 2 个模块，<code>input</code> 和 <code>web_search</code></li><li>其中的 <code>WebSearchComponent</code> 是一个自定义模块，下面我们会详细介绍这个模块的实现</li></ul><p>在实现这个自定义模块之前，我们需要先在 Azure 上创建一个 Bing 搜索服务，然后获取 API Key，具体操作可以参考微软的<a href="https://learn.microsoft.com/en-us/bing/search-apis/bing-web-search/overview">官方文档</a>。然后安装 LlamaIndex 的 Bing 查询工具库：<code>pip install llama-index-tools-bing-search</code>，然后就可以开始实现自定义模块了，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Any</span></span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> CustomQueryComponent</span><br><span class="line"><span class="keyword">from</span> llama_index.tools.bing_search <span class="keyword">import</span> BingSearchToolSpec</span><br><span class="line"><span class="keyword">from</span> llama_index.agent.openai <span class="keyword">import</span> OpenAIAgent</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSearchComponent</span>(<span class="title class_ inherited__">CustomQueryComponent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Web search component.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate_component_inputs</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate component inputs during run_component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;input&quot;</span> <span class="keyword">in</span> <span class="built_in">input</span>, <span class="string">&quot;input is required&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_input_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Input keys dict.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;input&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_output_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run_component</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the component.&quot;&quot;&quot;</span></span><br><span class="line">        tool_spec = BingSearchToolSpec(api_key=os.getenv(<span class="string">&quot;BING_SEARCH_API_KEY&quot;</span>))</span><br><span class="line">        agent = OpenAIAgent.from_tools(tool_spec.to_tool_list())</span><br><span class="line">        question = kwargs[<span class="string">&quot;input&quot;</span>]</span><br><span class="line">        result = agent.chat(question)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>: result&#125;</span><br></pre></td></tr></table></figure><ul><li>我们直接看自定义组件中的核心方法 <code>_run_component</code></li><li>首先我们创建一个 <code>BingSearchToolSpec</code> 对象，传入 Bing 搜索引擎的 API Key，这里我们将 API Key 保存到环境变量 <code>BING_SEARCH_API_KEY</code> 中</li><li>这里我们使用了 LlamaIndex 的 Agent 功能，我们使用 <code>OpenAIAgent</code> 对象并传入 Bing 搜索工具</li><li>最后通过 <code>kwargs[&quot;input&quot;]</code> 获取用户问题并传递给 <code>agent.chat</code> 方法，得到搜索结果并返回</li><li>Bing 查询工具更多的用法可以参考<a href="https://llamahub.ai/l/tools/llama-index-tools-bing-search?from=">其文档</a></li></ul><p>3 个工具组件创建之后，我们需要创建一个路由模块，我们使用 Semantic Router 来实现这个路由模块，我们先定义 Semantic Router 的几个 Route，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">chitchat = Route(</span><br><span class="line">    name=<span class="string">&quot;chitchat&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;how&#x27;s the weather today?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;how are things going?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lovely weather today&quot;</span>,</span><br><span class="line">        <span class="string">&quot;the weather is horrendous&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let&#x27;s go to the chippy&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rag = Route(</span><br><span class="line">    name=<span class="string">&quot;rag&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;What mysterious object did Loki use in his attempt to conquer Earth?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;How did Thanos achieve his plan of exterminating half of all life in the universe?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;What method did the Avengers use to reverse Thanos&#x27; actions?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Which member of the Avengers sacrificed themselves to defeat Thanos?&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">web = Route(</span><br><span class="line">    name=<span class="string">&quot;web&quot;</span>,</span><br><span class="line">    utterances=[</span><br><span class="line">        <span class="string">&quot;Search online for the top three countries in the 2024 Paris Olympics medal table.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Find the latest news about the U.S. presidential election.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Look up the current updates on NVIDIA’s stock performance today.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Search for what Musk said on X last month.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Find the latest AI news.&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>这里我们定义了 3 个 Route，分别针对 3 种不同的问题类型</li><li><code>chitchat</code> Route 的示例语句是一些闲聊语句，对应 <code>chitchat</code> 工具组件</li><li><code>rag</code> Route 的示例语句是一些关于复仇者联盟电影剧情的问题，对应 <code>rag</code> 工具组件</li><li><code>web</code> Route 的示例语句是一些关于网络搜索的问题， 其中有不少 <code>Search</code>、<code>Find</code> 等关键词，对应 <code>web</code> 工具组件</li></ul><p>接下来我们创建一个自定义的路由模块，使用 Semantic Router 来实现查询路由，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.base.query_pipeline.query <span class="keyword">import</span> (</span><br><span class="line">    QueryComponent,</span><br><span class="line">    QUERY_COMPONENT_TYPE,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> llama_index.core.bridge.pydantic <span class="keyword">import</span> Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemanticRouterComponent</span>(<span class="title class_ inherited__">CustomQueryComponent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Semantic router component.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    components: <span class="type">Dict</span>[<span class="built_in">str</span>, QueryComponent] = Field(</span><br><span class="line">        ..., description=<span class="string">&quot;Components (must correspond to choices)&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, components: <span class="type">Dict</span>[<span class="built_in">str</span>, QUERY_COMPONENT_TYPE]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Init.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(components=components)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate_component_inputs</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate component inputs during run_component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_input_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Input keys dict.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;input&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_output_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>, <span class="string">&quot;selection&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run_component</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.components) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No components&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> chitchat.name <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.components.keys():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No chitchat component&quot;</span>)</span><br><span class="line"></span><br><span class="line">        routes = [chitchat, rag, web]</span><br><span class="line">        encoder = OpenAIEncoder()</span><br><span class="line">        rl = RouteLayer(encoder=encoder, routes=routes)</span><br><span class="line">        question = kwargs[<span class="string">&quot;input&quot;</span>]</span><br><span class="line">        selection = rl(question).name</span><br><span class="line">        <span class="keyword">if</span> selection <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = <span class="variable language_">self</span>.components[selection].run_component(<span class="built_in">input</span>=question)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output = <span class="variable language_">self</span>.components[<span class="string">&quot;chitchat&quot;</span>].run_component(<span class="built_in">input</span>=question)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>: output, <span class="string">&quot;selection&quot;</span>: selection&#125;</span><br></pre></td></tr></table></figure><ul><li>在自定义模块的构造器函数 <code>__init__</code> 中我们传入了一个字典，字典的键是 Route 的名称，值是对应的工具组件</li><li>在 <code>_output_keys</code> 方法中我们返回了 2 个输出键，一个是输出结果，一个是选择结果</li><li>在 <code>_run_component</code> 方法中我们首先对工具组件参数进行验证，确保有 <code>chitchat</code> 这个工具组件，因为我们需要将无法分类的问题分发到 <code>chitchat</code> 工具组件</li><li>然后我们使用 Semantic Router 来判断用户问题的意图，得到选择结果 <code>selection</code></li><li>再根据选择结果来选择相应的工具组件并执行</li><li>如果选择结果为空，则选择 <code>chitchat</code> 工具组件并执行</li><li>最后返回输出结果和选择结果</li></ul><p>最后我们将所有的工具组件和路由模块添加到一个单独的查询流水线中，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;router&quot;</span>: SemanticRouterComponent(</span><br><span class="line">            components=&#123;</span><br><span class="line">                <span class="string">&quot;chitchat&quot;</span>: chitchat_p,</span><br><span class="line">                <span class="string">&quot;rag&quot;</span>: rag_p,</span><br><span class="line">                <span class="string">&quot;web&quot;</span>: web_p,</span><br><span class="line">            &#125;</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>新建的查询流水线只有一个模块 <code>router</code>，这个模块是我们自定义的路由模块 <code>SemanticRouterComponent</code></li><li>在路由模块中我们传入了 3 个之前定义的查询流水线，表示不同的用户意图执行不同的查询流水线</li><li>因为只有一个模块，所以无需添加连接关系</li></ul><p>下面我们来执行一下这个流水线，看看效果如何：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output = p.run(<span class="built_in">input</span>=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># Selection: chitchat</span></span><br><span class="line"><span class="comment"># Output: assistant: Hello! How can I assist you today?</span></span><br><span class="line"></span><br><span class="line">output = p.run(<span class="built_in">input</span>=<span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>)</span><br><span class="line"><span class="comment"># Selection: rag</span></span><br><span class="line"><span class="comment"># Output: Tony Stark and Bruce Banner.</span></span><br><span class="line"></span><br><span class="line">output = p.run(<span class="built_in">input</span>=<span class="string">&quot;Search online for the top three countries in the 2024 Paris Olympics medal table.&quot;</span>)</span><br><span class="line"><span class="comment"># Selection: web</span></span><br><span class="line"><span class="comment"># Output: The top three countries in the latest medal table for the 2024 Paris Olympics are as follows:</span></span><br><span class="line"><span class="comment"># 1. United States</span></span><br><span class="line"><span class="comment"># 2. China</span></span><br><span class="line"><span class="comment"># 3. Great Britain</span></span><br></pre></td></tr></table></figure><p>可以看到我们的查询路由工作的很好，根据用户问题的不同意图选择了不同的工具组件，并得到了相应的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们介绍了 RAG 检索策略中的查询路由，并介绍了 LLM Router 和 Embedding Router 两种查询路由的实现原理，最后通过一个实战项目了解了查询路由在实际项目中的使用。但目前的查询路由还有很多不确定性，因此我们无法保证查询路由总能做出完全准确的决策，需要经过精心测试才能得到更加可靠的 RAG 应用程序。</p><p>关注我，一起学习各种人工智能和 GenAI 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><ul><li><a href="https://medium.com/towards-data-science/routing-in-rag-driven-applications-a685460a7220">Routing in RAG-Driven Applications</a></li></ul>]]></content>
    
    
    <summary type="html">介绍 RAG 检索策略中的查询路由，以及如何在检索时使用</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="router" scheme="https://zhaozhiming.github.io/tags/router/"/>
    
    <category term="semantic-router" scheme="https://zhaozhiming.github.io/tags/semantic-router/"/>
    
  </entry>
  
  <entry>
    <title>都 2024 年了，你还在用 pip 吗？</title>
    <link href="https://zhaozhiming.github.io/2024/07/15/modern-python-project-tools-config/"/>
    <id>https://zhaozhiming.github.io/2024/07/15/modern-python-project-tools-config/</id>
    <published>2024-07-15T02:49:25.000Z</published>
    <updated>2024-10-03T08:49:29.889Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/07/next-generation-python-tools.jpg" class="" width="400" height="300"><p>编程语言 Python 随着 AI 的发展越来越受开发人员的喜爱，目前已经是最流行的编程语言，但由于 Python 是一门相对较老的语言，并且经过 Python2 到 Python3 这一漫长而复杂的迁移历程，使得一些 Python 开发人员可能还在使用一些过时的工具和库。今天我们就来带大家了解当前 Python 生态系统中最流行最实用的开发工具，让你彻底告别那些<code>老古董</code>。</p><span id="more"></span><h2 id="Python-环境管理工具"><a href="#Python-环境管理工具" class="headerlink" title="Python 环境管理工具"></a>Python 环境管理工具</h2><p>Python 项目中虚拟环境的管理非常重要，虚拟环境可以帮助我们在不同项目中使用不同的 Python 版本和依赖库，避免不同项目之间的依赖冲突。Python 最早使用的是 <code>virtualenv</code> 工具来管理虚拟环境，到了 Python3.3 后自带了内置的创建虚拟环境模块 <code>venv</code>，但它们都存在一个问题，就是只能使用同一个 Python 版本创建虚拟环境。假如你在 A 项目想使用 Python3.10，而在 B 项目想使用 Python3.9，那么你就需要安装两个不同版本的 Python，然后分别使用 <code>virtualenv</code> 或 <code>venv</code> 来创建虚拟环境。</p><p>在使用了一些 Python 环境管理工具后，我比较推荐 <a href="https://docs.anaconda.com/miniconda/">Miniconda</a> 这个工具，它是一个轻量级的 Conda 版本，可以帮助我们管理 Python 环境和依赖库，但我一般不使用它来管理依赖库，主要使用它来管理 Python 环境。</p><p>虽然 Miniconda 与其他 Python 环境管理工具（比如 <a href="https://github.com/pyenv/pyenv">pyenv</a>）相比会重量级一些（包含了一些数据科学相关的库），而且功能也不是很纯粹（即有环境管理也有依赖管理等功能）， 但是它的优势在于环境管理的功能非常出色，可以轻松地在不同操作系统上进行安装，同时适配 bash、fish、zsh 等不同的 shell 环境，而且跟 <code>virtualenv</code> 和 <code>venv</code> 一起使用也不会引起冲突。</p><h3 id="Miniconda-使用示例"><a href="#Miniconda-使用示例" class="headerlink" title="Miniconda 使用示例"></a>Miniconda 使用示例</h3><p>以下是 Miniconda 的一些常用命令：</p><ul><li>创建 Python 环境： <code>conda create -n myenv python=3.10</code></li><li>切换 Python 环境： <code>conda activate myenv</code></li><li>展示所有 Python 环境： <code>conda env list</code></li><li>初始化 shell 环境： <code>conda init &lt;bash/fish/zsh&gt;</code></li></ul><h2 id="Python-依赖管理工具"><a href="#Python-依赖管理工具" class="headerlink" title="Python 依赖管理工具"></a>Python 依赖管理工具</h2><p>Python 项目中最常使用的工具应该要属 Pip 了，Pip 是 Python 的依赖管理工具，用于安装和管理 Python 依赖，虽然 Pip 功能强大，但在管理项目依赖时存在一些问题，比如新增依赖时需要手动修改 <code>requirements.txt</code> 文件，而且没有版本锁定功能，导致在不同环境中安装的依赖版本可能不一致。</p><p>其他编程语言比如 JS 则能有效地处理这种情况，使用它的依赖管理工具 <code>npm</code> 会产生一个 <code>package.json</code> 文件来管理项目依赖，然后生成一个 <code>package-lock.json</code> 文件来锁定依赖版本，确保在不同环境中安装相同的依赖版本。</p><p>为了解决这一问题，在 Python 中出现了不少依赖管理工具，<a href="https://python-poetry.org/">Poetry</a> 是其中一个比较流行的工具。Poetry 使用一个 <code>pyproject.toml</code> 文件来管理项目的所有依赖项和元数据，使项目配置更加简洁明了，它会自动处理依赖项的版本冲突，并且能够生成锁文件 <code>poetry.lock</code>，确保在不同环境中安装相同的依赖版本。</p><h3 id="Poetry-安装"><a href="#Poetry-安装" class="headerlink" title="Poetry 安装"></a>Poetry 安装</h3><p>Poetry 有多种安装方式，最简单的是通过 Python 脚本进行安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://install.python-poetry.org | python3 -</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过 Miniconda 创建一个特定版本的 Python 环境，然后在这个环境中使用 Poetry，具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 conda 创建一个 Python 环境</span></span><br><span class="line">conda create -n myenv python=3.10</span><br><span class="line"><span class="comment"># 切换到这个 Python 环境</span></span><br><span class="line">conda activate myenv</span><br><span class="line"><span class="comment"># 构建一个 Poetry 虚拟环境</span></span><br><span class="line">poetry <span class="built_in">env</span> use python</span><br><span class="line"><span class="comment"># 进入该环境</span></span><br><span class="line">poetry shell</span><br></pre></td></tr></table></figure><h3 id="Poetry-使用示例"><a href="#Poetry-使用示例" class="headerlink" title="Poetry 使用示例"></a>Poetry 使用示例</h3><p>在新项目中使用 Poetry 可以使用 <code>poetry new &lt;project_name&gt;</code> 来创建一个新的 Python 项目，如果是已有项目，可以在项目目录中使用 <code>poetry init</code> 命令来初始化项目，这两个命令都会生成一个 <code>pyproject.toml</code> 文件，用于管理项目的依赖项和元数据。</p><p>你可以使用 <code>poetry install</code> 来安装项目的所有依赖，如果是初次运行该命令，Poetry 会生成一个 <code>poetry.lock</code> 文件，用于锁定项目的依赖版本，确保在不同环境中安装相同的依赖版本。也可以使用 <code>poetry add &lt;package_name&gt;</code> 命令来单独添加一个依赖，这样 Poetry 会自动更新 <code>pyproject.toml</code> 和 <code>poetry.lock</code> 文件。</p><p>我们通过一个简单的例子来看下 Poetry 对依赖管理的方法，假设我们在项目中安装了一个新的依赖 <code>requests</code>，那么可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add requests</span><br></pre></td></tr></table></figure><p>安装完成后，在 <code>pyproject.toml</code> 文件中只会添加 <code>requests</code> 这个依赖的信息：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">requests</span> = <span class="string">&quot;^2.32.3&quot;</span></span><br></pre></td></tr></table></figure><p>但是在 <code>poetry.lock</code> 文件会中除了添加 <code>requests</code> 这个依赖外，还会添加 <code>requests</code> 这个依赖所需的其他依赖库的信息，可以使用以下命令查看依赖之间的关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ poetry show --tree</span><br><span class="line">requests 2.32.3 Python HTTP <span class="keyword">for</span> Humans.</span><br><span class="line">├── certifi &gt;=2017.4.17</span><br><span class="line">├── charset-normalizer &gt;=2,&lt;4</span><br><span class="line">├── idna &gt;=2.5,&lt;4</span><br><span class="line">└── urllib3 &gt;=1.21.1,&lt;3</span><br></pre></td></tr></table></figure><p>可以看到 <code>requests</code> 是项目根目录下的依赖，而其他几个依赖是 <code>requests</code> 所需的依赖。</p><p>如果你用 Pip 来安装依赖，那么 <code>pip install requests</code> 后再用 <code>pip freeze &gt; requirements.txt</code> 命令生成的 <code>requirements.txt</code> 文件会包含所有依赖的信息，使得你分不清哪些是项目的依赖，哪些是衍生的依赖。</p><p>Poetry 还允许你将 lock 文件导出成 <code>requirements.txt</code> 文件，这样你就可以使用 <code>pip install -r requirements.txt</code> 来安装项目的依赖，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">export</span> --without-hashes --format=requirements.txt --output requirements.txt</span><br></pre></td></tr></table></figure><p>更多的 Poetry 使用方法可以参<a href="https://python-poetry.org/docs/">考官方文档</a>。</p><h3 id="其他依赖管理工具"><a href="#其他依赖管理工具" class="headerlink" title="其他依赖管理工具"></a>其他依赖管理工具</h3><p>除了 Poetry 外，还有一些其他的 Python 依赖管理工具，比如 <a href="https://pdm-project.org/en/latest/">Pdm</a> 就是不错的选择，它整体和 Poetry 类似，它还包含了 Python 环境管理的功能，这样就不需要和 Miniconda 配合也可直接使用，但是在流行度上比 Poetry 稍微逊色一些（截止时间 2024 年 7 月，Poetry 的 Github Star 数是 30K，而 Pdm 的 Github Star 数是 7.6K），可能是 Pdm 比 Poetry 发布时间晚的关系（Poetry 是 2018 年发布的，而 Pdm 是 2020 年发布的），后面如果 Pdm 发展的好的话，说不定会超过 Poetry。</p><p>另外一个值得推荐的 Python 依赖管理工具是 <a href="https://github.com/astral-sh/uv">Uv</a>，它是一款用 Rust 编写的极速 Python 包安装和解析工具，旨在作为 Pip 和 Pip-tools 的替代品，并逐步发展成为一个全面的 Python 项目和包管理器，下面是它和其他工具安装依赖的速度对比图：</p><img src="/images/post/2024/07/uv-compare.png" class="" width="1000" height="600"><p>得益于 Rust 的高性能，在速度上 Uv 完全碾压了其他工具，但可惜的是 Uv 目前还是使用 <code>requirements.txt</code> 来管理依赖，这样就无法保证可以在不同环境安装相同的依赖，而且 Uv 也不能和 Poetry 一起使用，因为 Uv 是按照兼容 Pip 的思路进行开发，而 Poetry 内部已经不用 Pip 做依赖管理了。</p><p>尽管 Uv 无法和 Poetry 一起使用，但是我们可以在 CI&#x2F;CD 中使用 Uv 来加速依赖安装，比如我们先用 Poetry 导出 <code>requirements.txt</code> 文件，然后在 CI&#x2F;CD 中使用 Uv 来安装依赖，这样就可以大大缩短依赖安装的时间。</p><h3 id="Pip-是否过时"><a href="#Pip-是否过时" class="headerlink" title="Pip 是否过时"></a>Pip 是否过时</h3><p>虽然这些依赖管理工具很强大，但一些小型项目可能更多开发人员还是会选择 Pip，因为 Pip 无需额外安装其他工具，一般有 Python 环境就可以直接使用。另外一点是编程语言的原生工具也在不断发展，以 JS 为例，npm 刚开始时也不支持 lock 文件，但后面参考了一些 JS 的流行工具，在社区的共同努力下慢慢完善了这个功能，所以 Pip 也有可能在未来的某个版本中加入类似 Poetry 的功能。</p><p>所以在 Pip 没有发展完善之前，我们可以使用 Poetry 这样的工具来解决依赖管理的问题，同时也能简化项目配置，提高开发效率。</p><h2 id="代码规范工具"><a href="#代码规范工具" class="headerlink" title="代码规范工具"></a>代码规范工具</h2><p>另外一种常用的工具是代码规范类工具，因为 Python 的语法比较灵活，所以在团队协作中可能会出现代码风格不一致的问题，为了解决这个问题，每种编程语言都会有一些代码规范工具，这类工具包括代码格式化工具、代码检查工具等。</p><p>在 Python 中代码格式化工具有 <a href="https://github.com/psf/black">Black</a>、<a href="https://github.com/google/yapf">YAPF</a>、<a href="https://github.com/hhatto/autopep8">autopep8</a> 等，而代码检查工具有 <a href="https://github.com/PyCQA/flake8">Flake8</a>、<a href="https://github.com/pylint-dev/pylint">Pylint</a>、<a href="https://github.com/python/mypy">mypy</a> 等，这些工具都可以通过 Pip 来安装，然后在项目中使用。</p><p>而最近比较流行的一个代码规范工具 <a href="https://github.com/astral-sh/ruff">Ruff</a>，它同时集成了代码格式化和代码检查功能，可以帮助我们更好地在项目中统一代码风格。Ruff 是 Uv 开发团队开发的另外一款工具，同样是使用 Rust 语言进行编写，从而使它的性能远远高于其他同类型的工具，下面是 Ruff 和其他工具的性能对比图：</p><img src="/images/post/2024/07/ruff-compare.png" class="" width="1000" height="600"><p>Ruff 内部集成了 Black 和 Flake8 等工具，下面我们就来介绍下 Ruff 如何安装及使用。</p><h3 id="Ruff-安装"><a href="#Ruff-安装" class="headerlink" title="Ruff 安装"></a>Ruff 安装</h3><p>Ruff 可以通过 Pip 或 Poetry 进行安装，在项目中使用的话，推荐使用 Poetry 安装到 dev 开发依赖中，表示这个工具只在开发环境中使用，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add --dev ruff</span><br></pre></td></tr></table></figure><p>如果想让 Ruff 在本地 IDE 中使用的话，建议是进行全局安装，这样就可以在任何项目中使用 Ruff，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/ruff/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过 IDE 的插件来使用 Ruff，比如在 VSCode 中安装 <a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">Ruff 插件</a>，然后在 VSCode 中使用快捷键 <code>Ctrl+Shift+P</code> 打开命令面板，输入 <code>user config</code> 打开用户配置文件，然后添加 Ruff 安装后的路径：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ruff.path&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/your/ruff/path&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Ruff-使用示例"><a href="#Ruff-使用示例" class="headerlink" title="Ruff 使用示例"></a>Ruff 使用示例</h3><p>Ruff 主要有 2 个命令，分别是 <code>ruff check</code> 和 <code>ruff format</code>，前者用于代码检查，后者用于代码格式化。</p><p>为了保证团队的代码风格一致，我们可以在 Git 的 hook 中添加 Ruff 检查命令，这样每个人在执行 <code>git commit</code> 命令时就会自动执行 Ruff 命令，如果检查失败则无法提交代码。</p><p>首先我们需要安装 <a href="https://pre-commit.com/">pre-commit</a> 工具，这个工具可以让我们在 Git hook 上轻松配置命令，同样将其安装到 dev 开发依赖即可：<code>poetry add --dev pre-commit</code>，然后在项目根目录下添加 <code>.pre-commit-config.yaml</code> 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">    <span class="comment"># Ruff 版本</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.5.1</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="comment"># 执行 ruff check</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line">        <span class="comment"># 可选参数，自动修复代码</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">--fix</span>]</span><br><span class="line">      <span class="comment"># 执行 ruff format</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff-format</span></span><br></pre></td></tr></table></figure><ul><li>在文件中我们添加 Ruff 工具来处理代码提交时的检查</li><li>我们添加了 2 个工具，第一个工具 id 是 <code>ruff</code> 表示执行 <code>ruff check</code> 命令，第二个工具 id 是 <code>ruff-format</code> 表示执行 <code>ruff format</code> 命令</li><li>第一个工具还有一个可选参数 <code>args: [--fix]</code>，表示会自动修复检查出有误的代码，但也不是所有代码都能自动修复，有些代码还是需要手动修复的</li></ul><p>最后我们在项目中执行 <code>pre-commit install</code> 命令，将文件内容添加到 Git hook 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pre-commit install</span><br><span class="line">pre-commit installed at .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p>配置完成后，我们故意写一些代码错误，然后提交代码， 检查结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;add some feature&#x27;</span></span><br><span class="line">ruff.....................................................................Failed</span><br><span class="line">- hook <span class="built_in">id</span>: ruff</span><br><span class="line">- <span class="built_in">exit</span> code: 1</span><br><span class="line"></span><br><span class="line">main.py:1:8: F401 [*] `requests` imported but unused</span><br><span class="line">  |</span><br><span class="line">1 | import requests</span><br><span class="line">  |        ^^^^^^^^ F401</span><br><span class="line">  |</span><br><span class="line">  = <span class="built_in">help</span>: Remove unused import: `requests`</span><br><span class="line"></span><br><span class="line">Found 1 error.</span><br><span class="line">[*] 1 fixable with the `--fix` option.</span><br><span class="line"></span><br><span class="line">ruff-format..............................................................Passed</span><br></pre></td></tr></table></figure><p>可以看到代码检查任务失败了，报了 <code>imported but unused</code> 的错误，错误编号 <code>F401</code>，第二个任务代码格式化检查通过。</p><p>如果想在代码中不检查某行代码，可以在代码行后面加上 <code># noqa: &#123;error_code&#125;</code>，比如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="comment"># noqa: F401</span></span><br></pre></td></tr></table></figure><p>这样就可以在 Ruff 检查时忽略这个错误。更多的 Ruff 使用方法可以参<a href="https://docs.astral.sh/ruff/tutorial/">考官方文档</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们介绍了 Python 中新一代的项目工具，新工具带来的好处是开发效率的提升，因为每个新工具都是在解决旧工具的不足之处，是在旧工具的基础上进行了优化和改进。作为一个热衷提高生产力的开发人员，可以在适当时机尝试使用这些新工具，如果觉得新工具不合适，也可以退回去重新使用旧工具，关键在于尝试。</p><p>关注我，一起学习各种人工智能和 GenAI 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍新一代 Python 项目常用工具，以及如何在项目中使用</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="python" scheme="https://zhaozhiming.github.io/tags/python/"/>
    
    <category term="miniconda" scheme="https://zhaozhiming.github.io/tags/miniconda/"/>
    
    <category term="poetry" scheme="https://zhaozhiming.github.io/tags/poetry/"/>
    
    <category term="ruff" scheme="https://zhaozhiming.github.io/tags/ruff/"/>
    
    <category term="uv" scheme="https://zhaozhiming.github.io/tags/uv/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之知识图谱</title>
    <link href="https://zhaozhiming.github.io/2024/07/04/rag-knowledge-graphs/"/>
    <id>https://zhaozhiming.github.io/2024/07/04/rag-knowledge-graphs/</id>
    <published>2024-07-04T14:12:57.000Z</published>
    <updated>2024-10-03T08:49:29.888Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/07/rag-knowledge-graph.jpg" class="" width="400" height="300"><p>RAG（Retrieval Augmented Generation）技术中检索是一个非常重要的环节，检索的准确性直接影响到生成的质量，但普通 RAG 的向量检索技术并不能满足所有场景下的需求，比如在一些大型私有文档库中，传统的检索技术往往表现不好。目前已经有很多研究团队在 RAG 中引入知识图谱来提高检索的准确性，并且取得了很好的效果。今天我们就来了解一下知识图谱的原理，以及如何在 RAG 中进行使用。</p><span id="more"></span><h2 id="什么是知识图谱"><a href="#什么是知识图谱" class="headerlink" title="什么是知识图谱"></a>什么是知识图谱</h2><p>知识图谱是一种利用图结构来表示和建模现实世界中实体及其关系的技术方法。它将信息以节点（实体）和边（关系）的形式组织成一个有机的网络，从而实现对复杂知识的高效存储、查询和分析。知识图谱的核心在于通过三元组形式（实体-关系-实体）来描述事物之间的关联，这种结构化的数据表示方法不仅能够捕捉数据的语义含义，还能便于理解和分析。</p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>知识图谱在 RAG 中的使用流程图如下所示：</p><img src="/images/post/2024/07/graph-rag-flow.png" class="" width="1000" height="600"><p>在数据入库过程中，文档经过分块后，知识图谱 RAG 会将文档块进行实体和关系的提取，提取出实体和关系后，通常是将它们保存到图数据库中。</p><p>在检索过程中，知识图谱 RAG 会将问题进行实体提取，将提取出来的实体通过图数据库进行检索，获取相关的实体和关系，检索结果往往是一个庞大的实体关系网络，最后将检索到的实体和关系结合问题提交给 LLM（大语言模型）进行答案生成。</p><p>有些知识图谱 RAG 的实现也会结合图检索和向量检索两种方式，这样可以综合利用图检索和向量检索的优势，提高检索的准确性和效率。</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>在 RAG 中使用知识图谱主要解决在大型文档库上问答和理解困难的问题，特别是那些普通 RAG 方法难以处理的全局性问题。普通 RAG 在回答针对整个文档库的全局性问题时表现不佳，例如问题：<code>请告诉我所有关于 XXX 的事情</code>，这个问题涉及到的上下文可能分布在整个大型文档库中，普通 RAG 的向量检索方法很难得到这种分散、细粒度的文档信息，向量检索经常使用 top-k 算法来获取最相近的上下文文档，这种方式很容易遗漏关联的文档块，从而导致信息检索不完整。</p><p>另外是 LLM 的上下文窗口限制问题，对于全局性问题往往涉及到非常多的上下文文档，如果要全部提交给 LLM 则很容易超出 LLM 的窗口限制，而知识图谱将文档提取成实体关系后再提交给 LLM，实际上大大压缩了文档块的大小，从而让所有相关文档提交给 LLM 成为可能。</p><h3 id="与普通-RAG-的区别"><a href="#与普通-RAG-的区别" class="headerlink" title="与普通 RAG 的区别"></a>与普通 RAG 的区别</h3><ul><li>知识图谱 RAG 使用图结构来表示和存储信息，捕捉实体间的复杂关系，而普通 RAG 通常使用向量化的文本数据</li><li>知识图谱 RAG 通过图遍历和子图检索来获取相关信息，普通 RAG 主要依赖向量相似度搜索</li><li>知识图谱 RAG 能更好地理解实体间的关系和层次结构，提供更丰富的上下文，普通 RAG 在处理复杂关系时能力有限</li></ul><h2 id="数据入库"><a href="#数据入库" class="headerlink" title="数据入库"></a>数据入库</h2><p>下面我们来看下知识图谱 RAG 具体的数据入库流程，普通 RAG 在文档分块后，通常是使用 Embedding 模型将文档块进行向量化，然后将向量和文档保存到向量数据库。与普通 RAG 不同，知识图谱 RAG 在入库过程中会将文档块进行实体和关系的提取，提取出实体和关系后再将它们保存到图数据库中。</p><img src="/images/post/2024/07/graph-rag-index-flow.png" class="" width="1000" height="600"><p>实体提取的传统方法是基于预定义的规则和词典、统计机器学习或者深度学习等技术，但进入到 LLM 时代后，实体提取更多的是使用 LLM 来进行，因为 LLM 能够更好地理解文本的语义，实现也更加简单。</p><p>比如在 <a href="https://www.llamaindex.ai/">LlamaIndex</a> 的 <code>KnowledgeGraphIndex</code> 类中的实体提取提示词是这样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_KG_TRIPLET_EXTRACT_TMPL = (</span><br><span class="line">    <span class="string">&quot;Some text is provided below. Given the text, extract up to &quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;max_knowledge_triplets&#125; &quot;</span></span><br><span class="line">    <span class="string">&quot;knowledge triplets in the form of (subject, predicate, object). Avoid stopwords.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Example:&quot;</span></span><br><span class="line">    <span class="string">&quot;Text: Alice is Bob&#x27;s mother.&quot;</span></span><br><span class="line">    <span class="string">&quot;Triplets:\n(Alice, is mother of, Bob)\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Text: Philz is a coffee shop founded in Berkeley in 1982.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Triplets:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(Philz, is, coffee shop)\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(Philz, founded in, Berkeley)\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(Philz, founded in, 1982)\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Text: &#123;text&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Triplets:\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在提示词中要求 LLM 将文档块 <code>text</code> 提取成<code>实体-关系-实体</code>这样的三元组，实体一般是名词，表示文档块中的实体，关系是动词或者介词，表示实体之间的关系，并给出了几个 Few Shot，让 LLM 能更好地理解实体抽取的任务。</p><p>将实体提取出来后，通常是将实体和关系保存到图数据库中，但也有一些知识图谱 RAG 的实现会将这些数据保存到文件中，然后通过其特有的算法来进行检索，比如微软的 <a href="https://microsoft.github.io/graphrag/">GraphRAG</a>。</p><p>图数据库是一种专门用来存储图结构数据的数据库，它能够高效地存储和查询图数据，常见的图数据库有 Neo4j、ArangoDB 等。不同的图数据库有不同的查询语言，比如 Neo4j 的查询语言使用的是 Cypher，如果想要在 RAG 中使用 Neo4j 来存储知识图谱数据，那么掌握一些基础的 Cypher 语法是有必要的。</p><h2 id="检索生成"><a href="#检索生成" class="headerlink" title="检索生成"></a>检索生成</h2><p>了解了知识图谱 RAG 的数据入库流程之后，我们再来看下它的检索生成过程。普通 RAG 在检索过程中通常是将问题进行向量化，然后通过向量相似度搜索来获取最相近的几个文档块，然后将这些文档块提交给 LLM 进行答案生成。而知识图谱 RAG 在检索过程中会将问题进行实体提取，将提取出来的实体通过图数据库进行检索，这样可以获取到名称相同的实体，以及与实体相关的实体和关系，最后将检索到的所有实体和关系提交给 LLM 进行答案生成。</p><img src="/images/post/2024/07/graph-rag-retrieve-flow.png" class="" width="1000" height="600"><p>对问题进行实体提取与数据入库时的实体提取方法类似，也是通过 LLM 来进行，但只需要提取出问题中的实体即可，不需要提取三元组，可以看下 LlamaIndex 的 <code>KGTableRetriever</code> 类中提取问题关键字的提示词：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_QUERY_KEYWORD_EXTRACT_TEMPLATE_TMPL = (</span><br><span class="line">    <span class="string">&quot;A question is provided below. Given the question, extract up to &#123;max_keywords&#125; &quot;</span></span><br><span class="line">    <span class="string">&quot;keywords from the text. Focus on extracting the keywords that we can use &quot;</span></span><br><span class="line">    <span class="string">&quot;to best lookup answers to the question. Avoid stopwords.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;question&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Provide keywords in the following comma-separated format: &#x27;KEYWORDS: &lt;keywords&gt;&#x27;\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>提示词要求 LLM 从问题中提取出多个关键字，并用逗号分隔，这些关键字通常是问题中的实体。将问题的实体提取出来后，再用实体名称去图数据库中进行检索， 检索的原理就是使用图数据库的查询语句对每个实体进行检索，获取对应的三元组。以 Neo4j 图数据库为例，下面是一个简单的 Cypher 查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n &#123;name: &#x27;Alice&#x27;&#125;)-[r]-(m)</span><br><span class="line">RETURN n, r, m</span><br></pre></td></tr></table></figure><p>这个查询语句的意思是查找图数据库中所有与实体 Alice 相关的实体和关系，这样就可以获取到 Alice 相关的所有三元组。最后将得到的数据转换为文本，作为问题的上下文，提交给 LLM 进行答案生成。</p><h2 id="LlamaIndex-知识图谱-RAG-实现"><a href="#LlamaIndex-知识图谱-RAG-实现" class="headerlink" title="LlamaIndex 知识图谱 RAG 实现"></a>LlamaIndex 知识图谱 RAG 实现</h2><p>​了解完知识图谱 RAG 的原理后，接下来我们来看下如何在实际项目中使用知识图谱 RAG ，在 LlamaIndex 框架中已经实现了知识图谱的功能，使用 LlamaIndex 和 Neo4j 可以快速地实现知识图谱 RAG。</p><h3 id="Neo4j-安装"><a href="#Neo4j-安装" class="headerlink" title="Neo4j 安装"></a>Neo4j 安装</h3><p>Neo4j 是一个高性能的图形数据库，它将结构化数据存储在网络（从数学角度称为图）上而不是传统的表中，这种设计使得 Neo4j 在处理复杂的关系和连接时具有显著的优势。Neo4j 使用 Cypher 作为查询语言，Cypher 是一种声明式图数据库查询语言，类似于 SQL，但是专门用于图数据库。Cypher 语言的语法简单直观，易于学习和使用，可以快速编写复杂的图查询。Neo4j 除了支持图检索外，还支持其他多种检索方式，包括向量检索、全文检索等。</p><p>下面我们来看在如何安装 Neo4j 数据库，Neo4j 的安装非常简单，只需要通过 Docker 下载镜像并启动就可以了，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name neo4j -d \</span><br><span class="line">    --publish=7474:7474 --publish=7687:7687 \</span><br><span class="line">    --volume=/your/host/path/neo4j-data/data:/data \</span><br><span class="line">    --<span class="built_in">env</span> NEO4J_PLUGINS=<span class="string">&#x27;[&quot;apoc&quot;]&#x27;</span> \</span><br><span class="line">    neo4j:5.21.0</span><br></pre></td></tr></table></figure><ul><li>我们使用 Neo4j 的 Docker 镜像进行安装，版本是 5.21.0</li><li>Neo4j 镜像会开放 2 个端口，端口 7474 的服务是 Web 管理服务，端口 7687 的服务是数据库服务</li><li>我们将 Neo4j 的数据目录映射到宿主机的 <code>/your/host/path/neo4j-data/data</code> 目录</li><li>我们通过环境变量给 Neo4j 安装一个插件 Apoc，保证 Python 程序可以通过账号密码连接数据库</li></ul><p>服务成功启动后，我们打开浏览器访问 <code>http://localhost:7474</code>，可以看到 Neo4j 的 Web 管理界面，如下图所示：</p><img src="/images/post/2024/07/neo4j-web.png" class="" width="1000" height="600"><p>输入初始账号密码：<code>neo4j/neo4j</code>，然后设置新密码，就可以进入到 Neo4j 的管理界面了。</p><h3 id="在-LlamaIndex-中使用-Neo4j"><a href="#在-LlamaIndex-中使用-Neo4j" class="headerlink" title="在 LlamaIndex 中使用 Neo4j"></a>在 LlamaIndex 中使用 Neo4j</h3><p>安装完 Neo4j 数据库后，我们就可以在 LlamaIndex 中使用 Neo4j 了，首先使用 <code>Neo4jGraphStore</code> 类来连接 Neo4j 数据库：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.graph_stores.neo4j <span class="keyword">import</span> Neo4jGraphStore</span><br><span class="line"></span><br><span class="line">username = <span class="string">&quot;neo4j&quot;</span></span><br><span class="line">password = <span class="string">&quot;neo4j&quot;</span></span><br><span class="line">url = <span class="string">&quot;bolt://localhost:7687&quot;</span></span><br><span class="line">database = <span class="string">&quot;neo4j&quot;</span></span><br><span class="line">graph_store = Neo4jGraphStore(</span><br><span class="line">    username=username,</span><br><span class="line">    password=password,</span><br><span class="line">    url=url,</span><br><span class="line">    database=database,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>Neo4jGraphStore</code> 创建连接 Neo4j 数据库的存储对象，传入用户名、密码、连接地址、数据库名称等参数</li><li><code>bolt</code> 是 Neo4j 数据库使用的一种高效的二进制协议，用于在客户端和服务器之间传输数据</li><li>Neo4j 数据库的社区版只能使用一个数据库，这里的数据库名称是固定的 <code>neo4j</code></li></ul><p>然后将文档保存到 Neo4j 数据库中，这里的测试文档还是用维基百科上的<a href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> StorageContext, SimpleDirectoryReader KnowledgeGraphIndex</span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">storage_context = StorageContext.from_defaults(graph_store=graph_store)</span><br><span class="line">index = KnowledgeGraphIndex.from_documents(</span><br><span class="line">    documents,</span><br><span class="line">    storage_context=storage_context,</span><br><span class="line">    max_triplets_per_chunk=<span class="number">2</span>,</span><br><span class="line">    include_embeddings=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>SimpleDirectoryReader</code> 加载文档数据</li><li>使用 <code>StorageContext</code> 创建存储上下文对象，传入图数据库存储对象</li><li>使用 <code>KnowledgeGraphIndex</code> 从文档中创建知识图谱索引对象</li><li><code>max_triplets_per_chunk=2</code> 参数表示每个文档块将被最多提取成 2 个三元组</li><li><code>include_embeddings=True</code> 参数表示将提取后的三元组转成 Embedding 向量并保存</li><li><code>KnowledgeGraphIndex</code> 默认使用 OpenAI 的 LLM 模型和 Embedding 模型 来进行实体提取和 Embedding，因此需要在环境变量中设置 OpenAI 的 API Key</li></ul><p>文档经过分块、实体提取、Embedding 等操作后，最后将实体和关系保存到 Neo4j 数据库中。数据入库完成后，我们可以在 Neo4j 数据库中查看所有的实体和关系，如下图所示：</p><img src="/images/post/2024/07/neo4j-dataset.png" class="" width="1000" height="600"><p>最后我们构建查询引擎，并对问题进行检索生成：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query_engine = index.as_query_engine(</span><br><span class="line">    include_text=<span class="literal">True</span>,</span><br><span class="line">    response_mode=<span class="string">&quot;tree_summarize&quot;</span>,</span><br><span class="line">    embedding_mode=<span class="string">&quot;hybrid&quot;</span>,</span><br><span class="line">    similarity_top_k=<span class="number">5</span>,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">response = query_engine.query(<span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Response: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>index.as_query_engine</code> 创建查询引擎对象</li><li><code>response_mode=&quot;tree_summarize&quot;</code> 参数表示最终结果使用树形总结的方式来生成</li><li><code>embedding_mode=&quot;hybrid&quot;</code> 参数表示使用图检索和向量检索的混合模式</li><li><code>similarity_top_k=5</code> 参数表示最多返回 5 个相似的文档块，<code>verbose=True</code> 参数表示检索过程中打印详细信息</li><li>使用查询引擎进行问题的检索和生成，最后打印出生成答案</li></ul><p>我们再来看下程序运行后的结果，因为我们开启了调试模式，所以在检索过程中会打印出详细的检索信息，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Extracted keywords: [<span class="string">&#x27;Avengers&#x27;</span>, <span class="string">&#x27;Ultron&#x27;</span>, <span class="string">&#x27;created&#x27;</span>, <span class="string">&#x27;members&#x27;</span>]</span><br><span class="line">KG context:</span><br><span class="line">The following are knowledge sequence <span class="keyword">in</span> max depth 2 <span class="keyword">in</span> the form of directed graph like:</span><br><span class="line">`subject -[predicate]-&gt;, object, &lt;-[predicate_next_hop]-, object_next_hop ...`</span><br><span class="line">[<span class="string">&#x27;CAPTURES&#x27;</span>, <span class="string">&#x27;Romanoff&#x27;</span>, <span class="string">&#x27;USES&#x27;</span>, <span class="string">&quot;Loki&#x27;s scepter to close&quot;</span>]</span><br><span class="line">[<span class="string">&#x27;BATTLE&#x27;</span>, <span class="string">&#x27;Chitauri&#x27;</span>, <span class="string">&#x27;KNOWN_AS&#x27;</span>, <span class="string">&#x27;Extraterrestrial race&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;CAPTURES&#x27;</span>, <span class="string">&#x27;Romanoff&#x27;</span>, <span class="string">&#x27;MAKES_HER_WAY_TO&#x27;</span>, <span class="string">&#x27;Generator&#x27;</span>]</span><br><span class="line">......</span><br><span class="line">Response: Tony Stark and Bruce Banner.</span><br></pre></td></tr></table></figure><ul><li>首先提取问题中的关键词，这里提取出了<code>Avengers</code>, <code>Ultron</code>, <code>created</code>, <code>members</code>这几个关键词</li><li>然后打印出根据关键词检索到的实体和关系三元组</li><li>最后根据问题和这些上下文生成了答案</li></ul><h2 id="GraphRAG"><a href="#GraphRAG" class="headerlink" title="GraphRAG"></a>GraphRAG</h2><p>看完 LlamaIndex 的知识图谱 RAG 实现后，我们再来看下另外一个知识图谱 RAG 的实现。最近微软开源了一个知识图谱 RAG 的实现叫 <a href="https://microsoft.github.io/graphrag/">GraphRAG</a>，它是一个基于知识图谱的 RAG 应用，可以用于问答、文本生成等任务。GraphRAG 是在微软之前发布的<a href="https://arxiv.org/pdf/2404.16130">论文</a> 理论基础上进行开发，与普通知识图谱 RAG 不同的地方是，它并没有用到图数据库，而是直接将知识图谱保存到文件中，然后通过其特有的图检索算法进行检索。另外 GraphRAG 还利用知识图谱的模块化特性，将知识图谱划分为多个语义相关的社区，并为每个社区生成概括性的摘要。 在回答用户查询时，GraphRAG 会根据查询内容检索相关的社区摘要，并利用这些摘要生成最终答案。</p><p>下面我们介绍一下 GraphRAG 的安装和使用方法，让大家可以快速地了解 GraphRAG。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>关于 GraphRAG 的安装方法，这里推荐使用源码安装的方式来安装 GraphRAG，因为这样可以让我们在使用过程中通过修改源码的方式来调试 GraphRAG，从而更好地理解 GraphRAG 的原理。</p><p>首先我们需要下载 GraphRAG 的源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/graphrag.git</span><br><span class="line"><span class="built_in">cd</span> graphrag</span><br></pre></td></tr></table></figure><p>然后我们需要使用 <a href="https://python-poetry.org/">Poetry</a> 来安装 GraphRAG 的依赖，Poetry 的安装可以参考其官网的<a href="https://python-poetry.org/docs/#installation">安装手册</a>，GraphRAG 安装依赖的命令如下：</p><blockquote><p>Poetry 是一个用于 Python 项目依赖管理和打包的工具，Poetry 使用一个 <code>pyproject.toml</code> 文件来管理项目的所有依赖项和元数据，使项目配置更加简洁明了，它会自动处理依赖项的版本冲突，并且能够生成锁文件 <code>poetry.lock</code>，确保在不同环境中安装相同的依赖版本。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 conda 创建一个 Python 环境</span></span><br><span class="line">conda create -n graphrag python=3.10</span><br><span class="line"><span class="comment"># 切换到这个 Python 环境</span></span><br><span class="line">conda activate graphrag</span><br><span class="line"><span class="comment"># 构建一个 Poetry 虚拟环境</span></span><br><span class="line">poetry <span class="built_in">env</span> use python</span><br><span class="line"><span class="comment"># 进入该环境</span></span><br><span class="line">poetry shell</span><br><span class="line"><span class="comment"># 安装依赖，会根据 GraphRAG 的 poetry.lock 文件安装依赖</span></span><br><span class="line">poetry install</span><br></pre></td></tr></table></figure><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>GraphRAG 安装完成后，我们再来准备测试文档，创建一个测试文件夹，用来存放我们的测试文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ./ragtest/input</span><br><span class="line"><span class="comment"># GraphRAG 官方文档是下载这个文件作为测试文档，我们也可以放其他的 txt 文档</span></span><br><span class="line">curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt &gt; ./ragtest/input/book.txt</span><br></pre></td></tr></table></figure><p>然后创建配置文件，我们使用 GraphRAG 的初始化命令来生成配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run poe index --init --root ./ragtest</span><br></pre></td></tr></table></figure><p>初始化完成后，我们可以看到在 <code>./ragtest</code> 目录下生成了 <code>settings.yaml</code> 和 <code>.env</code> 2 个文件，在 <code>.env</code> 文件中通过 <code>GRAPHRAG_API_KEY</code> 键来设置 OpenAI 的 API Key，而<code>settings.yaml</code> 文件用来保存 GraphRAG 的流水线配置信息。</p><h3 id="入库流程"><a href="#入库流程" class="headerlink" title="入库流程"></a>入库流程</h3><p>初始化配置完成后，我们使用 GraphRAG 执行数据入库流水线，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run poe index --root ./ragtest</span><br></pre></td></tr></table></figure><p>这个执行过程比较耗时，因为 GraphRAG 会将文档进行一系列的操作，包括文档分块、实体提取、文本 Embedding、生成社区报告等，以下是 GraphRAG 的索引入库流程图：</p><img src="/images/post/2024/07/graphrag-index-flow.png" class="" width="1000" height="600"><p>执行完成后，我们可以在 <code>./ragtest/output/&#123;timestamp&#125;/artifacts</code> 目录下可以看到生成的索引文件，默认是 <code>parquet</code> 格式，后面的检索流程会从这里读取数据。</p><p>想了解更多关于 GraphRAG 数据入库的信息，可以参考其<a href="https://microsoft.github.io/graphrag/posts/index/1-default_dataflow/">官方文档</a>。</p><h3 id="检索流程"><a href="#检索流程" class="headerlink" title="检索流程"></a>检索流程</h3><p>文档入库完成后，我们就可以使用 GraphRAG 进行检索生成了，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run poe query --root ./ragtest --method <span class="built_in">local</span> <span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span></span><br></pre></td></tr></table></figure><p>GraphRAG 的检索模式有 2 种，分别是本地模式和全局模式，上面的命令使用 <code>--method</code> 参数来指定哪种模式。</p><p>本地模式类似传统的知识图谱 RAG，通过结合来自知识图谱的相关数据和原始文档的文本块生成答案，而全局模式是通过在所有社区报告上进行搜索，以类似 map-reduce 的方式生成答案。以下是 GraphRAG 本地检索的流程图：</p><img src="/images/post/2024/07/graphrag-query-local-flow.png" class="" width="1000" height="600"><p>经过测试，GraphRAG 在检索质量上要比普通 RAG 更好，文档数据越多优势越明显，但是 GraphRAG 的检索速度要比普通 RAG 慢，因为 GraphRAG 需要对文档进行多种方式检索。</p><p>关于 GraphRAG 的检索流程的更多信息，可以参考其<a href="https://microsoft.github.io/graphrag/posts/query/overview/">官方文档</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>知识图谱 RAG 是一种基于知识图谱的 RAG 技术，它通过图结构来表示和存储信息，提取其中的实体和关系，然后通过图检索的方式来进行检索生成。对于一些大型的私有文档库和复杂的全局性问题，知识图谱 RAG 无疑是一个很好的选择，但在使用过程中也要综合考虑，知识图谱的增强往往也会导致检索生成的速度变慢以及耗费的资源增加，因此在实际应用中需要根据具体的场景来选择合适的 RAG 技术。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍如何使用知识图谱来改进 RAG 的检索策略</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="knownledge-graph" scheme="https://zhaozhiming.github.io/tags/knownledge-graph/"/>
    
    <category term="graphrag" scheme="https://zhaozhiming.github.io/tags/graphrag/"/>
    
    <category term="neo4j" scheme="https://zhaozhiming.github.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之 Self-RAG</title>
    <link href="https://zhaozhiming.github.io/2024/06/30/rag-selfrag/"/>
    <id>https://zhaozhiming.github.io/2024/06/30/rag-selfrag/</id>
    <published>2024-06-30T08:22:07.000Z</published>
    <updated>2024-10-03T08:49:29.888Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/07/rag-selfrag.jpg" class="" width="400" height="300"><p>Self-RAG 是另外一种形式的 RAG（Retrieval Augmented Generation），它与其他 RAG 检索策略不同，它并不是在 RAG 流程上对某个模块进行增强， 而是在 RAG 不同的模块上进行优化改进，从而达到改进整体 RAG 流程的目的。如果你对 Self-RAG 比较陌生或者只是听说它的名字，那么今天请跟我一起来了解 Self-RAG 的实现原理，以及通过学习 Self-RAG 的代码实现来更好地理解其中的细节。</p><span id="more"></span><h2 id="Self-RAG-整体概览"><a href="#Self-RAG-整体概览" class="headerlink" title="Self-RAG 整体概览"></a>Self-RAG 整体概览</h2><p><a href="https://selfrag.github.io/">Self-RAG</a> 是一种新的 RAG 方式，通过训练后的 LLM（大语言模型）进行检索、生成和评估等任务，以提高生成结果的准确性和质量。研究团队经过实验证明，Self-RAG 在开放领域问答、推理和事实验证任务中表现优异，效果要比商业模型 ChatGPT 好，同时也比开源模型 Llama2 使用普通 RAG 的效果更好，Self-RAG 的论文地址可以看<a href="https://arxiv.org/abs/2310.11511">这里</a>。</p><p>Self-RAG 旨在解决普通 RAG 的几个问题：</p><ul><li>过度检索：普通 RAG 对输入问题始终进行相关知识检索，可能引入无用甚至偏离主题的内容，从而影响输出结果</li><li>输出不准确：因为不能保证 LLM 始终是基于检索知识来回答问题，所以输出结果可能与检索到的知识不一致</li></ul><p>在后面的介绍中我们会慢慢了解为什么 Self-RAG 能解决这些问题。</p><h3 id="Self-RAG-流程"><a href="#Self-RAG-流程" class="headerlink" title="Self-RAG 流程"></a>Self-RAG 流程</h3><p>为了更好地理解 Self-RAG，我们来看下它与普通 RAG 的区别，首先我们来看下普通 RAG 的流程图：</p><img src="/images/post/2024/07/base-rag-flow.png" class="" width="1000" height="600"><ul><li>这个流程图省略了文档入库的部分，主要展示检索和生成的过程</li><li>每一次查询，普通 RAG 都会去检索相关文档，然后将<strong>所有的文档</strong>和问题一起输入到 LLM 中，然后生成结果</li><li>生成结果的提示词需要添加所有的检索文档作为问题的上下文，一般会要求 LLM 优先根据上下文知识进行回答</li></ul><p>我们再来看下 Self-RAG 的流程图：</p><img src="/images/post/2024/07/selfrag-flow.png" class="" width="1000" height="600"><ul><li>Self-RAG 首先会使用 LLM 对问题进行首次结果生成（这里的 LLM 是经过特殊训练后的 LLM，后面会详细介绍），然后根据生成的结果可以直接判断是否需要检索，如果不需要检索，则直接返回结果</li><li>如果需要检索，Self-RAG 会检索出相关文档，然后将<strong>每个文档</strong>和问题一起输入到 LLM 中，获取每个文档的生成结果，生成结果的提示词只用到了单个文档来作为问题的上下文</li><li>然后对每个文档的生成结果进行评估，评选出得分最高的结果，最终返回这个结果</li></ul><h3 id="Self-RAG-与普通-RAG-的区别"><a href="#Self-RAG-与普通-RAG-的区别" class="headerlink" title="Self-RAG 与普通 RAG 的区别"></a>Self-RAG 与普通 RAG 的区别</h3><p>从以上 2 个流程图可以看出，Self-RAG 与普通 RAG 的区别主要有以下几点：</p><ul><li>普通 RAG 每次查询都需要检索，而 Self-RAG 可以根据生成的结果判断是否需要检索</li><li>普通 RAG 将检索到的所有文档作为上下文，而 Self-RAG 只用到了单个文档作为上下文，但需要对每个文档进行结果生成</li><li>Self-RAG 对生成结果有一个评估和挑选的过程，而普通 RAG 没有这个过程，因为普通 RAG 的生成结果只有一个</li><li>普通 RAG 使用的是通用 LLM，而 Self-RAG 使用的是经过特殊训练后的 LLM</li></ul><h2 id="按需检索"><a href="#按需检索" class="headerlink" title="按需检索"></a>按需检索</h2><p>了解了 Self-RAG 的整体流程后，我们再来了解一下 Self-RAG 每个阶段的实现原理，首先是首次查询阶段。</p><p>与普通的 RAG 不同，Self-RAG 使用的是经过训练的 LLM，这种 LLM 在文本生成的过程中，会输出一些特殊的 Token，这些 Token 叫 <strong>Reflection Token</strong>。在 RAG 流程中，Self-RAG 会使用 Reflection Token 来进行不同的操作。</p><p>Self-RAG 开始使用 LLM 对问题进行生成时，会输出 <code>Retrieve</code> 类型的 Reflection Token，这种类型的 Token 的值有 3 种，分别是：</p><ul><li>Retrieval：表示需要检索</li><li>No Retrieval：表示不需要检索</li><li>Continue to Use Evidence: 表示模型可以继续使用先前检索到的证据</li></ul><p>我们来通过几个例子来看一下 Self-RAG 生成的 Reflection Token 是怎样的，首先我们提问一个不需要检索的问题，问题和输出结果示例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Question: Write a essay of your best summer vacation.</span><br><span class="line">Answer: Sure![No Retrieval]As an AI, I don<span class="string">&#x27;t have personal experiences or memories, but I can write about the importance and significance of summer vacations for individuals and families.[No Retrieval]......</span></span><br></pre></td></tr></table></figure><p>在返回结果中我们可以看到包含了<code>[No Retrieval]</code>关键字，表示这个问题不需要检索，可以直接返回结果。</p><p>我们再问一个需要检索的问题，问题和输出结果示例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Question: How did US statues get their names?</span><br><span class="line">Answer: A number of them.[Retrieval]&lt;paragraph&gt;[Irrelevant]Some were named <span class="keyword">for</span> the people <span class="built_in">who</span> originally sponsored them, some were named <span class="keyword">for</span> events or issues that they represented, and some were named <span class="keyword">for</span> mythological figures.[Utility:4]</span><br></pre></td></tr></table></figure><p>在返回结果中我们可以看到包含了<code>[Retrieval]&lt;paragraph&gt;</code> 关键字，表示这个问题需要补充外部知识，即需要检索。</p><p>当然，普通 RAG 也可以通过其他方式来实现按需检索，比如首先通过 LLM 确定查询问题是否需要检索，返回一个<code>yes/no</code>的结果，如果不需要检索，则再用 LLM 生成最终结果。这意味着，如果查询问题不需要检索，普通 RAG 需要调用 2 次 LLM，而 Self-RAG 只需要调用 1 次 LLM。</p><img src="/images/post/2024/07/need-require-different.png" class="" width="1000" height="600"><p>可以看到在不需要检索这个分支上，Self-RAG 比普通 RAG 的效率更高。</p><h2 id="检索与生成"><a href="#检索与生成" class="headerlink" title="检索与生成"></a>检索与生成</h2><p>当 Self-RAG 经过首次查询后，发现需要检索，那么就会使用检索器根据问题检索文档，在检索方面，Self-RAG 和普通 RAG 并没有什么不同，都是通过向量相似性来检索文档。当检索完文档后，会将每个文档和问题一起输入到 LLM 中，获取每个文档的生成结果。</p><p>在第二次的生成结果中，Self-RAG 的 LLM 会生成 3 种类型的 Reflection Token，分别是：</p><ul><li>IsREL：检查检索到的文档是否为问题提供了有用的信息，它的值有<code>[Relevant]</code>和<code>[Irrelevant]</code>，表示文档的相关性</li><li>IsSUP：检查检索到的文档是否都为生成的答案提供了支持，它的值有<code>[Fully supported]</code>，<code>[Partially supported]</code>，<code>[No support / Contradictory]</code>，表示支持的程度</li><li>IsUSE：表示生成的答案是否对问题有帮助，它的值有<code>[Utility:5]</code>、<code>[Utility:4]</code>、<code>[Utility:3]</code>、<code>[Utility:2]</code>、<code>[Utility:1]</code>，表示答案的质量，数字越大表示质量越高</li></ul><img src="/images/post/2024/07/selfrag-second-generate.png" class="" width="400" height="600"><p>我们来看下 Self-RAG 在这个阶段的生成结果，问题和输出结果示例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Question: What mysterious object did Loki use <span class="keyword">in</span> his attempt to conquer Earth?</span><br><span class="line">Answer1: [Relevant]The mysterious object that Loki used <span class="keyword">in</span> his attempt to conquer Earth was the Tesseract, <span class="built_in">which</span> is a powerful energy <span class="built_in">source</span> of unknown potential.[Fully supported][Utility:5]</span><br><span class="line">Answer2: [Relevant]Thanos used the Time Stone to dodge Loki<span class="string">&#x27;s attack.[No support / Contradictory][Utility:5]</span></span><br></pre></td></tr></table></figure><p>可以看到，在每个生成结果中，基本上都包含了以上 3 种 Reflection Token，这些 Token 会在后面的评估阶段进行使用。</p><h3 id="优化生成效率"><a href="#优化生成效率" class="headerlink" title="优化生成效率"></a>优化生成效率</h3><p>在这个阶段因为需要使用 LLM 对每个文档生成结果，可能会有人觉得这个阶段的效率会比普通 RAG 低，但实际上可以使用并发的方式来进行结果生成，从而提高效率。</p><img src="/images/post/2024/07/selfrag-concurrent-generate.png" class="" width="500" height="600"><p>上图中 Self-RAG 虽然需要调用 3 次 LLM，但通过并发的方式，执行时间和调用 1 次 LLM 的时间是一样的，所以在这个阶段 Self-RAG 的效率和普通 RAG 基本一致，虽然 Self-RAG 耗费的 token 会多一些。</p><h2 id="评估与选择"><a href="#评估与选择" class="headerlink" title="评估与选择"></a>评估与选择</h2><p>当生成了每个文档的结果后，Self-RAG 会对每个文档的结果进行评估，评估的方式是通过上个阶段生成的 Reflection Token 来计算每个文档的得分，然后选择得分最高的文档作为最终结果。</p><h3 id="评估参数-logprobs"><a href="#评估参数-logprobs" class="headerlink" title="评估参数 logprobs"></a>评估参数 logprobs</h3><p>在了解评估的方式之前，我们先来了解一下 Self-RAG 评估的一个重要参数<code>logprobs</code>，这个参数指的是对每个生成的 token（即单词或子词）的概率对数，这个参数是在生成结果时 LLM 输出的，通过这个参数可以计算每个 token 的得分。</p><img src="/images/post/2024/07/general-workflow-for-prompt.png" class="" width="1000" height="600"><p>我们来看下 OpenAI API 返回的一个结果示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmpl-6yE4TGqItUpYJ6xYcIzY6&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1623073722</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;davinci&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot; I&#x27;m good, thanks!&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logprobs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot; I&#x27;m&quot;</span><span class="punctuation">,</span> <span class="string">&quot; good&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">,</span> <span class="string">&quot; thanks&quot;</span><span class="punctuation">,</span> <span class="string">&quot;!&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;token_logprobs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">-0.1</span><span class="punctuation">,</span> <span class="number">-0.05</span><span class="punctuation">,</span> <span class="number">-0.2</span><span class="punctuation">,</span> <span class="number">-0.3</span><span class="punctuation">,</span> <span class="number">-0.15</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;top_logprobs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot; I&#x27;m&quot;</span><span class="punctuation">:</span> <span class="number">-0.1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot; I am&quot;</span><span class="punctuation">:</span> <span class="number">-2.3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot; I&quot;</span><span class="punctuation">:</span> <span class="number">-3.1</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot; good&quot;</span><span class="punctuation">:</span> <span class="number">-0.05</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot; fine&quot;</span><span class="punctuation">:</span> <span class="number">-1.5</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot; great&quot;</span><span class="punctuation">:</span> <span class="number">-2.0</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;,&quot;</span><span class="punctuation">:</span> <span class="number">-0.2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="number">-2.5</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;!&quot;</span><span class="punctuation">:</span> <span class="number">-3.0</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot; thanks&quot;</span><span class="punctuation">:</span> <span class="number">-0.3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot; thank you&quot;</span><span class="punctuation">:</span> <span class="number">-1.8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot; thank&quot;</span><span class="punctuation">:</span> <span class="number">-2.6</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;!&quot;</span><span class="punctuation">:</span> <span class="number">-0.15</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="number">-1.9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;?&quot;</span><span class="punctuation">:</span> <span class="number">-2.7</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text_offset&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">14</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">21</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;length&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，logprobs 参数的输出如下：</p><ul><li>tokens：生成的 token 列表 [“ I’m”, “ good”, “,”, “ thanks”, “!”]</li><li>token_logprobs：每个生成的 token 的对数概率值 [-0.1, -0.05, -0.2, -0.3, -0.15]</li><li>top_logprobs：每个生成的 token 的前几名候选 token 的对数概率值及其对应的 token，例如第一个 token<code> I’m</code>的前几名候选 token 及其对数概率值为<code>&#123;&quot; I’m&quot;: -0.1, &quot; I am&quot;: -2.3, &quot; I&quot;: -3.1&#125;</code></li><li>text_offset：每个 token 在生成文本中的偏移量 [5, 9, 14, 15, 21]</li></ul><p>在 Self-RAG 中，评估功能使用<code>logprobs</code>参数来计算<code>IsREL</code>、<code>IsSUP</code>和<code>IsUSE</code>这 3 种 Reflection Token 的得分。比如输出中出现了<code>[Fully supported]</code>这个 token，那么说明 LLM 推理的时候计算出了<code>[Fully supported]</code>、<code>[Partially supported]</code>等可能的 token 输出的概率，但最后选择了<code>[Fully supported]</code>。因此，在评估这次输出的 <code>IsSUP</code> 的分数时，就可以基于 logprobs 中这些 tokens 的概率来计算。</p><h3 id="评估公式"><a href="#评估公式" class="headerlink" title="评估公式"></a>评估公式</h3><p>了解了<code>logprobs</code>参数后，我们再来看下 Self-RAG 3 个评估指标的计算公式，首先是<code>IsREL</code>的计算公式：</p><blockquote><p>s(ISREL) &#x3D; p(ISREL &#x3D; RELEVANT) &#x2F; (p(ISREL &#x3D; RELEVANT) + p(ISREL &#x3D; IRRELEVANT))</p></blockquote><ul><li>p(ISREL &#x3D; RELEVANT) 代表模型预测 ISREL 为 Relevant 的概率</li><li>p(ISREL &#x3D; IRRELEVANT) 代表模型预测 ISREL 为 Irrelevant 的概率</li></ul><p>然后是<code>IsSUP</code>的计算公式：</p><blockquote><p>s(ISSUP) &#x3D; p(ISSUP &#x3D; FULLY) &#x2F; S + 0.5 * p(ISSUP &#x3D; PARTIALLY) &#x2F; S</p></blockquote><ul><li>p(ISSUP &#x3D; FULLY) 代表模型预测 ISSUP 为 Fully Supported 的概率</li><li>p(ISSUP &#x3D; PARTIALLY) 代表模型预测 ISSUP 为 Partially Supported 的概率</li><li>S 代表三种可能值的概率之和： S &#x3D; ∑t∈{FULLY,PARTIALLY,NO} p(ISSUP &#x3D; t)</li></ul><p>最后是<code>IsUSE</code>的计算公式：</p><blockquote><p>s(ISUSE) &#x3D; (∑i wi * p(ISUSE &#x3D; i)) &#x2F; S</p></blockquote><ul><li>wi 代表每个等级的权重，分别为：{-1, -0.5, 0, 0.5, 1}，对应 ISUSE&#x3D;{1, 2, 3, 4, 5}</li><li>p(ISUSE &#x3D; i) 代表模型预测 ISUSE 为等级 i 的概率</li><li>S 代表五种等级的概率之和：S &#x3D; ∑t∈{1,2,3,4,5} p(ISUSE &#x3D; t)</li></ul><p>可以看到这些计算公式都是基于 logprobs 参数来计算的，这样可以更好地评估每个文档的生成结果，从而选择得分最高的文档作为最终结果。</p><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>Self-RAG 需要训练的模型有 2 种，一种是评估模型（Critic），另一种是生成模型（Generator）。评估模型使用 GPT4 生成的数据作为训练语料，生成模型则是使用检索数据和评估模型的生成数据作为训练语料，两者都可以基于基础大模型进行训练。</p><p>Self-RAG 研究团队分别基于 Llama2-7b 和 Llama2-13b 这 2 个模型进行训练，训练好的模型可以在 <a href="https://huggingface.co/selfrag">Huggingface</a> 上进行下载，但官方的模型并没有明确区分是评估模型还是生成模型，也就是说这些模型可以同时用于评估和生成。</p><p>我们来看下模型训练的数据，首先是评估模型的训练数据，下面是训练数据的截取片段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;task&quot;</span><span class="punctuation">:</span> <span class="string">&quot;retrieval&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;instruction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;When provided with instruction, please evaluate whether seeking additional information from external sources such as the web (e.g., Wikipedia) aids in producing a more comprehensive response. Respond with either [Retrieval] or [No Retrieval].&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task instruction: Appraise the following website design. https://example.com\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[Retrieval]&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>评估模型的每项训练数据都是一项任务，任务类型分别有<code>retrieval</code>、<code>groundness</code>、<code>utility</code> 和 <code>multi_retrieval</code>这 4 种任务</li><li><code>retrieval</code>任务用来训练生成<code>IsREL</code>评估指标</li><li><code>groudness</code> 任务用来训练生成<code>IsSUP</code>评估指标</li><li><code>utility</code>任务用来训练生成<code>IsUSE</code>评估指标</li><li><code>multi_retrieval</code>任务用来训练生成<code>Retrieve</code>类型的 Reflection Token，即是否需要检索</li></ul><p>通过训练数据可以看出，评估模型主要训练如何评估这 4 类任务，根据指令和输入数据，输出正确的评估结果。</p><p>再来看生成模型的训练数据，下面是训练数据的截取片段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;instruction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Question: Write a text based on \&quot;rangers show some iron to tie the series\&quot;\nText: along with being talented , self-assured and highly paid , these experienced rangers are also considerate .\n\nQuestion: Write a text based on \&quot;union wo n&#x27;t dismantle blockage of gm canada headquarters\&quot;\nText: canadian auto workers officials friday refused to end a blockade of general motors canada headquarters despite an offer to potentially bring new car production to a complex where a truck plant is slated for closure .\n\nQuestion: Write a text based on \&quot;six azerbaijan opposition parliamentary candidates declare hunger strike\&quot;\nText:&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[No Retrieval]six opposition candidates in the upcoming parliamentary elections in azerbaijan declared a hunger strike friday to pressure the government into ensuring fair polls .[Utility:5]&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flan_v2_18667&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dataset_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flan_v2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过训练数据可以看出，生成模型主要训练如何生成带有 Reflection Token 的综合性结果。</p><h2 id="LlamaIndex-Self-RAG-Pack"><a href="#LlamaIndex-Self-RAG-Pack" class="headerlink" title="LlamaIndex Self-RAG Pack"></a>LlamaIndex Self-RAG Pack</h2><p>目前已经有了一些开源的 Self-RAG 实现，比如在 <a href="https://www.llamaindex.ai/">LlamaIndex</a> 的 <a href="https://docs.llamaindex.ai/en/stable/community/llama_packs/">Llama Packs</a> 上就有人提供了 <a href="https://llamahub.ai/l/llama-packs/llama-index-packs-self-rag?from=">Self-RAG 的实现</a>，下面我们来看下如何使用 LlamaIndex 的 Self-RAG Pack。</p><blockquote><p>Llama Packs 是一个社区驱动的预包装模块或模板集合，用于快速开始构建基于 LLM 的应用程序，如果把 LlamaIndex 比作 VsCode 的话，那么 Llama Packs 就是 VsCode 的插件。</p></blockquote><h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><p>首先我们需要下载 Self-RAG 模型， 这里我们下载量化版的 Self-RAG 模型，这样我们可以在没有 GPU 的机器上运行模型，下载命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -q huggingface-hub</span><br><span class="line">huggingface-cli download m4r1/selfrag_llama2_7b-GGUF selfrag_llama2_7b.q4_k_m.gguf --local-dir <span class="string">&quot;&lt;DIR_PATH&gt;&quot;</span> --local-dir-use-symlinks False</span><br></pre></td></tr></table></figure><p>然后下载 LlamaIndex 的 Self-RAG Pack，下载命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llamaindex-cli download-llamapack SelfRAGPack --download-dir ./self_rag_pack</span><br></pre></td></tr></table></figure><p>下载完成后，我们可以看到下载的文件夹中包含了 Self-RAG Pack 的源码，我们可以通过以下代码来调用 Self-RAG Pack：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> self_rag_pack.llama_index.packs.self_rag.base <span class="keyword">import</span> SelfRAGQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, SimpleDirectoryReader</span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">retriever = index.as_retriever(similarity_top_k=<span class="number">10</span>)</span><br><span class="line">model_path = <span class="string">&quot;/your/selfrag-model-path/selfrag_llama2_7b.q4_k_m.gguf&quot;</span></span><br><span class="line">query_engine = SelfRAGQueryEngine(<span class="built_in">str</span>(model_path), retriever, verbose=<span class="literal">True</span>)</span><br><span class="line">response = query_engine.query(<span class="string">&quot;Who won best Director in the 1972 Academy Awards?&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>SelfRAGQueryEngine</code> 初始化需要模型路径和检索器，检索器可以使用普通 RAG 的检索器 <code>VectorStoreIndex</code>。</p><h3 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h3><p>Self-RAG Pack 的核心代码在 <code>SelfRAGQueryEngine</code> 类中，这个类包含了 Self-RAG 的整个流程，首先我们看下 <code>custom_query</code> 方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">custom_query</span>(<span class="params">self, query_str: <span class="built_in">str</span></span>) -&gt; Response:</span><br><span class="line">    response = <span class="variable language_">self</span>.llm(prompt=_format_prompt(query_str), **_GENERATE_KWARGS)</span><br><span class="line">    answer = response[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    source_nodes = []</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment"># 省略检索部分代码</span></span><br><span class="line"></span><br><span class="line">    answer = _postprocess_answer(answer)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.verbose:</span><br><span class="line">        print_text(<span class="string">f&quot;Final answer: <span class="subst">&#123;answer&#125;</span>\n&quot;</span>, color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(response=<span class="built_in">str</span>(answer), source_nodes=source_nodes)</span><br></pre></td></tr></table></figure><ul><li>通过 LLM 进行首次查询，获取生成结果</li><li>对生成结果进行判断，如果需要检索，则调用检索器进行检索，这部分代码后面介绍</li><li>如果无需检索，则对结果进行后处理，然后返回结果，这里的后处理主要是去掉 Reflection Token</li></ul><p>再来看<code>custom_query</code>方法中的检索部分代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">custom_query</span>(<span class="params">self, query_str: <span class="built_in">str</span></span>) -&gt; Response:</span><br><span class="line">    ...... <span class="comment"># 省略已展示过的代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;[Retrieval]&quot;</span> <span class="keyword">in</span> answer:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.verbose:</span><br><span class="line">            print_text(<span class="string">&quot;Retrieval required\n&quot;</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">        documents = <span class="variable language_">self</span>.retriever.retrieve(query_str)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.verbose:</span><br><span class="line">            print_text(<span class="string">f&quot;Received: <span class="subst">&#123;<span class="built_in">len</span>(documents)&#125;</span> documents\n&quot;</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">        paragraphs = [</span><br><span class="line">            _format_prompt(query_str, document.node.text) <span class="keyword">for</span> document <span class="keyword">in</span> documents</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.verbose:</span><br><span class="line">            print_text(<span class="string">&quot;Start evaluation\n&quot;</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"></span><br><span class="line">        critic_output = <span class="variable language_">self</span>._run_critic(paragraphs)</span><br><span class="line"></span><br><span class="line">        paragraphs_final_score = critic_output.paragraphs_final_score</span><br><span class="line">        llm_response_per_paragraph = critic_output.llm_response_per_paragraph</span><br><span class="line">        source_nodes = critic_output.source_nodes</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.verbose:</span><br><span class="line">            print_text(<span class="string">&quot;End evaluation\n&quot;</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"></span><br><span class="line">        best_paragraph_id = <span class="built_in">max</span>(</span><br><span class="line">            paragraphs_final_score, key=paragraphs_final_score.get</span><br><span class="line">        )</span><br><span class="line">        answer = llm_response_per_paragraph[best_paragraph_id]</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.verbose:</span><br><span class="line">            print_text(<span class="string">f&quot;Selected the best answer: <span class="subst">&#123;answer&#125;</span>\n&quot;</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">    ...... <span class="comment"># 省略已展示过的代码</span></span><br></pre></td></tr></table></figure><ul><li>通过判断生成结果中是否包含<code>[Retrieval]</code>来判断是否需要检索</li><li>如果需要检索，则调用检索器进行检索，获取检索到的文档， 并将检索到的文档内容和问题一起构建成提示词列表<code>paragraphs</code></li><li>执行<code>_run_critic</code>方法进行结果生成并评估，这个方法的代码后面介绍</li><li>从<code>_run_critic</code>方法中得到每个文档的分数列表<code>paragraphs_final_score</code>，每个文档的生成结果列表<code>llm_response_per_paragraph</code>和文档列表<code>source_nodes</code></li><li>在<code>paragraphs_final_score</code>中选择得分最高的文档作为最终结果，然后返回该结果</li></ul><p>接下来我们看下 <code>_run_critic</code> 方法的实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_run_critic</span>(<span class="params">self, paragraphs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; CriticOutput:</span><br><span class="line">    paragraphs_final_score = &#123;&#125;</span><br><span class="line">    llm_response_text = &#123;&#125;</span><br><span class="line">    source_nodes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p_idx, paragraph <span class="keyword">in</span> <span class="built_in">enumerate</span>(paragraphs):</span><br><span class="line">        pred = <span class="variable language_">self</span>.llm(paragraph, **<span class="variable language_">self</span>.generate_kwargs)</span><br><span class="line">        <span class="comment"># Cache llm answer</span></span><br><span class="line">        llm_response_text[p_idx] = pred[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;text&quot;</span>]</span><br><span class="line">        logprobs = pred[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;logprobs&quot;</span>]</span><br><span class="line">        pred_log_probs = logprobs[<span class="string">&quot;top_logprobs&quot;</span>]</span><br><span class="line">        <span class="comment"># Compute isRel score, on the first predicted token</span></span><br><span class="line">        isRel_score = _relevance_score(pred_log_probs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute isSup score</span></span><br><span class="line">        isSup_score = _is_supported_score(logprobs[<span class="string">&quot;tokens&quot;</span>], pred_log_probs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute isUse score</span></span><br><span class="line">        isUse_score = _is_useful_score(logprobs[<span class="string">&quot;tokens&quot;</span>], pred_log_probs)</span><br><span class="line"></span><br><span class="line">        paragraphs_final_score[p_idx] = (</span><br><span class="line">            isRel_score + isSup_score + <span class="number">0.5</span> * isUse_score</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># Add the paragraph as source node with its relevance score</span></span><br><span class="line">        source_nodes.append(</span><br><span class="line">            NodeWithScore(</span><br><span class="line">                node=TextNode(text=paragraph, id_=p_idx),</span><br><span class="line">                score=isRel_score,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        ...... <span class="comment"># 省略打印语句</span></span><br><span class="line">    <span class="keyword">return</span> CriticOutput(llm_response_text, paragraphs_final_score, source_nodes)</span><br></pre></td></tr></table></figure><ul><li>初始化几个变量：每个文档的分数列表<code>paragraphs_final_score</code>，每个文档的生成结果列表<code>llm_response_per_paragraph</code>和文档列表<code>source_nodes</code></li><li>遍历提示词列表<code>paragraphs</code>，每个提示词是问题加检索文档，将提示词发送给 LLM，获取生成结果，这里是串行地调用 LLM，如果换成并发的方式效率更高</li><li>从 LLM 的生成结果中获取生成的文本和<code>logprobs</code>参数，将文本内容保存到<code>llm_response_text</code>中，将<code>logprobs</code>参数用来计算<code>IsREL</code>、<code>IsSUP</code>和<code>IsUSE</code>的得分</li><li>分别计算<code>IsREL</code>、<code>IsSUP</code>和<code>IsUSE</code>的得分，然后通过这个计算公式计算出每个文档的最终得分：<code>final_score = IsREL + IsSUP + 0.5 * IsUSE</code>，并将结果保存到<code>paragraphs_final_score</code>中</li><li>将每个文档转换为 <code>NodeWithScore</code> 对象保存到<code>source_nodes</code>中</li><li>最后返回<code>CriticOutput</code>对象，包含了每个文档的生成结果、分数和文档列表</li></ul><p>关于更多 Self-RAG Pack 的代码实现，可以查看<a href="https://github.com/run-llama/llama_index/blob/main/llama-index-packs/llama-index-packs-self-rag/llama_index/packs/self_rag/base.py">这里</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过今天的介绍，我们了解了 Self-RAG 的实现原理，以及通过 LlamaIndex 的 Self-RAG Pack 代码来学习 Self-RAG 的具体实现，让我们可以更好地理解 Self-RAG 的细节和流程。Self-RAG 主要通过自训练的 LLM 来为生成结果提供 Reflection Token，从而可以轻松实现按需检索和评估等功能，无需再次调用 LLM 或者使用其他第三方库，这样可以提高效率和准确性。希望通过今天的介绍大家可以更好地理解 Self-RAG，将来可以更好地应用 Self-RAG 到实际项目中。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍 Self-RAG 的实现原理以及具体实践</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="selfrag" scheme="https://zhaozhiming.github.io/tags/selfrag/"/>
    
  </entry>
  
  <entry>
    <title>评估 RAG？只要 LlamaIndex 就足够了</title>
    <link href="https://zhaozhiming.github.io/2024/06/16/llamaindex-buildin-evaluation/"/>
    <id>https://zhaozhiming.github.io/2024/06/16/llamaindex-buildin-evaluation/</id>
    <published>2024-06-15T23:06:29.000Z</published>
    <updated>2024-10-03T08:49:29.888Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/06/llamaindex-evaluation.jpg" class="" width="400" height="300"><p>我们之前介绍过一些 RAG （Retrieval Augmented Generation）的评估工具，比如 Turlens、Ragas 等，它们的评估指标丰富、使用方便，但它们始终是独立的第三方工具，需要和 LLM（大语言模型）开发框架（LangChain、LlamaIndex）进行集成才能使用，功能一旦更新不及时就会导致不可用的问题。如果你正在使用的是 LlamaIndex 开发框架，那么恭喜你，LlamaIndex 内置了评估工具，可以帮助你快速评估 RAG 应用，无需集成第三方的评估工具。今天我们就来详细了解一下 LlamaIndex 内置评估工具的原理以及它们的使用方法。</p><span id="more"></span><h2 id="LlamaIndex-评估工具"><a href="#LlamaIndex-评估工具" class="headerlink" title="LlamaIndex 评估工具"></a>LlamaIndex 评估工具</h2><p><a href="https://www.llamaindex.ai/">LlamaIndex</a> 不但可以与很多外部优秀的第三方评估工具进行集成，而且在内部也自带了一套评估工具，如果你想快速地体验 RAG 的评估功能，那么使用 LlamaIndex 内置的评估工具就足够了。LlamaIndex 有以下评估指标：</p><ul><li>Answer Relevcancy</li><li>Context Relevancy</li><li>Relevancy</li><li>Faithfulness</li><li>Correctness</li></ul><p>这些评估指标我们后面会详细介绍，另外还有 LlamaIndex 特有的对比评估 Pairwise，可以帮助你评估两个检索引擎哪个生成的答案更好。</p><p>LlamaIndex 还提供了测试数据的生成功能，可以帮助我们轻松地生成评估所需的测试数据，包括评估的问题、参考答案等，这样我们就可以快速地进行评估工作，而不需要花费大量的时间去准备测试数据。</p><p>如果你想提升评估工作的效率，LlamaIndex 也提供了批量运行评估任务的工具，可以快速评估多种评估指标以及大量测试数据，批量任务的执行时间和单次任务的执行时间基本无异，这样就可以帮助我们快速地执行大量评估任务。</p><h2 id="测试数据生成"><a href="#测试数据生成" class="headerlink" title="测试数据生成"></a>测试数据生成</h2><p>评估 RAG 应用需要用到几个评估实体，分别是：</p><ul><li>Question: 指用户输入的问题，RAG 应用通过问题检索到相关的文档上下文</li><li>Context: 指检索到的文档上下文，RAG 应用检索到相关文档后会将这些上下文结合用户问题一起提交给 LLM，最后生成答案</li><li>Answer: 指生成的答案，RAG 应用将问题和上下文提交给 LLM 后，LLM 会根据这些信息来生成答案</li><li>Grouth Truth: 指人工标注的正确答案，利用这个实体可以对生成的答案进行分析，从而得到评估结果，在 LlamaIndex 中，这个实体叫做 Reference Answer</li></ul><p>其中 Question 和 Ground Truth 通过用户提供，Context 通过检索得到，Answer 是由 LLM 生成，后面我们在讲解的时候会沿用这些实体名称。在 LlamaIndex 中提供了生成测试数据集的功能，可以帮助我们快速生成测试数据集，无需人工干预。</p><p>首先我们来看下如何生成评估所需的 Question，这里的测试文档使用维基百科上的<a href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> SimpleDirectoryReader</span><br><span class="line"><span class="keyword">from</span> llama_index.core.llama_dataset.generator <span class="keyword">import</span> RagDatasetGenerator</span><br><span class="line"><span class="keyword">from</span> llama_index.llms.openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">llm = OpenAI(model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>)</span><br><span class="line">dataset_generator = RagDatasetGenerator.from_documents(</span><br><span class="line">    documents,</span><br><span class="line">    llm=llm,</span><br><span class="line">    num_questions_per_chunk=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line">dataset = dataset_generator.generate_questions_from_nodes()</span><br><span class="line">examples = dataset.examples</span><br><span class="line"><span class="keyword">for</span> i, example <span class="keyword">in</span> <span class="built_in">enumerate</span>(examples):</span><br><span class="line">    contexts = [n[:<span class="number">100</span>] <span class="keyword">for</span> n <span class="keyword">in</span> example.reference_contexts]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>. <span class="subst">&#123;example.query&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="number">1.</span> Question: How did Ultron initially come into existence <span class="keyword">and</span> what was his ultimate goal?</span><br><span class="line"><span class="number">2.</span> Question: What event prompts the Avengers to devise a plan involving time travel to undo Thanos<span class="string">&#x27;s actions in &quot;Avengers: Endgame&quot;?</span></span><br><span class="line"><span class="string">3. Question: How does Thanos acquire the Power Stone and what events transpire after he obtains it?</span></span><br><span class="line"><span class="string">4. Question: How does Thanos ultimately achieve his goal of completing the Gauntlet and causing half of all life across the universe to disintegrate in &quot;Avengers: Infinity War&quot;?</span></span><br><span class="line"><span class="string">5. Question: How does Loki initially gain access to Earth and what is his ultimate goal upon arriving?</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>SimpleDirectoryReader</code>读取文档</li><li>LlamaIndex 在新版本中推荐使用<code>RagDatasetGenerator</code>来生成测试数据，参数<code>documents</code>表示读取的文档列表，<code>llm</code>表示使用的大语言模型， 这里我们使用 OpenAI 的<code>gpt3.5</code>模型，<code>num_questions_per_chunk</code>表示每个文档生成的问题数量，这里我们设置为 1</li><li>然后调用数据生成器的<code>generate_questions_from_nodes</code>方法生成问题集，其原理是用 LLM 来根据文档生成问题，生成后的数据保存在<code>examples</code>属性中</li><li>最后遍历<code>examples</code> 对象，生成的 Question 在<code>example.query</code> 属性中</li><li>从显示结果中可以看到生成了 5 个 Question</li></ul><p>除了生成 Question 外，数据生成器还可以生成 Ground Truth，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dataset = dataset_generator.generate_dataset_from_nodes()</span><br><span class="line">examples = dataset.examples</span><br><span class="line"><span class="keyword">for</span> i, example <span class="keyword">in</span> <span class="built_in">enumerate</span>(examples):</span><br><span class="line">    contexts = [n[:<span class="number">100</span>] <span class="keyword">for</span> n <span class="keyword">in</span> example.reference_contexts]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>. <span class="subst">&#123;example.query&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Ground Truth: <span class="subst">&#123;example.reference_answer[:<span class="number">100</span>]&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="number">1.</span> Question: How did Ultron initially come into existence <span class="keyword">and</span> what was his ultimate goal?</span><br><span class="line">Ground Truth: Ultron initially came into existence when Tony Stark <span class="keyword">and</span> Bruce Banner discovered an artificial intel...</span><br><span class="line"><span class="number">2.</span> Question: What event prompts the Avengers to devise a plan involving time travel to undo Thanos<span class="string">&#x27;s actions in &quot;Avengers: Endgame&quot;?</span></span><br><span class="line"><span class="string">Ground Truth: The event that prompts the Avengers to devise a plan involving time travel to undo Thanos&#x27;</span>s actions ...</span><br><span class="line"><span class="number">3.</span> Question: How does Thanos acquire the Power Stone <span class="keyword">and</span> what events transpire after he obtains it?</span><br><span class="line">Ground Truth: Thanos acquires the Power Stone <span class="keyword">from</span> the planet Xandar. After obtaining the Power Stone, Thanos <span class="keyword">and</span> ...</span><br><span class="line"><span class="number">4.</span> Question: How does Thanos ultimately achieve his goal of completing the Gauntlet <span class="keyword">and</span> causing half of <span class="built_in">all</span> life across the universe to disintegrate <span class="keyword">in</span> <span class="string">&quot;Avengers: Infinity War&quot;</span>?</span><br><span class="line">Ground Truth: Thanos ultimately achieves his goal of completing the Gauntlet <span class="keyword">and</span> causing half of <span class="built_in">all</span> life across t...</span><br><span class="line"><span class="number">5.</span> Question: How does Loki initially gain access to Earth <span class="keyword">and</span> what <span class="keyword">is</span> his ultimate goal upon arriving?</span><br><span class="line">Ground Truth: Loki initially gains access to Earth by using the Tesseract to <span class="built_in">open</span> a wormhole. His ultimate goal up...</span><br></pre></td></tr></table></figure><p>这次使用数据生成器的<code>generate_dataset_from_nodes</code>方法来生成测试数据，生成的数据不仅包含 Question，还包含 Ground Truth，也是就代码中的<code>example.reference_answer</code>属性的值。其实除了 Question 和 Ground Truth 外，在生成的数据中还包含<code>reference_contexts</code>，这是数据生成器使用其内部检索器检索到的上下文，这个数据暂时对我们没有用处，我们只需要关注 Question 和 Ground Truth 即可。</p><h3 id="将数据集保存到-json-文件"><a href="#将数据集保存到-json-文件" class="headerlink" title="将数据集保存到 json 文件"></a>将数据集保存到 json 文件</h3><p>每次运行程序都重新生成一遍测试数据比较耗费资源，我们可以将生成的数据集保存到 json 文件中，下次直接读取 json 文件即可，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> llama_index.core.llama_dataset.rag <span class="keyword">import</span> LabelledRagDataset</span><br><span class="line"></span><br><span class="line">dataset_json = <span class="string">&quot;./output/test-dataset.json&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dataset_json):</span><br><span class="line">    dataset = dataset_generator.generate_dataset_from_nodes()</span><br><span class="line">    examples = dataset.examples</span><br><span class="line">    dataset.save_json(dataset_json)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dataset = LabelledRagDataset.from_json(dataset_json)</span><br><span class="line">    examples = dataset.examples</span><br></pre></td></tr></table></figure><ul><li>保存数据时使用<code>dataset</code>对象的<code>save_json</code>方法</li><li>读取数据时使用<code>LabelledRagDataset</code>的<code>from_json</code>方法</li></ul><h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>下面我们来详细介绍 LlamaIndex 的评估指标，并通过代码示例来了解如何使用这些评估指标。</p><h3 id="Answer-Relevcancy"><a href="#Answer-Relevcancy" class="headerlink" title="Answer Relevcancy"></a>Answer Relevcancy</h3><p>Answer Revelancy 是评估 Answer 和 Question 的相关性，这个指标可以帮助我们评估生成的答案是否和问题相关，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> AnswerRelevancyEvaluator</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, Settings</span><br><span class="line"><span class="keyword">from</span> llama_index.core.node_parser <span class="keyword">import</span> SentenceSplitter</span><br><span class="line"></span><br><span class="line">question = examples[<span class="number">0</span>].query</span><br><span class="line"></span><br><span class="line">node_parser = SentenceSplitter()</span><br><span class="line">nodes = node_parser.get_nodes_from_documents(documents)</span><br><span class="line">Settings.llm = llm</span><br><span class="line">vector_index = VectorStoreIndex(nodes)</span><br><span class="line">engine = vector_index.as_query_engine()</span><br><span class="line">response = engine.query(question)</span><br><span class="line">answer = <span class="built_in">str</span>(response)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;question&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">evaluator = AnswerRelevancyEvaluator(llm)</span><br><span class="line">result = evaluator.evaluate(query=question, response=answer)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;result.score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;result.feedback&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Question: How did Ultron initially come into existence <span class="keyword">and</span> what was his ultimate goal?</span><br><span class="line">Answer: Ultron initially came into existence when Tony Stark <span class="keyword">and</span> Bruce Banner discovered an artificial intelligence within Loki<span class="string">&#x27;s scepter and decided to use it to complete Stark&#x27;</span>s <span class="string">&quot;Ultron&quot;</span> <span class="keyword">global</span> defense program. Ultron<span class="string">&#x27;s ultimate goal was to eradicate humanity in order to save Earth.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">score: 1.0</span></span><br><span class="line"><span class="string">feedback: 1. The provided response matches the subject matter of the user&#x27;</span>s query by explaining how Ultron initially came into existence <span class="keyword">and</span> what his ultimate goal was.</span><br><span class="line"><span class="number">2.</span> The response directly addresses the focus <span class="keyword">and</span> perspective of the use<span class="string">r&#x27;s query by detailing the specific events that led to Ultron&#x27;</span>s creation <span class="keyword">and</span> his ultimate goal of eradicating humanity.</span><br><span class="line"></span><br><span class="line">[RESULT] <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>我们使用测试数据集的第一条数据的问题作为评估问题</li><li>然后构建一个普通的 RAG 查询引擎，并通过查询评估问题来得到答案</li><li>将问题和答案传递给<code>AnswerRelevancyEvaluator</code>评估器，通过<code>evaluate</code>方法来评估问题和答案的相关性</li><li>评估结果的<code>score</code>范围是 0~1，得分越高表示答案和问题的相关性越高，得分为 1 表示完全相关</li><li>评估结果中还有<code>feedback</code>属性，用来解释评估结果，这个属性可以帮助我们了解评估结果的产生原因</li></ul><p>LlamaIndex 中每种评估器的初始化参数都基本一致，以<code>AnswerRelevancyEvaluator</code> 为例， 有以下主要参数：</p><ul><li>llm: 评估使用的大语言模型</li><li>eval_template: 评估时所用的提示词模板</li><li>score_threshold: 这个参数在不同的评估器中有不同的含义，在<code>AnswerRelevancyEvaluator</code> 中这个参数用来将反馈中的分数转换到 0~1 范围，在<code>CorrectnessEvaluator</code> 中这个参数用来评判答案是否正确</li></ul><p>在上面的反馈结果中我们可以看到<code>[RESULT] 2</code>，这个值就是反馈中的分数，LLM 在评估过程中评估了 2 个问题，每个问题回答正确则得 1 分，从得分结果来看，2 个问题都回答正确，所以得分为 2，然后除以阀值 2.0，得到最终分数为 1.0。</p><h4 id="评估提示词模板修改"><a href="#评估提示词模板修改" class="headerlink" title="评估提示词模板修改"></a>评估提示词模板修改</h4><p><code>eval_template</code>参数用来设置评估提示词模板，我们可以来看下<code>AnswerRelevancyEvaluator</code>默认的评估提示词：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">DEFAULT_EVAL_TEMPLATE = PromptTemplate(</span><br><span class="line">    <span class="string">&quot;Your task is to evaluate if the response is relevant to the query.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The evaluation should be performed in a step-by-step manner by answering the following questions:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;1. Does the provided response match the subject matter of the user&#x27;s query?\n&quot;</span></span><br><span class="line">    <span class="string">&quot;2. Does the provided response attempt to address the focus or perspective &quot;</span></span><br><span class="line">    <span class="string">&quot;on the subject matter taken on by the user&#x27;s query?\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Each question above is worth 1 point. Provide detailed feedback on response according to the criteria questions above  &quot;</span></span><br><span class="line">    <span class="string">&quot;After your feedback provide a final result by strictly following this format: &#x27;[RESULT] followed by the integer number representing the total score assigned to the response&#x27;\n\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Query: \n &#123;query&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Response: \n &#123;response&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Feedback:&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>评估提示词模板是一个<code>PromptTemplate</code>对象，这个对象有一个<code>template</code>属性，这个属性就是评估提示词模板的字符串内容，如果我们想要修改评估提示词，一种方法是重新写一套评估提示词指令，另外一种方法是在这个模板的前面或后面添加提示词来对评估指令进行微调，比如我想让 LLM 将评估结果用中文回复，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation.answer_relevancy <span class="keyword">import</span> DEFAULT_EVAL_TEMPLATE</span><br><span class="line"></span><br><span class="line">translate_prompt = <span class="string">&quot;\n\nPlease reply in Chinese.&quot;</span></span><br><span class="line">eval_template = DEFAULT_EVAL_TEMPLATE</span><br><span class="line">eval_template.template += translate_prompt</span><br><span class="line">evaluator = AnswerRelevancyEvaluator(</span><br><span class="line">    llm=llm, eval_template=eval_template</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们在<code>AnswerRelevancyEvaluator</code>的默认提示词模板上添加了返回中文回复的提示词，然后通过<code>eval_template</code>参数传递给评估器，这样评估器在评估任务完成后就会将评估结果用中文返回。</p><h3 id="Context-Relevancy"><a href="#Context-Relevancy" class="headerlink" title="Context Relevancy"></a>Context Relevancy</h3><p>Context Relevancy 是评估 Context 和 Question 的相关性，这个指标可以帮助我们评估检索到的文档上下文和问题的相关性，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> ContextRelevancyEvaluator</span><br><span class="line"></span><br><span class="line">contexts = [n.get_content() <span class="keyword">for</span> n <span class="keyword">in</span> response.source_nodes]</span><br><span class="line">evaluator = ContextRelevancyEvaluator(llm)</span><br><span class="line">result = evaluator.evaluate(query=question, contexts=contexts)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;result.score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;result.feedback&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">score: <span class="number">1.0</span></span><br><span class="line">feedback: <span class="number">1.</span> The retrieved context matches the subject matter of the use<span class="string">r&#x27;s query. It provides a detailed explanation of how Ultron initially came into existence and what his ultimate goal was.</span></span><br><span class="line"><span class="string">2. The retrieved context can be used exclusively to provide a full answer to the user&#x27;</span>s query. It covers <span class="built_in">all</span> the necessary information about Ultron<span class="string">&#x27;s creation and his goal to eradicate humanity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[RESULT] 4.0</span></span><br></pre></td></tr></table></figure><ul><li>我们通过查询引擎返回的结果<code>response</code>中的<code>source_nodes</code>属性获取到 Context，并将其转化为字符串列表，评估时需要这种格式的数据</li><li>构建<code>ContextRelevancyEvaluator</code>评估器</li><li>将 Question 和 Context 传递给评估器的<code>evaluate</code>方法进行评估</li><li>最后输出评估结果</li></ul><p>从评估结果中可以看到，评估器评估了 2 个问题，每个问题得分 2，最终得分为 4，这个得分是通过评估器内部的评估模板计算出来的，分数经过转换后得到 score 为 1.0。</p><p>在评估结果中除了<code>score</code>和<code>feedback</code>属性外，还有其他一些属性：</p><ul><li>query: 评估的问题，也就是 Question</li><li>contexts: 评估的上下文，也就是 Context</li><li>response: 评估的回答，也就是 Answer</li><li>passing: 是否通过，如果评估结果通过则为 True，否则为 False，在一些评估器中这个属性和评估器的<code>score_threshold</code>属性有关</li><li>pairwise_source: 对比评估源，这是对比评估才有的属性，后面会详细介绍</li></ul><h3 id="Relevancy"><a href="#Relevancy" class="headerlink" title="Relevancy"></a>Relevancy</h3><p>Relevancy 是评估 Answer、Context 与 Question 是否相关，这个指标可以帮助我们评估问题是否真正得到了回答，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> AnswerRelevancyEvaluator</span><br><span class="line"></span><br><span class="line">evaluator = RelevancyEvaluator(llm)</span><br><span class="line">result = evaluator.evaluate(query=question, response=answer, contexts=contexts)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;result.score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;result.feedback&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;passing: <span class="subst">&#123;result.passing&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">score: <span class="number">1.0</span></span><br><span class="line">feedback: YES</span><br><span class="line">passing: <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>构建<code>RelevancyEvaluator</code>评估器</li><li>这个评估器需要传递 Question、Answer 和 Context 三个参数进行评估</li><li>最后输出评估结果</li></ul><p>因为这个评估是检查 Answer 和 Context 是否与 Question 相关， 因此评估结果是一个布尔值， 当<code>feedback</code>为<code>YES</code>表示 Answer、Context 与 Question 相关，同时<code>passing</code>为<code>True</code>，<code>score</code>为 1.0。</p><h3 id="Faithfulness"><a href="#Faithfulness" class="headerlink" title="Faithfulness"></a>Faithfulness</h3><p>Faithfulness 是评估 Answer 和 Context 是否匹配，这个指标可以帮助我们评估生成的答案是否符合上下文，检查答案是否有<strong>幻觉</strong>，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> FaithfulnessEvaluator</span><br><span class="line"></span><br><span class="line">evaluator = FaithfulnessEvaluator(llm)</span><br><span class="line">result = evaluator.evaluate(response=answer, contexts=contexts)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;result.score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;result.feedback&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;passing: <span class="subst">&#123;result.passing&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">score: <span class="number">1.0</span></span><br><span class="line">feedback: YES</span><br><span class="line">passing: <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>构建<code>FaithfulnessEvaluator</code>评估器</li><li>这个评估器需要传递 Answer 和 Context 两个参数进行评估</li><li>最后输出评估结果，评估结果也是一个布尔值，当<code>feedback</code>为<code>YES</code>表示两者相关， 同时<code>passing</code>为<code>True</code>，<code>score</code>为 1.0</li></ul><p>LlamaIndex 的评估工具不仅可以对检索引擎进行评估，还可以对 Pipeline 进行评估，只要将 Pipeline 的输出结果作为评估的参数即可：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> QueryPipeline, InputComponent</span><br><span class="line"><span class="keyword">from</span> llama_index.core.response_synthesizers.simple_summarize <span class="keyword">import</span> SimpleSummarize</span><br><span class="line"></span><br><span class="line">p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;retriever&quot;</span>: retriever,</span><br><span class="line">        <span class="string">&quot;output&quot;</span>: SimpleSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;retriever&quot;</span>)</span><br><span class="line">p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;query_str&quot;</span>)</span><br><span class="line">p.add_link(<span class="string">&quot;retriever&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;nodes&quot;</span>)</span><br><span class="line">output = p.run(<span class="built_in">input</span>=question)</span><br><span class="line">answer = <span class="built_in">str</span>(output)</span><br><span class="line">contexts = [n.get_content() <span class="keyword">for</span> n <span class="keyword">in</span> output.source_nodes]</span><br></pre></td></tr></table></figure><p>我们创建一个基本的 RAG Pipeline， 然后使用 Pipeline 来代替检索引擎进行问题检索和回答生成，最后将得到的 Answer 和 Context 传递给评估器进行评估即可。关于<code>Pipeline</code>的更多介绍可以参考我之前的<a href="https://zhaozhiming.github.io/2024/06/08/rag-module-pipeline/">这篇文章</a>。</p><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><p>Correctness 是评估 Answer 和 Ground Truth 的相关性和正确性，这个指标可以帮助我们评估生成的答案是否正确，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> CorrectnessEvaluator</span><br><span class="line"></span><br><span class="line">evaluator = CorrectnessEvaluator(llm)</span><br><span class="line">ground_truth = dataset_examples[<span class="number">1</span>].reference_answer</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;question&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ground Truth: <span class="subst">&#123;ground_truth&#125;</span>&quot;</span>)</span><br><span class="line">result = evaluator.evaluate(query=question, response=answer, reference=ground_truth)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;result.score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;result.feedback&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;passing: <span class="subst">&#123;result.passing&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Question: What event prompts the Avengers to devise a plan involving time travel to undo Thanos<span class="string">&#x27;s actions in &quot;Avengers: Endgame&quot;?</span></span><br><span class="line"><span class="string">Answer: The event that prompts the Avengers to devise a plan involving time travel to undo Thanos&#x27;</span>s actions <span class="keyword">in</span> <span class="string">&quot;Avengers: Endgame&quot;</span> occurs when Scott Lang escapes <span class="keyword">from</span> the Quantum Realm <span class="keyword">and</span> reaches the Avengers Compound. He explains that he experienced only five hours <span class="keyword">while</span> trapped, despite being there <span class="keyword">for</span> five years. This leads to the realization that the Quantum Realm allows <span class="keyword">for</span> time travel, prompting the Avengers to ask Tony Stark to <span class="built_in">help</span> them retrieve the Infinity Stones <span class="keyword">from</span> the past to reverse Thanos<span class="string">&#x27;s actions in the present.</span></span><br><span class="line"><span class="string">Ground Truth: The event that prompts the Avengers to devise a plan involving time travel to undo Thanos&#x27;</span>s actions <span class="keyword">in</span> <span class="string">&quot;Avengers: Endgame&quot;</span> <span class="keyword">is</span> the discovery that Thanos has already destroyed the Infinity Stones, preventing <span class="built_in">any</span> further use to reverse his actions.</span><br><span class="line"></span><br><span class="line">score: <span class="number">4.0</span></span><br><span class="line">feedback: The generated answer <span class="keyword">is</span> relevant <span class="keyword">and</span> mostly correct <span class="keyword">in</span> detailing the events leading to the Avengers<span class="string">&#x27; decision to use time travel in &quot;Avengers: Endgame.&quot; It accurately describes Scott Lang&#x27;</span>s escape <span class="keyword">from</span> the Quantum Realm <span class="keyword">and</span> his crucial role <span class="keyword">in</span> introducing the concept of time manipulation via the Quantum Realm. However, it slightly deviates <span class="keyword">from</span> the reference answer, which emphasizes the destruction of the Infinity Stones by Thanos <span class="keyword">as</span> the critical event. The generated answer instead focuses on the discovery of time travel <span class="keyword">as</span> a viable option, which <span class="keyword">is</span> also a correct perspective but <span class="keyword">not</span> the only one. Thus, the score reflects high relevance <span class="keyword">and</span> correctness <span class="keyword">with</span> a minor deviation <span class="keyword">in</span> focus.</span><br><span class="line">passing: <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>构建<code>CorrectnessEvaluator</code>评估器</li><li>使用我们之前创建的测试数据集中某条数据的<code>reference_answer</code>作为 Ground Truth</li><li>将 Question、Answer 和 Ground Truth 传递给评估器的<code>evaluate</code>方法进行评估</li></ul><p><code>CorrectnessEvaluator</code>评估器的得分范围是 1 ～ 5，当分数大于等于 4 时表示答案正确，<code>passing</code>为<code>True</code>，评估器根据 Qustion、Answer 和 Ground Truth 进行评估，最后输出评估结果。</p><h3 id="Pairwise"><a href="#Pairwise" class="headerlink" title="Pairwise"></a>Pairwise</h3><p>Pairwise 是对比评估，可以帮助我们评估两个检索引擎生成的 Answer 哪个更好，在执行对比评估之前，我们需要再构建一个检索引擎，这个检索引擎我们使用不同的文档分块策略，这样才可以与之前的检索引擎进行区分，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">node_parser = SentenceSplitter(chunk_size=<span class="number">128</span>, chunk_overlap=<span class="number">25</span>)</span><br><span class="line">nodes = node_parser.get_nodes_from_documents(documents)</span><br><span class="line">Settings.llm = llm</span><br><span class="line">vector_index = VectorStoreIndex(nodes)</span><br><span class="line">second_engine = vector_index.as_query_engine()</span><br><span class="line">second_response = engine.query(question)</span><br><span class="line">second_answer = <span class="built_in">str</span>(second_response)</span><br></pre></td></tr></table></figure><ul><li>原来的检索引擎<code>engine</code>使用的是<code>SentenceSplitter</code>文档分割器默认的分块策略，<code>chunk_size</code>为 1024，<code>chunk_overlap</code>为 200</li><li>我们新建了另外一个检索引擎<code>second_engine</code>，并将文档分割器的<code>chunk_size</code>设置为 128，<code>chunk_overlap</code>设置为 25</li><li>然后使用<code>second_engine</code>来查询问题，得到另一个答案<code>second_answer</code></li></ul><p>然后我们使用<code>PairwiseEvaluator</code>评估器来对比两个答案，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> PairwiseComparisonEvaluator</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;question&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Second Answer: <span class="subst">&#123;second_answer&#125;</span>&quot;</span>)</span><br><span class="line">evaluator = PairwiseComparisonEvaluator(llm)</span><br><span class="line">result = evaluator.evaluate(</span><br><span class="line">    query=question, response=answer, second_response=second_answer</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;result.score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;result.feedback&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;pairwise source: <span class="subst">&#123;<span class="built_in">str</span>(result.pairwise_source)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Question: What event prompts the Avengers to devise a plan involving time travel to undo Thanos<span class="string">&#x27;s actions in &quot;Avengers: Endgame&quot;?</span></span><br><span class="line"><span class="string">Answer: The event that prompts the Avengers to devise a plan involving time travel to undo Thanos&#x27;</span>s actions <span class="keyword">in</span> <span class="string">&quot;Avengers: Endgame&quot;</span> <span class="keyword">is</span> the discovery that Thanos has already destroyed the Infinity Stones, preventing <span class="built_in">any</span> further use to reverse his actions.</span><br><span class="line">Second Answer: The destruction of the Infinity Stones by Thanos prompts the Avengers to devise a plan involving time travel to undo Thanos<span class="string">&#x27;s actions in &quot;Avengers: Endgame&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">score: 1.0</span></span><br><span class="line"><span class="string">feedback: Assistant A provides a more detailed and informative response by explaining that the Avengers discover that Thanos has already destroyed the Infinity Stones, which is the event that prompts them to devise a plan involving time travel to undo his actions in &quot;Avengers: Endgame.&quot; This additional context enhances the understanding of the situation and the motivation behind the Avengers&#x27;</span> plan. Assistant B, on the other hand, simply states that the destruction of the Infinity Stones by Thanos <span class="keyword">is</span> the event that leads to the Avengers<span class="string">&#x27; plan without providing any further elaboration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Therefore, based on the level of detail and clarity provided in the responses, [[A]] Assistant A is better.</span></span><br><span class="line"><span class="string">pairwise source: EvaluationSource.ORIGINAL</span></span><br></pre></td></tr></table></figure><ul><li>构建<code>PairwiseComparisonEvaluator</code>评估器</li><li>将 Question、Answer 和 Second Answer 传递给评估器的<code>evaluate</code>方法进行评估</li></ul><p>在显示结果中，我们打印了 Question、Answer 和 Second Answer，以及评估结果的几个属性，从评估结果中可以看到，第一个 Answer 比第二个 Answer 更好。在评估结果中还有一个<code>pairwise_source</code>属性，值是<code>EvaluationSource.ORIGINAL</code>，表示评估顺序是原始顺序。</p><p>在 <code>PairwiseComparisonEvaluator</code>评估器中，有一个初始化参数<code>enforce_consensus</code>，默认值是 True。在评估器进行对比评估时，首先会将 Answer 和 Second Answer 进行对比， 即<code>evaluate(response=answer, second_response=second_answer)</code>，如果<code>enforce_consensus</code>为 True，<strong>则会将 Answer 和 Second Answer 反过来再进行对比</strong>， 即<code>evaluate(response=second_answer, second_response=answer)</code>， 最后根据两次结果来产生最终的评估结果。如果最终结果使用的是反转后的结果，那么<code>pairwise source</code>的值就是<code>EvaluationSource.FLIPPED</code>。</p><p>可以看下另外一种对比结果，在下面的评估结果中，2 个 Answer 的得分一样，评估结果是平局：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score: 0.5</span><br><span class="line">feedback: Both Assistant A and Assistant B provided the same answer to the user<span class="string">&#x27;s question, stating that Tony Stark and Bruce Banner are the two members of the Avengers who created Ultron. Since both responses are identical in terms of accuracy and relevance to the user&#x27;</span>s question, there is no significant difference between the two answers. Therefore, <span class="keyword">in</span> this <span class="keyword">case</span>, it is a tie between Assistant A and Assistant B.</span><br><span class="line"></span><br><span class="line">Therefore, the final verdict is <span class="string">&#x27;[[C]]&#x27;</span> <span class="keyword">for</span> a tie.</span><br><span class="line">pairwise_source: EvaluationSource.ORIGINAL</span><br></pre></td></tr></table></figure><h2 id="批量评估"><a href="#批量评估" class="headerlink" title="批量评估"></a>批量评估</h2><p>介绍完了 LlamaIndex 的评估指标后，有人可能会担心如果一次性运行这么多评估指标，那么运行时间会不会很长，其实不用担心，LlamaIndex 很贴心地提供了一个批量评估的工具，可以帮助我们快速地运行多个评估指标，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.evaluation <span class="keyword">import</span> BatchEvalRunner</span><br><span class="line"></span><br><span class="line">answer_relevancy_evaluator = AnswerRelevancyEvaluator(llm)</span><br><span class="line">context_relevancy_evaluator = ContextRelevancyEvaluator(llm)</span><br><span class="line">relevant_evaluator = RelevancyEvaluator(llm)</span><br><span class="line">correctness_evaluator = CorrectnessEvaluator(llm)</span><br><span class="line">faithfulness_evaluator = FaithfulnessEvaluator(llm)</span><br><span class="line"></span><br><span class="line">runner = BatchEvalRunner(</span><br><span class="line">    evaluators=&#123;</span><br><span class="line">        <span class="string">&quot;answer_relevancy&quot;</span>: answer_relevancy_evaluator,</span><br><span class="line">        <span class="string">&quot;context_relevancy&quot;</span>: context_relevancy_evaluator,</span><br><span class="line">        <span class="string">&quot;relevancy&quot;</span>: relevant_evaluator,</span><br><span class="line">        <span class="string">&quot;correctness&quot;</span>: correctness_evaluator,</span><br><span class="line">        <span class="string">&quot;faithfulness&quot;</span>: faithfulness_evaluator,</span><br><span class="line">    &#125;,</span><br><span class="line">    workers=<span class="number">8</span>,</span><br><span class="line">)</span><br><span class="line">questions = [example.query <span class="keyword">for</span> example <span class="keyword">in</span> examples]</span><br><span class="line">ground_truths = [example.reference_answer <span class="keyword">for</span> example <span class="keyword">in</span> examples]</span><br><span class="line">metrics_results = runner.evaluate_queries(</span><br><span class="line">    engine, queries=questions, reference=ground_truths</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> metrics <span class="keyword">in</span> metrics_results.keys():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;metrics: <span class="subst">&#123;metrics&#125;</span>&quot;</span>)</span><br><span class="line">    eval_results = metrics_results[metrics]</span><br><span class="line">    <span class="keyword">for</span> eval_result <span class="keyword">in</span> eval_results:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;score: <span class="subst">&#123;eval_result.score&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;feedback: <span class="subst">&#123;eval_result.feedback&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> eval_result.passing <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;passing: <span class="subst">&#123;eval_result.passing&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">metrics: answer_relevancy</span><br><span class="line">score: <span class="number">1.0</span></span><br><span class="line">feedback: <span class="number">1.</span> The provided response matches the subject matter of the use<span class="string">r&#x27;s query by explaining how Ultron initially came into existence and what his ultimate goal was.</span></span><br><span class="line"><span class="string">2. The response directly addresses the focus and perspective of the user&#x27;</span>s query by detailing the specific events that led to Ultron<span class="string">&#x27;s creation and his ultimate goal of eradicating humanity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[RESULT] 2</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><ul><li>我们首先创建了 5 个评估器，分别是<code>AnswerRelevancyEvaluator</code>、<code>ContextRelevancyEvaluator</code>、<code>RelevancyEvaluator</code>、<code>CorrectnessEvaluator</code>、<code>FaithfulnessEvaluator</code></li><li>然后通过测试数据集提取了 Question 列表<code>questions</code>和 Ground Truth 列表<code>ground_truths</code>，每个列表分别有 5 个元素</li><li>使用<code>BatchEvalRunner</code>构建一个批量评估运行器，初始化参数<code>evaluators</code>为 5 个评估器，<code>workers</code>参数表示并行运行的工作线程数，<code>workers</code>的数量可以根据运行机器上的 CPU 核数来决定</li><li>调用<code>aevaluate_queries</code>方法来运行评估，传递的参数是查询引擎、Question 列表和 Ground Truth 列表</li><li>评估结果最后会根据评估器名称保存在<code>metrics_results</code>字典中，我们遍历这个字典，输出评估结果</li></ul><p>5 个评估器加上 5 个问题，相当于我们执行了 25 次评估，但执行时间和运行单次评估的时间基本相同，但需要注意的是，<code>BatchEvalRunner</code>只能在检索引擎下使用，不能通过 Pipeline 使用。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>LlamaIndex 内置的评估工具有以下优缺点。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>不需要额外安装第三方库，可以快速使用</li><li>评估指标可以满足大部分评估需求</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>评估方法基本上是通过 LLM 加提示词的方式来评估，评估使用的 LLM 不同，可能评估效果差别也会比较大，其他 RAG 评估工具会使用一些计算公式来结合提示词进行评估，从而减小 LLM 的影响</li><li>是 LlamaIndex 内置的功能，这是优点也是缺点，毕竟评估功能与其他 RAG 功能相比重要性较低，以后随着 LlamaIndex 更多新功能的加入，评估功能的开发优先级可能会降低</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体而言，LlamaIndex 的评估功能可以帮助我们快速地评估 RAG 的性能，满足我们基本的 RAG 评估需求，无需借助其他第三方库。如果你正在使用 LlamaIndex 开发 RAG 应用，建议使用 LlamaIndex 内置的评估工具，使用后如果发现满足不了需求再考虑使用其他第三方评估工具。希望这篇文章可以帮助大家更好地了解 LlamaIndex 的评估功能。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍如何使用 LlamaIndex 内置评估工具进行 RAG 应用评估</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="evaluation" scheme="https://zhaozhiming.github.io/tags/evaluation/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之流程与模块化</title>
    <link href="https://zhaozhiming.github.io/2024/06/08/rag-module-pipeline/"/>
    <id>https://zhaozhiming.github.io/2024/06/08/rag-module-pipeline/</id>
    <published>2024-06-08T12:54:26.000Z</published>
    <updated>2024-10-03T08:49:29.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/06/rag-module-flow.jpg" class="" width="400" height="300"><p>我们介绍了很多关于高级 RAG（Retrieval Augmented Generation）的检索策略，每一种策略就像是机器中的零部件，我们可以通过对这些零部件进行不同的组合，来实现不同的 RAG 功能，从而满足不同的需求。今天我们就来介绍高级 RAG 检索中一些常见的 RAG 模块，以及如何通过流程的方式来组合这些模块，实现高级 RAG 检索功能。</p><span id="more"></span><h2 id="RAG-模块化"><a href="#RAG-模块化" class="headerlink" title="RAG 模块化"></a>RAG 模块化</h2><p>模块化 RAG 提出了一种高度可扩展的范例，将 RAG 系统分为模块类型、模块和操作符的三层结构。每个模块类型代表 RAG 系统中的一个核心流程，包含多个功能模块。每个功能模块又包含多个特定的操作符。整个 RAG 系统变成了多个模块和相应操作符的排列组合，形成了我们所说的 RAG 流程。在流程中，每种模块类型可以选择不同的功能模块，并且在每个功能模块中可以选择一个或多个操作符。</p><img src="/images/post/2024/06/rag-module-intro.jpg" class="" width="1000" height="600"><h2 id="RAG-流程"><a href="#RAG-流程" class="headerlink" title="RAG 流程"></a>RAG 流程</h2><p>RAG 流程是指在 RAG 系统中，从输入查询到输出生成文本的整个工作流程。这个流程通常涉及多个模块和操作符的协同工作，包括但不限于检索器、生成器以及可能的预处理和后处理模块。RAG 流程的设计旨在使得 LLM（大语言模型）能够在生成文本时利用外部知识库或文档集，从而提高回答的准确性和相关性。</p><p>RAG 推理阶段的流程一般分为以下几种模式：</p><ul><li>Sequential: 线性流程，包括高级和简单的 RAG 范式</li><li>Conditional: 基于查询的关键词或语义选择不同的 RAG 路径</li><li>Branching: 包括多个并行分支，分为预检索和后检索的分支结构</li><li>Loop: 包括迭代、递归和自适应检索等多种循环结构</li></ul><p>下图是 Loop 模式的 RAG 流程图：</p><img src="/images/post/2024/06/loop-rag-flow.jpeg" class="" width="1000" height="600"><p>后面我们主要以 Sequential 模式为例，介绍如何通过模块化和流水线的方式来实现高级 RAG 检索功能。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><a href="https://www.llamaindex.ai/">LlamaIndex</a>的查询流水线（Query Pipeline）功能提供了一种模块化的方式来组合 RAG 检索策略。我们可以通过定义不同的模块，然后将这些模块按照一定的顺序组合起来，形成一个完整的查询流水线。下面我们通过一个从简单到复杂的示例来演示如何使用 LlamaIndex 的查询流水线功能实现高级 RAG 检索。</p><h3 id="普通-RAG"><a href="#普通-RAG" class="headerlink" title="普通 RAG"></a>普通 RAG</h3><p>首先我们定义一个普通 RAG 的流水线，这个流水线包含了 3 个模块，分别是：输入、检索和输出。其中输入模块用于接收用户输入的查询，检索模块用于从知识库中检索相关文档，输出模块用于根据检索结果生成回答。</p><img src="/images/post/2024/06/rag-flow-base.png" class="" width="1000" height="600"><p>在定义查询流水线之前，我们先将我们的测试文档索引入库，这里的测试文档还是用维基百科上的<a href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> llama_index.llms.openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> llama_index.embeddings.openai <span class="keyword">import</span> OpenAIEmbedding</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> (</span><br><span class="line">    Settings,</span><br><span class="line">    SimpleDirectoryReader,</span><br><span class="line">    StorageContext,</span><br><span class="line">    VectorStoreIndex,</span><br><span class="line">    load_index_from_storage,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> llama_index.core.node_parser <span class="keyword">import</span> SentenceSplitter</span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">node_parser = SentenceSplitter()</span><br><span class="line">llm = OpenAI(model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>)</span><br><span class="line">embed_model = OpenAIEmbedding(model=<span class="string">&quot;text-embedding-3-small&quot;</span>)</span><br><span class="line">Settings.llm = llm</span><br><span class="line">Settings.embed_model = embed_model</span><br><span class="line">Settings.node_parser = node_parser</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;storage&quot;</span>):</span><br><span class="line">    index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">    index.set_index_id(<span class="string">&quot;avengers&quot;</span>)</span><br><span class="line">    index.storage_context.persist(<span class="string">&quot;./storage&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    store_context = StorageContext.from_defaults(persist_dir=<span class="string">&quot;./storage&quot;</span>)</span><br><span class="line">    index = load_index_from_storage(</span><br><span class="line">        storage_context=store_context, index_id=<span class="string">&quot;avengers&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ul><li>首先我们通过<code>SimpleDirectoryReader</code>读取<code>./data</code>目录下的文档</li><li>然后我们定义了一个<code>SentenceSplitter</code>用于将文档进行分割</li><li>接着我们使用<code>OpenAI</code>的 LLM 和 Embedding 模型来生成文本和向量，并将他们添加到<code>Settings</code>中</li><li>最后我们将文档索引入库，并将索引保存到<code>./storage</code>目录下，以便后续使用</li></ul><p>接下来我们定义一个普通的 RAG 流水线，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> QueryPipeline, InputComponent</span><br><span class="line"><span class="keyword">from</span> llama_index.core.response_synthesizers.simple_summarize <span class="keyword">import</span> SimpleSummarize</span><br><span class="line"></span><br><span class="line">retriever =  index.as_retriever()</span><br><span class="line">p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: InputComponent(),</span><br><span class="line">        <span class="string">&quot;retriever&quot;</span>: retriever,</span><br><span class="line">        <span class="string">&quot;output&quot;</span>: SimpleSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;retriever&quot;</span>)</span><br><span class="line">p.add_link(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;query_str&quot;</span>)</span><br><span class="line">p.add_link(<span class="string">&quot;retriever&quot;</span>, <span class="string">&quot;output&quot;</span>, dest_key=<span class="string">&quot;nodes&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>我们创建了一个普通检索器<code>retriever</code>，用于从知识库中检索相关文档</li><li>然后创建了一个<code>QueryPipeline</code>对象，这是查询流水线的主体，设置 verbose 参数为 True 用于输出详细信息</li><li>通过<code>QueryPipeline</code>的<code>add_modules</code>方法添加了 3 个模块：<code>input</code>、<code>retriever</code>和<code>output</code></li><li><code>input</code>模块的实现类是<code>InputComponent</code>，这是查询流水线常用的输入组件，<code>retriever</code>模块是我们定义的检索器，<code>output</code>模块的实现类是<code>SimpleSummarize</code>，这是可以将问题和检索结果进行简单总结的输出组件</li><li>接着我们添加模块间的连接关系，<code>add_link</code>方法用于连接模块之间的关系，第一个参数是源模块，第二个参数是目标模块</li><li><code>dest_key</code>参数用于指定目标模块的输入参数，因为<code>output</code>模块有 2 个参数，分别是问题和检索结果，所以我们需要指定<code>dest_key</code>参数，当目标模块只有一个参数时则不需要指定</li><li>在<code>add_link</code>方法中，与<code>dest_key</code>参数对应的是<code>src_key</code>参数，当源模块有多个参数时，我们需要指定<code>src_key</code>参数，反之则不需要。</li></ul><p>查询流水线添加模块和连接关系的方式除了<code>add_modules</code>和<code>add_link</code>方法外，还可以通过<code>add_chain</code>方法添加，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = QueryPipeline(verbose=<span class="literal">True</span>)</span><br><span class="line">p.add_chain([InputComponent(), retriever])</span><br></pre></td></tr></table></figure><p>这种方式可以一次性添加模块与连接关系，但这种方式只能添加单参数的模块，如果模块有多个参数则需要使用<code>add_modules</code>和<code>add_link</code>方法。</p><p>接下来我们再来运行查询流水线，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span></span><br><span class="line">output = p.run(<span class="built_in">input</span>=question)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(output))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果显示</span></span><br><span class="line">&gt; Running module <span class="built_in">input</span> <span class="keyword">with</span> <span class="built_in">input</span>:</span><br><span class="line"><span class="built_in">input</span>: Which two members of the Avengers created Ultron?</span><br><span class="line"></span><br><span class="line">&gt; Running module retriever <span class="keyword">with</span> <span class="built_in">input</span>:</span><br><span class="line"><span class="built_in">input</span>: Which two members of the Avengers created Ultron?</span><br><span class="line"></span><br><span class="line">&gt; Running module output <span class="keyword">with</span> <span class="built_in">input</span>:</span><br><span class="line">query_str: Which two members of the Avengers created Ultron?</span><br><span class="line">nodes: [NodeWithScore(node=TextNode(id_=<span class="string">&#x27;53d32f3a-a2d5-47b1-aa8f-a9679e83e0b0&#x27;</span>, embedding=<span class="literal">None</span>, metadata=&#123;<span class="string">&#x27;file_path&#x27;</span>: <span class="string">&#x27;/data/Avengers:Age-of-Ul...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Bruce Banner and Tony Stark.</span></span><br></pre></td></tr></table></figure><ul><li>使用查询流水线的<code>run</code>方法运行查询流水线，传入问题作为输入参数</li><li>在显示结果中可以看到查询流水线的调试信息，查询流水线首先运行了<code>input</code>模块，然后运行了<code>retriever</code>模块，最后运行了<code>output</code>模块，调试信息还打印了每个模块的输入参数，最后输出了问题的答案</li></ul><h3 id="增加-reranker-模块"><a href="#增加-reranker-模块" class="headerlink" title="增加 reranker 模块"></a>增加 reranker 模块</h3><p>接下来我们在普通 RAG 的基础上增加一个 reranker 模块，用于对检索结果进行重新排序。</p><img src="/images/post/2024/06/rag-flow-rerank.png" class="" width="1000" height="600"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+from llama_index.postprocessor.cohere_rerank import CohereRerank</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+reranker = CohereRerank()</span></span><br><span class="line">p = QueryPipeline(verbose=True)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;input&quot;: InputComponent(),</span><br><span class="line">        &quot;retriever&quot;: retriever,</span><br><span class="line"><span class="addition">+        &quot;reranker&quot;: reranker,</span></span><br><span class="line">        &quot;output&quot;: SimpleSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p.add_link(&quot;input&quot;, &quot;retriever&quot;)</span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;reranker&quot;, dest_key=&quot;query_str&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;retriever&quot;, &quot;reranker&quot;, dest_key=&quot;nodes&quot;)</span></span><br><span class="line">p.add_link(&quot;input&quot;, &quot;output&quot;, dest_key=&quot;query_str&quot;)</span><br><span class="line"><span class="deletion">-p.add_link(&quot;retriever&quot;, &quot;output&quot;, dest_key=&quot;nodes&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;reranker&quot;, &quot;output&quot;, dest_key=&quot;nodes&quot;)</span></span><br></pre></td></tr></table></figure><ul><li>这里我们使用了<a href="https://cohere.com/">Cohere</a>公司的 rerank 功能，在 LlamaIndex 中提供了<code>CohereRerank</code>类用于实现 Cohere 的 rerank 功能</li><li>要使用<code>CohererRerank</code>类，需要先在 Cohere 官网上注册账号并获取 API KEY，并在环境变量中设置<code>COHERE_API_KEY</code>的值：<code>export COHERE_API_KEY=your-cohere-api-key</code></li><li>然后我们在查询流水线中添加一个<code>reranker</code>模块，并将其添加到<code>retriever</code>模块和<code>output</code>模块之间，用于对检索结果进行重新排序</li><li>我们去除原来从<code>retriever</code>模块到<code>output</code>模块的连接关系，增加了<code>retriever</code>模块到<code>reranker</code>模块和<code>reranker</code>模块到<code>output</code>模块的连接关系</li><li><code>reranker</code>模块同样需要 2 个参数，分别是问题和检索结果，这样<code>reranker</code>模块才可以根据问题对检索结果进行重新排序，所以我们需要指定<code>dest_key</code>参数</li></ul><p>查询流水线的运行方法除了<code>run</code>方法外，还有<code>run_with_intermeation</code>方法，这个方法可以获取流水线的中间结果，我们将<code>retriever</code>和<code>rerank</code>模块的中间结果打印出来进行对比，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">output, intermediates = p.run_with_intermediates(<span class="built_in">input</span>=question)</span><br><span class="line">retriever_output = intermediates[<span class="string">&quot;retriever&quot;</span>].outputs[<span class="string">&quot;output&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;retriever output:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> retriever_output:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node id: <span class="subst">&#123;node.node_id&#125;</span>, node score: <span class="subst">&#123;node.score&#125;</span>&quot;</span>)</span><br><span class="line">reranker_output = intermediates[<span class="string">&quot;reranker&quot;</span>].outputs[<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nreranker output:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> reranker_output:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;node id: <span class="subst">&#123;node.node_id&#125;</span>, node score: <span class="subst">&#123;node.score&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">retriever output:</span><br><span class="line">node <span class="built_in">id</span>: 53d32f3a-a2d5-47b1-aa8f-a9679e83e0b0, node score: <span class="number">0.6608391314791646</span></span><br><span class="line">node <span class="built_in">id</span>: dea3844b-789f-46de-a415-df1ef14dda18, node score: <span class="number">0.5313643379538727</span></span><br><span class="line"></span><br><span class="line">reranker output:</span><br><span class="line">node <span class="built_in">id</span>: 53d32f3a-a2d5-47b1-aa8f-a9679e83e0b0, node score: <span class="number">0.9588471</span></span><br><span class="line">node <span class="built_in">id</span>: dea3844b-789f-46de-a415-df1ef14dda18, node score: <span class="number">0.5837967</span></span><br></pre></td></tr></table></figure><ul><li>执行<code>run_with_intermediates</code>方法后返回结果是一个元组，包含了输出结果和中间结果</li><li>要获取某个模块的中间结果，可以通过<code>intermediates</code>变量加上模块 key 进行获取，比如<code>intermediates[&quot;retriever&quot;]</code>是获取检索模块的中间结果</li><li>每个中间结果都有 2 个参数，分别是<code>inputs</code>和<code>outputs</code>，<code>inputs</code>表示模块的输入参数，<code>outputs</code>表示模块的输出参数</li><li><code>inputs</code>和<code>outputs</code>参数类型是字典，比如<code>reranker</code>模块的<code>outputs</code>参数中包含了<code>nodes</code>属性，我们可以这样来获取<code>nodes</code>属性的值：<code>intermediates[&quot;reranker&quot;].outputs[&quot;nodes&quot;]</code></li></ul><h3 id="增加-query-rewrite-模块"><a href="#增加-query-rewrite-模块" class="headerlink" title="增加 query rewrite 模块"></a>增加 query rewrite 模块</h3><p>之前我们在查询流水线中加入了 reranker 模块，相当是对检索结果的<code>后处理</code>操作，现在我们再加入一个 query rewrite 模块，用于对查询问题进行<code>预处理</code>操作。</p><img src="/images/post/2024/06/rag-flow-query-rewrite.png" class="" width="1000" height="600"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+query_rewriter = HydeComponent()</span></span><br><span class="line">p = QueryPipeline(verbose=True)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;input&quot;: InputComponent(),</span><br><span class="line"><span class="addition">+        &quot;query_rewriter&quot;: query_rewriter,</span></span><br><span class="line">        &quot;retriever&quot;: retriever,</span><br><span class="line">        &quot;reranker&quot;: reranker,</span><br><span class="line">        &quot;output&quot;: SimpleSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="deletion">-p.add_link(&quot;input&quot;, &quot;retriever&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;query_rewriter&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;query_rewriter&quot;, &quot;retriever&quot;)</span></span><br><span class="line">p.add_link(&quot;input&quot;, &quot;reranker&quot;, dest_key=&quot;query_str&quot;)</span><br><span class="line">p.add_link(&quot;retriever&quot;, &quot;reranker&quot;, dest_key=&quot;nodes&quot;)</span><br><span class="line">p.add_link(&quot;input&quot;, &quot;output&quot;, dest_key=&quot;query_str&quot;)</span><br><span class="line">p.add_link(&quot;reranker&quot;, &quot;output&quot;, dest_key=&quot;nodes&quot;)</span><br></pre></td></tr></table></figure><ul><li>这里我们定义了一个<code>HydeComponent</code>类用于实现查询重写的功能，使用的是 HyDE（假设性文档向量）查询重写策略，它会根据查询问题生成一个假设性回答，然后使用这个假设性回答去检索文档，从而提高检索的准确性</li><li><code>HydeComponent</code>是一个自定义的查询流水线组件，后面我们再详细介绍它的实现</li><li>我们在原有的查询流水线上增加了一个<code>query_rewriter</code>模块，放在<code>input</code>模块和<code>retriever</code>模块之间，用于对查询问题进行预处理</li><li>我们去除原来从<code>input</code>模块到<code>retriever</code>模块的连接关系，增加了<code>input</code>模块到<code>query_rewriter</code>模块和<code>query_rewriter</code>模块到<code>retriever</code>模块的连接关系</li><li><code>query_rewriter</code>模块只有一个参数，所以不需要指定<code>dest_key</code>参数</li></ul><p>LlamaIndex 的查询流水线提供了自定义组件的功能，我们可以通过继承<code>CustomQueryComponent</code>类来实现自定义组件，下面我们来实现<code>HydeComponent</code>类，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> CustomQueryComponent</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Any</span></span><br><span class="line"><span class="keyword">from</span> llama_index.core.indices.query.query_transform <span class="keyword">import</span> HyDEQueryTransform</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HydeComponent</span>(<span class="title class_ inherited__">CustomQueryComponent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;HyDE query rewrite component.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate_component_inputs</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate component inputs during run_component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;input&quot;</span> <span class="keyword">in</span> <span class="built_in">input</span>, <span class="string">&quot;input is required&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_input_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Input keys dict.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;input&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_output_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run_component</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the component.&quot;&quot;&quot;</span></span><br><span class="line">        hyde = HyDEQueryTransform(include_original=<span class="literal">True</span>)</span><br><span class="line">        query_bundle = hyde(kwargs[<span class="string">&quot;input&quot;</span>])</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;output&quot;</span>: query_bundle.embedding_strs[<span class="number">0</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li><code>HydeComponent</code>类中的<code>_validate_component_inputs</code>方法用于验证组件的输入参数，必须实现这个方法，否则会抛出异常</li><li><code>_input_keys</code>和<code>_output_keys</code>属性分别用于定义组件的输入和输出 key 值</li><li><code>_run_component</code>方法用于实现组件的具体功能，这里我们使用<code>HyDEQueryTransform</code>类实现了 HyDE 查询重写功能，将查询问题转换为假设性回答，并返回这个假设性回答</li></ul><p>关于查询重写的更多策略，可以参考我之前的<a href="https://zhaozhiming.github.io/2024/05/13/query-rewrite-rag/">这篇文章</a>。</p><h3 id="替换-output-模块"><a href="#替换-output-模块" class="headerlink" title="替换 output 模块"></a>替换 output 模块</h3><p>在之前的查询流水线中，我们使用的是简单的总结输出组件，现在我们将其替换为树形总结组件，用来提高最终的输出结果。</p><blockquote><p><strong>树形总结</strong>组件以自底向上的方式递归地合并文本块并对其进行总结（即从叶子到根构建一棵树）。<br>具体地说，在每个递归步骤中：</p><ol><li>我们重新打包文本块，使得每个块填充大语言模型的上下文窗口</li><li>如果只有一个块，我们给出最终响应</li><li>否则，我们总结每个块，并递归地总结这些摘要</li></ol></blockquote><img src="/images/post/2024/06/rag-flow-tree-summarize.png" class="" width="1000" height="600"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+from llama_index.core.response_synthesizers.tree_summarize import TreeSummarize</span></span><br><span class="line"></span><br><span class="line">p = QueryPipeline(verbose=True)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;input&quot;: InputComponent(),</span><br><span class="line">        &quot;query_rewriter&quot;: query_rewriter,</span><br><span class="line">        &quot;retriever&quot;: retriever,</span><br><span class="line">        &quot;reranker&quot;: reranker,</span><br><span class="line"><span class="deletion">-        &quot;output&quot;: SimpleSummarize(),</span></span><br><span class="line"><span class="addition">+        &quot;output&quot;: TreeSummarize(),</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>替换<code>output</code>模块的组件比较简单，只需要将原来的<code>SimpleSummarize</code>替换为<code>TreeSummarize</code>即可</li><li><code>TreeSummarize</code>组件的结构和<code>SimpleSummarize</code>组件类似，因此这里我们不需要修改其他模块的连接关系</li></ul><p>查询流水线实际上是一个 DAG（有向无环图），每个模块是图中的一个节点，模块之间的连接关系是图中的边，我们可以通过代码来展示这个图形结构，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyvis.network <span class="keyword">import</span> Network</span><br><span class="line"></span><br><span class="line">net = Network(notebook=<span class="literal">True</span>, cdn_resources=<span class="string">&quot;in_line&quot;</span>, directed=<span class="literal">True</span>)</span><br><span class="line">net.from_nx(p.clean_dag)</span><br><span class="line">net.write_html(<span class="string">&quot;output/pipeline_dag.html&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>我们使用<code>pyvis</code>库来绘制查询流水线的图形结构</li><li><code>Network</code>类用于创建一个网络对象，<code>notebook=True</code>表示在 Jupyter Notebook 中显示，<code>cdn_resources=&quot;in_line&quot;</code>表示使用内联资源，<code>directed=True</code>表示有向图</li><li><code>from_nx</code>方法用于将查询流水线的 DAG 结构转换为网络对象</li><li><code>write_html</code>方法用于将网络对象保存为 HTML 文件，这样我们就可以在浏览器中查看查询流水线的图形结构</li></ul><p>保存后的查询流水线图形结构如下：</p><img src="/images/post/2024/06/pipeline-dag.png" class="" width="1000" height="600"><h3 id="使用句子窗口检索"><a href="#使用句子窗口检索" class="headerlink" title="使用句子窗口检索"></a>使用句子窗口检索</h3><p>在之前的查询流水线中，<code>retriever</code>模块使用的是普通的检索策略，现在我们将其替换为句子窗口检索策略，用于提高检索的准确性。</p><blockquote><p>句子窗口检索的原理：首先在文档切分时，将文档以句子为单位进行切分，同时进行 Embedding 并保存数据库。然后在检索时，通过问题检索到相关的句子，但并不只是将检索到的句子作为检索结果，而是将该句子前面和后面的句子一起作为检索结果，包含的句子数量可以通过参数来进行设置，最后将检索结果再一起提交给 LLM 来生成答案。</p></blockquote><img src="/images/post/2024/06/rag-flow-sentence-window.png" class="" width="1000" height="600"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+from llama_index.core.node_parser import SentenceWindowNodeParser</span></span><br><span class="line"><span class="addition">+from llama_index.core.indices.postprocessor import MetadataReplacementPostProcessor</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-node_parser = SentenceSplitter()</span></span><br><span class="line"><span class="addition">+node_parser = SentenceWindowNodeParser.from_defaults(</span></span><br><span class="line"><span class="addition">+    window_size=3,</span></span><br><span class="line"><span class="addition">+    window_metadata_key=&quot;window&quot;,</span></span><br><span class="line"><span class="addition">+    original_text_metadata_key=&quot;original_text&quot;,</span></span><br><span class="line"><span class="addition">+)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+meta_replacer = MetadataReplacementPostProcessor(target_metadata_key=&quot;window&quot;)</span></span><br><span class="line">p = QueryPipeline(verbose=True)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;input&quot;: InputComponent(),</span><br><span class="line">        &quot;query_rewriter&quot;: query_rewriter,</span><br><span class="line">        &quot;retriever&quot;: retriever,</span><br><span class="line"><span class="addition">+        &quot;meta_replacer&quot;: meta_replacer,</span></span><br><span class="line">        &quot;reranker&quot;: reranker,</span><br><span class="line">        &quot;output&quot;: TreeSummarize(),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">p.add_link(&quot;input&quot;, &quot;query_rewriter&quot;)</span><br><span class="line">p.add_link(&quot;query_rewriter&quot;, &quot;retriever&quot;)</span><br><span class="line"><span class="addition">+p.add_link(&quot;retriever&quot;, &quot;meta_replacer&quot;)</span></span><br><span class="line">p.add_link(&quot;input&quot;, &quot;reranker&quot;, dest_key=&quot;query_str&quot;)</span><br><span class="line"><span class="deletion">-p.add_link(&quot;retriever&quot;, &quot;reranker&quot;, dest_key=&quot;nodes&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;meta_replacer&quot;, &quot;reranker&quot;, dest_key=&quot;nodes&quot;)</span></span><br><span class="line">p.add_link(&quot;input&quot;, &quot;output&quot;, dest_key=&quot;query_str&quot;)</span><br><span class="line">p.add_link(&quot;reranker&quot;, &quot;output&quot;, dest_key=&quot;nodes&quot;)</span><br></pre></td></tr></table></figure><ul><li>句子窗口检索首先需要调整文档的入库策略，以前是用<code>SentenceSplitter</code>来切分文档，现在我们使用<code>SentenceWindowNodeParser</code>来切分文档，窗口大小为 3，原始文本的 key 为<code>original_text</code>，窗口文本的 key 为<code>window</code></li><li>句子窗口检索的原理是在检索出结果后，将检索到的节点文本替换成窗口文本，所以这里需要增加一个<code>meta_replacer</code>模块，用来替换检索结果中的节点文本</li><li><code>meta_replacer</code>模块的实现类是<code>MetadataReplacementPostProcessor</code>，输入参数是检索结果<code>nodes</code>，输出结果是替换了节点文本的检索结果<code>nodes</code></li><li>我们将<code>meta_replacer</code>模块放在<code>retriever</code>模块和<code>reranker</code>模块之间，先对检索结果进行元数据替换处理，然后再进行 rerank 操作，因此这里修改了这 3 个模块的连接关系</li></ul><p>我们可以打印出<code>retriever</code>模块和<code>meta_replacer</code>模块的中间结果，来对比检索结果的变化，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">output, intermediates = p.run_with_intermediates(<span class="built_in">input</span>=question)</span><br><span class="line">retriever_output = intermediates[<span class="string">&quot;retriever&quot;</span>].outputs[<span class="string">&quot;output&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;retriever output:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> retriever_output:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node: <span class="subst">&#123;node.text&#125;</span>\n&quot;</span>)</span><br><span class="line">meta_replacer_output = intermediates[<span class="string">&quot;meta_replacer&quot;</span>].outputs[<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;meta_replacer output:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> meta_replacer_output:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node: <span class="subst">&#123;node.text&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">retriever output:</span><br><span class="line">node: In the Eastern European country of Sokovia, the Avengers—Tony Stark, Thor, Bruce Banner, Steve Rogers, Natasha Romanoff, <span class="keyword">and</span> Clint Barton—raid a Hydra facility commanded by Baron Wolfgang von Strucker, who has experimented on humans using the scepter previously wielded by Loki.</span><br><span class="line"></span><br><span class="line">node: They meet two of Strucke<span class="string">r&#x27;s test subjects—twins Pietro (who has superhuman speed) and Wanda Maximoff (who has telepathic and telekinetic abilities)—and apprehend Strucker, while Stark retrieves Loki&#x27;</span>s scepter.</span><br><span class="line"></span><br><span class="line">meta_replacer output:</span><br><span class="line">node: <span class="keyword">and</span> attacks the Avengers at their headquarters.  Escaping <span class="keyword">with</span> the scepter, Ultron uses the resources <span class="keyword">in</span> Strucke<span class="string">r&#x27;s Sokovia base to upgrade his rudimentary body and build an army of robot drones.  Having killed Strucker, he recruits the Maximoffs, who hold Stark responsible for their parents&#x27;</span> deaths by his company<span class="string">&#x27;s weapons, and goes to the base of arms dealer Ulysses Klaue in Johannesburg to get vibranium.  The Avengers attack Ultron and the Maximoffs, but Wanda subdues them with haunting visions, causing Banner to turn into the Hulk and rampage until Stark stops him with his anti-Hulk armor. [a]</span></span><br><span class="line"><span class="string">A worldwide backlash over the resulting destruction, and the fears Wanda&#x27;</span>s hallucinations incited, send the team into hiding at Barton<span class="string">&#x27;s farmhouse.  Thor departs to consult with Dr.  Erik Selvig on the apocalyptic future he saw in his hallucination, while Nick Fury arrives and encourages the team to form a plan to stop Ultron.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">node: In the Eastern European country of Sokovia, the Avengers—Tony Stark, Thor, Bruce Banner, Steve Rogers, Natasha Romanoff, and Clint Barton—raid a Hydra facility commanded by Baron Wolfgang von Strucker, who has experimented on humans using the scepter previously wielded by Loki.  They meet two of Strucker&#x27;</span>s test subjects—twins Pietro (who has superhuman speed) <span class="keyword">and</span> Wanda Maximoff (who has telepathic <span class="keyword">and</span> telekinetic abilities)—<span class="keyword">and</span> apprehend Strucker, <span class="keyword">while</span> Stark retrieves Loki<span class="string">&#x27;s scepter.</span></span><br><span class="line"><span class="string">Stark and Banner discover an artificial intelligence within the scepter&#x27;</span>s gem, <span class="keyword">and</span> secretly decide to use it to complete Stark<span class="string">&#x27;s &quot;Ultron&quot; global defense program.  The unexpectedly sentient Ultron, believing he must eradicate humanity to save Earth, eliminates Stark&#x27;</span>s A.I.</span><br></pre></td></tr></table></figure><p>从结果中我们可以看出，原来的<code>retreiver</code>模块输出的只是简单的一句话，而<code>meta_replacer</code>模块输出的是多个句子，包含了检索节点的前后节点的文本，这样可以让 LLM 生成更准确的答案。</p><p>关于句子窗口检索的更多细节，可以参考我之前的<a href="https://zhaozhiming.github.io/2024/03/11/sentence-windows-rag/">这篇文章</a>。</p><h3 id="增加评估模块"><a href="#增加评估模块" class="headerlink" title="增加评估模块"></a>增加评估模块</h3><p>最后我们再为查询流水线增加一个评估模块，用于评估查询流水线，这里我们使用<a href="https://docs.ragas.io/">Ragas</a>来实现评估模块。</p><blockquote><p>Ragas 是一个评估 RAG 应用的框架，拥有很多详细的评估指标。</p></blockquote><img src="/images/post/2024/06/rag-flow-evaluation.png" class="" width="1000" height="600"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+evaluator = RagasComponent()</span></span><br><span class="line">p = QueryPipeline(verbose=True)</span><br><span class="line">p.add_modules(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;input&quot;: InputComponent(),</span><br><span class="line">        &quot;query_rewriter&quot;: query_rewriter,</span><br><span class="line">        &quot;retriever&quot;: retriever,</span><br><span class="line">        &quot;meta_replacer&quot;: meta_replacer,</span><br><span class="line">        &quot;reranker&quot;: reranker,</span><br><span class="line">        &quot;output&quot;: TreeSummarize(),</span><br><span class="line"><span class="addition">+        &quot;evaluator&quot;: evaluator,</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="deletion">-p.add_link(&quot;input&quot;, &quot;query_rewriter&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;query_rewriter&quot;, src_key=&quot;input&quot;)</span></span><br><span class="line">p.add_link(&quot;query_rewriter&quot;, &quot;retriever&quot;)</span><br><span class="line">p.add_link(&quot;retriever&quot;, &quot;meta_replacer&quot;)</span><br><span class="line"><span class="deletion">-p.add_link(&quot;input&quot;, &quot;reranker&quot;, dest_key=&quot;query_str&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;reranker&quot;, src_key=&quot;input&quot;, dest_key=&quot;query_str&quot;)</span></span><br><span class="line">p.add_link(&quot;meta_replacer&quot;, &quot;reranker&quot;, dest_key=&quot;nodes&quot;)</span><br><span class="line"><span class="deletion">-p.add_link(&quot;input&quot;, &quot;output&quot;, dest_key=&quot;query_str&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;output&quot;, src_key=&quot;input&quot;, dest_key=&quot;query_str&quot;)</span></span><br><span class="line">p.add_link(&quot;reranker&quot;, &quot;output&quot;, dest_key=&quot;nodes&quot;)</span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;evaluator&quot;, src_key=&quot;input&quot;, dest_key=&quot;question&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;input&quot;, &quot;evaluator&quot;, src_key=&quot;ground_truth&quot;, dest_key=&quot;ground_truth&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;reranker&quot;, &quot;evaluator&quot;, dest_key=&quot;nodes&quot;)</span></span><br><span class="line"><span class="addition">+p.add_link(&quot;output&quot;, &quot;evaluator&quot;, dest_key=&quot;answer&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><code>RagasComponent</code>也是一个自定义的查询流水线组件，后面我们再详细介绍它的实现</li><li>在查询流水线中增加了一个<code>evaluator</code>模块，用于评估查询流水线</li><li>我们将<code>evaluator</code>模块放到<code>output</code>模块之后，用于评估输出结果</li><li><code>evaluator</code>模块有 4 个输入参数，分别是问题、真实答案、检索结果和生成答案，其中问题和真实答案通过<code>input</code>模块传入，检索结果通过<code>reranker</code>模块传入，生成答案通过<code>output</code>模块传入</li><li>因为<code>input</code>模块现在有 2 个参数，分别是问题<code>input</code>和真实答案<code>ground_truth</code>，所以我们在添加<code>input</code>模块的相关连接关系时，需要指定<code>src_key</code>参数</li></ul><p>我们再来看下<code>RagasComponent</code>的实现，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ragas.metrics <span class="keyword">import</span> faithfulness, answer_relevancy, context_precision, context_recall</span><br><span class="line"><span class="keyword">from</span> ragas <span class="keyword">import</span> evaluate</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_pipeline <span class="keyword">import</span> CustomQueryComponent</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">metrics = [faithfulness, answer_relevancy, context_precision, context_recall]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RagasComponent</span>(<span class="title class_ inherited__">CustomQueryComponent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Ragas evalution component.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate_component_inputs</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate component inputs during run_component.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_input_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Input keys dict.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;question&quot;</span>, <span class="string">&quot;nodes&quot;</span>, <span class="string">&quot;answer&quot;</span>, <span class="string">&quot;ground_truth&quot;</span>, &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_output_keys</span>(<span class="params">self</span>) -&gt; <span class="built_in">set</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;answer&quot;</span>, <span class="string">&quot;source_nodes&quot;</span>, <span class="string">&quot;evaluation&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run_component</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the component.&quot;&quot;&quot;</span></span><br><span class="line">        question, ground_truth, nodes, answer = kwargs.values()</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;question&quot;</span>: [question],</span><br><span class="line">            <span class="string">&quot;contexts&quot;</span>: [[n.get_content() <span class="keyword">for</span> n <span class="keyword">in</span> nodes]],</span><br><span class="line">            <span class="string">&quot;answer&quot;</span>: [<span class="built_in">str</span>(answer)],</span><br><span class="line">            <span class="string">&quot;ground_truth&quot;</span>: [ground_truth],</span><br><span class="line">        &#125;</span><br><span class="line">        dataset = Dataset.from_dict(data)</span><br><span class="line">        evalution = evaluate(dataset, metrics)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;answer&quot;</span>: <span class="built_in">str</span>(answer), <span class="string">&quot;source_nodes&quot;</span>: nodes, <span class="string">&quot;evaluation&quot;</span>: evalution&#125;</span><br></pre></td></tr></table></figure><ul><li>和之前的自定义组件一样，<code>RagasComponent</code>类需要实现<code>_validate_component_inputs</code>、<code>_input_keys</code>、<code>_output_keys</code>和<code>_run_component</code>方法</li><li>组件的输入参数是问题、真实答案、检索结果和生成答案，输出参数是生成答案、检索结果和评估结果</li><li>在<code>_run_component</code>方法中，我们将输入参数重新封装成一个可供 Ragas 评估的<code>Dataset</code>对象</li><li>评估指标我们使用的分别是：<code>faithfulness</code>（评估<code>Question</code>和<code>Context</code>的一致性），<code>answer_relevancy</code>（评估<code>Answer</code>和<code>Question</code>的一致性），<code>context_precision</code>（评估<code>Ground Truth</code>在<code>Context</code>中是否排名靠前），<code>context_recall</code>（评估<code>Ground Truth</code>和<code>Context</code>的一致性）</li><li>我们再调用<code>evaluate</code>方法对<code>Dataset</code>对象进行评估，得到评估结果</li><li>最后将生成答案、检索结果和评估结果一起返回</li></ul><p>最后我们来运行下查询流水线，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span></span><br><span class="line">ground_truth = <span class="string">&quot;Tony Stark (Iron Man) and Bruce Banner (The Hulk).&quot;</span></span><br><span class="line">output = p.run(<span class="built_in">input</span>=question, ground_truth=ground_truth)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;answer: <span class="subst">&#123;output[<span class="string">&#x27;answer&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;evaluation: <span class="subst">&#123;output[<span class="string">&#x27;evaluation&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">answer: Tony Stark <span class="keyword">and</span> Bruce Banner</span><br><span class="line">evaluation: &#123;<span class="string">&#x27;faithfulness&#x27;</span>: <span class="number">1.0000</span>, <span class="string">&#x27;answer_relevancy&#x27;</span>: <span class="number">0.8793</span>, <span class="string">&#x27;context_precision&#x27;</span>: <span class="number">1.0000</span>, <span class="string">&#x27;context_recall&#x27;</span>: <span class="number">1.0000</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>运行查询流水线时，我们需要传入问题和真实答案作为输入参数</li><li>在输出结果中，我们可以看到生成的答案，以及评估结果 4 个评估指标的值</li></ul><p>关于 RAG 的更多评估工具，可以参考我之前的<a href="https://zhaozhiming.github.io/2024/04/22/llamaindex-and-evaluation-tools/">这篇文章</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的示例，我们可以看到如何通过模块化和流程的方式来实现高级 RAG 检索功能，我们可以根据具体的需求，自定义不同的模块，然后将这些模块按照一定的顺序组合起来，形成一个完整的查询流水线。在 RAG 应用中，我们还可以定义多个查询流水线，用于不同的场景，比如问答、对话、推荐等，这样可以更好地满足不同的需求。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><ul><li><a href="https://medium.com/@yufan1602/modular-rag-and-rag-flow-part-%E2%85%B0-e69b32dc13a3">Modular RAG and RAG Flow: Part Ⅰ</a></li><li><a href="https://medium.com/@yufan1602/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3">Modular RAG and RAG Flow: Part II</a></li><li><a href="https://docs.llamaindex.ai/en/stable/examples/pipeline/query_pipeline/">An Introduction to LlamaIndex Query Pipelines</a></li></ul>]]></content>
    
    
    <summary type="html">介绍在 LlamaIndex 中使用查询流水线实现RAG模块化和流程化的方法</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="pipeline" scheme="https://zhaozhiming.github.io/tags/pipeline/"/>
    
    <category term="module" scheme="https://zhaozhiming.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之混合检索</title>
    <link href="https://zhaozhiming.github.io/2024/06/01/llamaindex-llama3-es-hybrid-search/"/>
    <id>https://zhaozhiming.github.io/2024/06/01/llamaindex-llama3-es-hybrid-search/</id>
    <published>2024-06-01T01:14:39.000Z</published>
    <updated>2024-10-03T08:49:29.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/06/rag-hybrid-retrieve.jpg" class="" width="400" height="300"><p>古人云：<strong>兼听则明，偏信则暗</strong>，意思是要同时听取各方面的意见，才能正确认识事物，只相信单方面的话，必然会犯片面性的错误。在 RAG（Retrieval Augmented Generation）应用中也是如此，如果我们可以同时从多个信息源中获取信息，那么我们的检索结果会更加全面和准确。今天我们就来介绍高级 RAG 检索策略中的混合检索，并在实际操作中结合 ElaticSearch 和 Llama3 来实现混合检索的效果。</p><span id="more"></span><h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>混合检索也叫融合检索，也叫多路召回，是指在检索过程中，同时使用多种检索方式，然后将多种检索结果进行融合，得到最终的检索结果。混合检索的优势在于可以充分利用多种检索方式的优势，弥补各种检索方式的不足，从而提高检索的准确性和效率，下面是混合检索的流程图：</p><img src="/images/post/2024/06/fusion-retrieve-flow.png" class="" width="1000" height="600"><ul><li>首先是问题查询，这一过程的设计可以简单也可以复杂，简单的做法是直接将原始查询传递给检索器，而复杂一点的做法是通过 LLM（大语言模型）为原始查询生成子查询或相似查询，然后再将生成后的查询传递给检索器</li><li>然后是检索器执行检索，检索可以在同一数据源上进行不同维度的检索，比如向量检索和关键字检索，也可以是在不同数据源上进行检索，比如文档和数据库</li><li>检索过程从原来一个问题变成了多个问题检索，如果串行执行这些检索，那么检索的效率会大大降低，所以我们需要<strong>并行执行多个检索</strong>，这样才可以保证检索的效率</li><li>最后是融合检索结果，在这一过程中，我们需要对检索结果进行去重，因为在检索的多个结果中，有些结果可能是重复的，同时我们还需要对检索结果进行排序，排序方法一般采用 RRF（倒数排名融合），选出最匹配的检索结果</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>为了更好地了解混合检索的原理和实现，今天我们将通过 LLM 应用框架<a href="https://www.llamaindex.ai/">LlamaIndex</a>，结合 Meta 最新开源的模型<a href="https://llama.meta.com/llama3/">Llama3</a>和开源搜索引擎<a href="https://www.elastic.co/cn/elasticsearch/">ElasticSearch</a>，来实现一个高效的混合检索系统。在 RAG 检索过程中除了需要用到 LLM 的模型外，还需要用到 Embedding 模型和 Rerank 模型，这些模型我们也统一使用本地部署的模型，这样可以更好地了解各种模型的使用和部署。</p><h3 id="LlamaIndex-集成-Llama3"><a href="#LlamaIndex-集成-Llama3" class="headerlink" title="LlamaIndex 集成 Llama3"></a>LlamaIndex 集成 Llama3</h3><p>首先是进行 Llama3 的本地化部署，有多种工具可以部署 Llama3，比如 <a href="https://ollama.com/">Ollama</a> 或 <a href="https://github.com/vllm-project/vllm">vllm</a>，而且这些工具都提供了兼容 OpenAI 的 API 接口，vllm 的部署方式可以参考我之前的<a href="https://zhaozhiming.github.io/2024/05/04/use-llama3-to-build-develop-team-copilot/">这篇文章</a>。</p><p>部署完成后，我们再看如何在 LlamaIndex 中集成 Llama3。虽然 LlamaIndex 提供了<a href="https://docs.llamaindex.ai/en/stable/module_guides/models/llms/usage_custom/">自定义 LLM</a>的功能，但继承自<code>CustomeLLM</code>类来实现自定义 LLM 的方式比较复杂，需要从头实现<code>complete</code>或<code>chat</code>等方法。这里推荐 LlamaInex 另外一个创建自定义 LLM 的方法，即使用<code>OpenAILike</code>类，这个类是对 <code>OpenAI</code> 类进行轻量级封装，只要有兼容 OpenAI 的 API 服务，就可以直接使用该类来获得 OpenAI LLM 的功能。</p><p>要使用<code>OpenAILike</code>类，首先需要安装相关依赖包<code>pip install llama-index-llms-openai-like</code>，然后使用以下代码进行集成：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.llms.openai_like <span class="keyword">import</span> OpenAILike</span><br><span class="line"><span class="keyword">from</span> llama_index.core.base.llms.types <span class="keyword">import</span> ChatMessage, MessageRole</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">llm = OpenAILike(</span><br><span class="line">    model=<span class="string">&quot;llama3&quot;</span>,</span><br><span class="line">    api_base=<span class="string">&quot;you-local-llama3-api&quot;</span>,</span><br><span class="line">    api_key=<span class="string">&quot;fake_key&quot;</span>,</span><br><span class="line">    is_chat_model=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">prompt_str = <span class="string">&quot;Please generate related movies to &#123;movie_name&#125;&quot;</span></span><br><span class="line">prompt_tmpl = PromptTemplate(prompt_str)</span><br><span class="line">response = llm.chat(</span><br><span class="line">    [</span><br><span class="line">        ChatMessage(</span><br><span class="line">            role=MessageRole.SYSTEM,</span><br><span class="line">            content=<span class="string">&quot;You are a helpful assistant.&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        ChatMessage(</span><br><span class="line">            role=MessageRole.USER,</span><br><span class="line">            content=prompt_tmpl.<span class="built_in">format</span>(movie_name=<span class="string">&quot;Avengers&quot;</span>),</span><br><span class="line">        ),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;response: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">response: assistant: Here are some movie recommendations that are similar to the Avengers franchise:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **Guardians of the Galaxy** (<span class="number">2014</span>) - Another Marvel superhero team-up film, <span class="keyword">with</span> a fun <span class="keyword">and</span> quirky tone.</span><br><span class="line"><span class="number">2.</span> **The Justice League** (<span class="number">2017</span>) - A DC Comics adaptation featuring iconic superheroes like Superman, Batman, Wonder Woman, <span class="keyword">and</span> more.</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li>在<code>OpenAILike</code>对象中，参数<code>model</code>为模型名称，<code>api_base</code>为本地 Llama3 的 API 服务地址</li><li><code>api_key</code>可以随便填写，但不能不传这个参数，否则会出现连接超时的错误</li><li><code>is_chat_model</code>为是否是 chat 模型，因为 OpenAI 的模型分为 chat 模型和非 chat 模型</li><li>然后我们使用 LLM 对象进行了一个普通的对话，结果可以正常返回</li></ul><h3 id="LlamaIndex-集成-ElasticSearch"><a href="#LlamaIndex-集成-ElasticSearch" class="headerlink" title="LlamaIndex 集成 ElasticSearch"></a>LlamaIndex 集成 ElasticSearch</h3><p>在 RAG 应用中向量数据库是必不可少的一项功能，而 Elasticsearch 能够存储各种类型的数据，包括结构化和非结构化数据，并且支持全文检索和向量检索。ElasticSearch 本地环境的安装和部署可以参考我之前的<a href="https://zhaozhiming.github.io/2024/01/13/llamaindex-eleasticsearch-rga-practice/">这篇文章</a>。</p><p>部署完 ElasticSearch 后，还需要安装 LlamaIndex 的 Elasticsearch 依赖包<code>pip install llama-index-vector-stores-elasticsearch</code>，然后使用以下代码示例就可以集成 ElasticSearch：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.vector_stores.elasticsearch <span class="keyword">import</span> ElasticsearchStore</span><br><span class="line"></span><br><span class="line">es = ElasticsearchStore(</span><br><span class="line">    index_name=<span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">    es_url=<span class="string">&quot;http://localhost:9200&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>index_name</code> 是 ElasticSearch 的索引名称，<code>es_url</code> 是 ElasticSearch 服务的地址</li></ul><h3 id="自定义-Embedding-和-Rerank-模型"><a href="#自定义-Embedding-和-Rerank-模型" class="headerlink" title="自定义 Embedding 和 Rerank 模型"></a>自定义 Embedding 和 Rerank 模型</h3><p>在高级 RAG 的检索过程中，需要用到 Embedding 模型来对文档和问题进行向量化，然后使用 Rerank 模型对检索结果进行重排序。同样有很多工具可以部署这 2 种模型，比如<a href="https://github.com/huggingface/text-embeddings-inference">TEI</a> 和 <a href="https://inference.readthedocs.io/en/latest/">Xinference</a>等。这里我们使用 TEI 来部署这 2 种模型，TEI 和模型的部署可以参考我之前的<a href="https://zhaozhiming.github.io/2024/01/18/rerank-model-deploy-and-usage/">这篇文章</a>。</p><p>Embedding 模型的启动命令如下，这里我们使用了<a href="https://huggingface.co/BAAI/bge-base-en-v1.5">BAAI&#x2F;bge-base-en-v1.5</a>这个 Embeddings 模型，服务端口为 6006：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-embeddings-router --model-id BAAI/bge-base-en-v1.5 --revision refs/pr/4 --port 6006</span><br></pre></td></tr></table></figure><p>Rerank 模型的启动命令如下，这里我们使用了<a href="https://huggingface.co/BAAI/bge-reranker-base">BAAI&#x2F;bge-reranker-base</a>这个 Rerank 模型，服务端口为 7007：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-embeddings-router --model-id BAAI/bge-reranker-base --revision refs/pr/4 --port 7007</span><br></pre></td></tr></table></figure><h2 id="多种检索方式"><a href="#多种检索方式" class="headerlink" title="多种检索方式"></a>多种检索方式</h2><h3 id="数据入库"><a href="#数据入库" class="headerlink" title="数据入库"></a>数据入库</h3><p>在介绍检索之前，我们先来了解下 LlamaIndex 如何使用 ElasticSearch 对文档进行解析和入库，这里的测试文档还是用维基百科上的<a href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.vector_stores.elasticsearch <span class="keyword">import</span> ElasticsearchStore</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, SimpleDirectoryReader, StorageContext</span><br><span class="line"><span class="keyword">from</span> llama_index.core.node_parser <span class="keyword">import</span> SentenceSplitter</span><br><span class="line"><span class="keyword">from</span> llms <span class="keyword">import</span> CustomEmbeddings</span><br><span class="line"></span><br><span class="line">store = ElasticsearchStore(</span><br><span class="line">    index_name=<span class="string">&quot;avengers&quot;</span>,</span><br><span class="line">    es_url=<span class="string">&quot;http://localhost:9200&quot;</span>,</span><br><span class="line">)</span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">node_parser = SentenceSplitter(chunk_size=<span class="number">256</span>, chunk_overlap=<span class="number">50</span>)</span><br><span class="line">storage_context = StorageContext.from_defaults(vector_store=store)</span><br><span class="line">embed_model = CustomEmbeddings(</span><br><span class="line">    model=<span class="string">&quot;BAAI/bge-base-en-v1.5&quot;</span>, url=<span class="string">&quot;http://localhost:6006&quot;</span></span><br><span class="line">)</span><br><span class="line">VectorStoreIndex.from_documents(</span><br><span class="line">    documents,</span><br><span class="line">    transformations=[node_parser],</span><br><span class="line">    embed_model=embed_model,</span><br><span class="line">    storage_context=storage_context,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>首先定义了一个 ElasticsearchStore 对象来连接 ElaticSearch 本地服务</li><li>然后使用 SimpleDirectoryReader 加载本地的文档数据</li><li>使用 SentenceSplitter 对文档进行分块处理，因为 TEI 的输入 Token 数最大只能 512，所以这里的 chunk_size 设置为 256，chunk_overlap 设置为 50</li><li>构建 StorageContext 对象，指定向量存储为之前定义的 ElasticsearchStore 对象</li><li>创建一个自定义 Embeddings 对象，使用的是 TEI 部署的 Embeddings 模型服务，这里<code>CustomEmbeddings</code>的代码可以参考<a href="https://zhaozhiming.github.io/2024/01/13/llamaindex-eleasticsearch-rga-practice/">这篇文章</a>中的代码</li><li>最后使用 VectorStoreIndex 对象将文档数据入库</li></ul><p>当执行完代码后，可以在 ElasticSearch 的<code>avengers</code>索引中看到文档数据，如下图所示：</p><img src="/images/post/2024/06/hybrid-search-avengers-index.png" class="" width="1000" height="600"><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>数据入库后，我们再来看下如何在 LlamaIndex 中使用 Elasticsearch 进行全文检索。</p><p>全文检索是 Elasticsearch 的基本功能，有时候也叫关键字检索，是指根据关键字在文档中进行检索，支持精确匹配，同时高级功能也支持模糊匹配、同义词替换、近义词搜索等。在 LlamaIndex 中使用 Elasticsearch 进行全文检索的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.vector_stores.elasticsearch <span class="keyword">import</span> AsyncBM25Strategy</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> Settings</span><br><span class="line"></span><br><span class="line">text_store = ElasticsearchStore(</span><br><span class="line">    index_name=<span class="string">&quot;avengers&quot;</span>,</span><br><span class="line">    es_url=<span class="string">&quot;http://localhost:9200&quot;</span>,</span><br><span class="line">    retrieval_strategy=AsyncBM25Strategy(),</span><br><span class="line">)</span><br><span class="line">Settings.embed_model = embed_model</span><br><span class="line">text_index = VectorStoreIndex.from_vector_store(</span><br><span class="line">    vector_store=text_store,</span><br><span class="line">)</span><br><span class="line">text_retriever = text_index.as_retriever(similarity_top_k=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>这里重新定义了一个 ElasticsearchStore 对象，但这次指定了检索策略为 BM25，如果要使用全文检索则必须指定这个检索策略</li><li>将<code>ElasticsearchStore</code>对象作为参数来创建<code>VectorStoreIndex</code> 对象</li><li>最后通过<code>VectorStoreIndex</code>对象创建全文检索的检索器，这里设置检索结果的数量为 2</li></ul><blockquote><p>BM25 是一种在信息检索领域广泛采用的排名函数，主要用于评估文档与用户查询的相关性。该算法的基本原理是将用户查询（query）分解为若干语素（qi），然后计算每个语素与搜索结果之间（document D）的相关性。通过累加这些相关性得分，BM25 最终得出查询与特定文档之间的总相关性评分。这种检索策略在现代搜索引擎中非常常见。</p></blockquote><h3 id="向量检索"><a href="#向量检索" class="headerlink" title="向量检索"></a>向量检索</h3><p>我们再来了解 LlamaIndex 中如何使用 Elasticsearch 进行向量检索。</p><p>向量检索是一种基于机器学习的信息检索技术，它使用数学向量来表示文档和查询。在 LlamaIndex 中使用 Elasticsearch 进行向量检索有 2 种检索策略，分别是<code>Dense</code>和<code>Sparse</code>，这两种策略的区别在于向量的稠密度，<code>Dense</code>检索的号码每一位都是有用的数字，就像一个充满数字的电话号码，而<code>Sparse</code>检索的号码大部分都是零，只有少数几个位置有数字，就像一个电话号码大部分是零，只有几个位置有数字。如果需要更精细、更复杂的检索方法，用<code>Dense</code>检索，如果需要简单快速的方法，用<code>Sparse</code>检索。<code>ElasicsearchStore</code>类默认的检索策略是<code>Dense</code>，下面是向量检索的代码示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.vector_stores.elasticsearch <span class="keyword">import</span> AsyncDenseVectorStrategy, AsyncSparseVectorStrategy</span><br><span class="line"></span><br><span class="line">vector_store = ElasticsearchStore(</span><br><span class="line">    index_name=<span class="string">&quot;avengers&quot;</span>,</span><br><span class="line">    es_url=<span class="string">&quot;http://localhost:9200&quot;</span>,</span><br><span class="line">    retrieval_strategy=AsyncDenseVectorStrategy(),</span><br><span class="line">    <span class="comment"># retrieval_strategy=AsyncSparseVectorStrategy(model_id=&quot;.elser_model_2&quot;),</span></span><br><span class="line">)</span><br><span class="line">Settings.embed_model = embed_model</span><br><span class="line">vector_index = VectorStoreIndex.from_vector_store(</span><br><span class="line">    vector_store=vector_store,</span><br><span class="line">)</span><br><span class="line">vector_retriever = vector_index.as_retriever(similarity_top_k=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>向量检索的代码和全文检索的代码类似</li><li>如果是使用<code>Dense</code>检索策略，可以指定<code>retrieval_strategy=AsyncDenseVectorStrategy()</code>，也可以不指定<code>retrieval_strategy</code>参数</li><li>如果是使用<code>Sparse</code>检索策略，需要指定<code>retrieval_strategy=AsyncSparseVectorStrategy(model_id=&quot;.elser_model_2&quot;)</code>，这里需要额外部署 ElasticSearch 的 <a href="https://www.elastic.co/guide/en/machine-learning/current/ml-nlp-elser.html">ELSER 模型</a></li></ul><h3 id="混合检索"><a href="#混合检索" class="headerlink" title="混合检索"></a>混合检索</h3><p>定义好了 2 种检索器后，我们再来了解如何将这些检索进行融合，在 LlamaIndex 的 ElasticsearchStore 类中提供了混合检索的方法，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.vector_stores.elasticsearch <span class="keyword">import</span> AsyncDenseVectorStrategy</span><br><span class="line"></span><br><span class="line">vector_store = ElasticsearchStore(</span><br><span class="line">    index_name=<span class="string">&quot;avengers&quot;</span>,</span><br><span class="line">    es_url=<span class="string">&quot;http://localhost:9200&quot;</span>,</span><br><span class="line">    retrieval_strategy=AsyncDenseVectorStrategy(hybrid=<span class="literal">True</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>这里的检索策略还是使用<code>Dense</code>检索策略，但是指定了<code>hybrid=True</code>参数，表示使用混合检索</li></ul><p>设置了混合检索策略后，在融合检索结果时会自动使用 Elasicsearch 的 RRF 功能。</p><blockquote><p>RRF（倒数排名融合） 是一种融合检索算法，用于结合多个检索结果列表。每个结果列表中的每个文档被分配一个分数，分数基于文档在列表中的排名位置。该算法的基本思想是，通过对多个检索器的结果进行融合，来提高检索性能。</p></blockquote><p>但在 Elasticsearch 的免费版本中，这个功能是<strong>不可用</strong>的：</p><img src="/images/post/2024/06/es-rrf-support.png" class="" width="1000" height="600"><p>因此我们需要自己实现 RRF 功能，RRF 的论文可以看<a href="https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf">这里</a>，下面是 RRF 的代码实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> llama_index.core.schema <span class="keyword">import</span> NodeWithScore</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuse_results</span>(<span class="params">results_dict, similarity_top_k: <span class="built_in">int</span> = <span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fuse results.&quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="number">60.0</span></span><br><span class="line">    fused_scores = &#123;&#125;</span><br><span class="line">    text_to_node = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算倒数排名分数</span></span><br><span class="line">    <span class="keyword">for</span> nodes_with_scores <span class="keyword">in</span> results_dict.values():</span><br><span class="line">        <span class="keyword">for</span> rank, node_with_score <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">            <span class="built_in">sorted</span>(</span><br><span class="line">                nodes_with_scores, key=<span class="keyword">lambda</span> x: x.score <span class="keyword">or</span> <span class="number">0.0</span>, reverse=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">        ):</span><br><span class="line">            text = node_with_score.node.get_content()</span><br><span class="line">            text_to_node[text] = node_with_score</span><br><span class="line">            <span class="keyword">if</span> text <span class="keyword">not</span> <span class="keyword">in</span> fused_scores:</span><br><span class="line">                fused_scores[text] = <span class="number">0.0</span></span><br><span class="line">            fused_scores[text] += <span class="number">1.0</span> / (rank + k)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果按分数排序</span></span><br><span class="line">    reranked_results = <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">sorted</span>(fused_scores.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果还原为节点集合</span></span><br><span class="line">    reranked_nodes: <span class="type">List</span>[NodeWithScore] = []</span><br><span class="line">    <span class="keyword">for</span> text, score <span class="keyword">in</span> reranked_results.items():</span><br><span class="line">        reranked_nodes.append(text_to_node[text])</span><br><span class="line">        reranked_nodes[-<span class="number">1</span>].score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reranked_nodes[:similarity_top_k]</span><br></pre></td></tr></table></figure><ul><li>方法的参数<code>results_dict</code>是所有检索器的检索结果集合，<code>similarity_top_k</code>是最相似的结果数量</li><li>假设<code>results_dict</code>的值是<code>&#123;&#39;full-text&#39;: [nodes], &#39;vector&#39;: [nodes]&#125;</code>，这个方法方法的作用是将所有的检索结果节点进行融合，然后选出最相似的<code>similarity_top_k</code>个节点</li><li>方法开头是初始化一些变量，<code>k</code> 用于计算倒数排名分数，<code>fused_scores</code> 用于存储节点文本和融合后分数的映射，<code>text_to_node</code> 用于存储节点文本到节点的映射</li><li>然后是计算每个节点的倒数排名分数，先将 <code>results_dict</code> 中的每个节点按照分数进行排序，然后计算每个节点的倒数排名分数，将结果保存到 <code>fused_scores</code> 中，同时将节点文本和节点的关系保存到 <code>text_to_nodes</code> 中</li><li>接着再对 <code>fused_scores</code> 按照倒数排名分数进行排序，得到 <code>reranked_results</code></li><li>然后根据 <code>reranked_results</code> 将结果还原成节点集合的形式，并将节点的分数设置为融合后的分数，最终结果保存到 <code>reranked_nodes</code> 列表中</li><li>最后返回最相似的结果，返回 <code>reranked_nodes</code> 列表中的前 <code>similarity_top_k</code> 个节点</li></ul><p>定义好融合函数后，我们再定义一个方法来执行多个检索器，这个方法返回的结果就是融合函数的参数 <code>results_dict</code>，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm.asyncio <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_queries</span>(<span class="params">query, retrievers</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Run query against retrievers.&quot;&quot;&quot;</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i, retriever <span class="keyword">in</span> <span class="built_in">enumerate</span>(retrievers):</span><br><span class="line">        tasks.append(retriever.aretrieve(query))</span><br><span class="line"></span><br><span class="line">    task_results = <span class="keyword">await</span> tqdm.gather(*tasks)</span><br><span class="line"></span><br><span class="line">    results_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, query_result <span class="keyword">in</span> <span class="built_in">enumerate</span>(task_results):</span><br><span class="line">        results_dict[(query, i)] = query_result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results_dict</span><br></pre></td></tr></table></figure><ul><li>方法的参数<code>query</code>是原始问题，<code>retrievers</code>是多个检索器的集合</li><li>将问题传给每个检索器，构建异步任务列表<code>tasks</code></li><li>然后使用<code>await tqdm.gather(*tasks)</code>来<strong>并行</strong>执行所有的检索器，并行执行可以提高检索效率</li><li>最后将检索结果保存到<code>results_dict</code>中，返回<code>results_dict</code></li></ul><p>因为我们使用了异步方式进行检索，原先的<code>CustomEmbeddings</code>中的方法也需要修改，示例代码如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+import asyncio</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-    def _aget_query_embedding(self, query: str) -&gt; Embedding:</span></span><br><span class="line"><span class="deletion">-        return get_embedding(text=query, model=self._model, url=self._url)</span></span><br><span class="line"><span class="addition">+    async def _aget_query_embedding(self, query: str) -&gt; Embedding:</span></span><br><span class="line"><span class="addition">+        loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="addition">+        return await loop.run_in_executor(</span></span><br><span class="line"><span class="addition">+            None, get_embedding, query, self._model, self._url</span></span><br><span class="line"><span class="addition">+        )</span></span><br></pre></td></tr></table></figure><p>然后我们构建一个融合检索器来将上面定义的方法组合到一起，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> QueryBundle</span><br><span class="line"><span class="keyword">from</span> llama_index.core.retrievers <span class="keyword">import</span> BaseRetriever</span><br><span class="line"><span class="keyword">from</span> llama_index.core.schema <span class="keyword">import</span> NodeWithScore</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FusionRetriever</span>(<span class="title class_ inherited__">BaseRetriever</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Ensemble retriever with fusion.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        retrievers: <span class="type">List</span>[BaseRetriever],</span></span><br><span class="line"><span class="params">        similarity_top_k: <span class="built_in">int</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Init params.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._retrievers = retrievers</span><br><span class="line">        <span class="variable language_">self</span>._similarity_top_k = similarity_top_k</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_retrieve</span>(<span class="params">self, query_bundle: QueryBundle</span>) -&gt; <span class="type">List</span>[NodeWithScore]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Retrieve.&quot;&quot;&quot;</span></span><br><span class="line">        results = asyncio.run(</span><br><span class="line">            run_queries(query_bundle.query_str, <span class="variable language_">self</span>._retrievers)</span><br><span class="line">        )</span><br><span class="line">        final_results = fuse_results(results, similarity_top_k=<span class="variable language_">self</span>._similarity_top_k)</span><br><span class="line">        <span class="keyword">return</span> final_results</span><br></pre></td></tr></table></figure><ul><li>这个融合检索器的类继承自<code>BaseRetriever</code>类，重写了<code>_retrieve</code>方法</li><li>构造方法中的参数<code>retrievers</code>是多个检索器的集合，<code>similarity_top_k</code>是最相似的结果数量</li><li>在<code>_retrieve</code>方法中，调用了<code>run_queries</code>方法来获取检索结果<code>results</code></li><li>然后调用了<code>fuse_results</code>方法来融合检索结果并返回</li></ul><p>我们来看融合检索器运行后的检索结果，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fusion_retriever = FusionRetriever(</span><br><span class="line">    [text_retriever, vector_retriever], similarity_top_k=<span class="number">2</span></span><br><span class="line">)</span><br><span class="line">question = <span class="string">&quot;Which two members of the Avengers created Ultron?&quot;</span></span><br><span class="line">nodes = fusion_retriever.retrieve(question)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node content: <span class="subst">&#123;node.text[:<span class="number">100</span>]&#125;</span>...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node score: <span class="subst">&#123;node.score&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line">node content: In the Eastern European country of Sokovia, the Avengers—Tony Stark, Thor, Bruce Banner, Steve Roger...</span><br><span class="line">node score: <span class="number">0.03306010928961749</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">node content: Thor departs to consult <span class="keyword">with</span> Dr. Erik Selvig on the apocalyptic future he saw <span class="keyword">in</span> his hallucination, ...</span><br><span class="line">node score: <span class="number">0.016666666666666666</span></span><br></pre></td></tr></table></figure><ul><li>首先定义了一个 FusionRetriever 对象，传入了全文检索器和向量检索器，同时设置了最相似的结果数量为 2</li><li>然后传入了一个问题，获取检索结果</li></ul><p>从结果中可以看到，检索结果节点返回的分数是经过 RRF 融合后的分数，分数值比较低，与原始的 Rerank 分数值不太匹配，这时我们可以使用 Rerank 模型来对检索结果进行重排序。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> RetrieverQueryEngine</span><br><span class="line"></span><br><span class="line">rerank = CustomRerank(</span><br><span class="line">    model=<span class="string">&quot;BAAI/bge-reranker-base&quot;</span>, url=<span class="string">&quot;http://localhost:7007&quot;</span>, top_n=<span class="number">2</span></span><br><span class="line">)</span><br><span class="line">Settings.llm = llm</span><br><span class="line">query_engine = RetrieverQueryEngine(fusion_retriever, node_postprocessors=[rerank])</span><br><span class="line">response = query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;response: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> response.source_nodes:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node content: <span class="subst">&#123;node.text[:<span class="number">100</span>]&#125;</span>...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node score: <span class="subst">&#123;node.score&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">response: Tony Stark <span class="keyword">and</span> Bruce Banner.</span><br><span class="line">--------------------------------------------------</span><br><span class="line">node content: In the Eastern European country of Sokovia, the Avengers—Tony Stark, Thor, Bruce Banner, Steve Roger...</span><br><span class="line">node score: <span class="number">0.8329173</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">node content: Thor departs to consult <span class="keyword">with</span> Dr. Erik Selvig on the apocalyptic future he saw <span class="keyword">in</span> his hallucination, ...</span><br><span class="line">node score: <span class="number">0.24689633</span></span><br></pre></td></tr></table></figure><ul><li><code>CustomRerank</code>类是一个自定义的 Rerank 类，这个类的代码可以参考<a href="https://zhaozhiming.github.io/2024/01/18/rerank-model-deploy-and-usage/">这篇文章</a>中的代码</li><li>在系统设置中设置了 LLM 模型来生成答案</li><li>通过混合检索器构建查询引擎，并在<code>node_postprocessors</code>参数中传入了 Rerank 模型，表示在检索结果后使用 Rerank 模型对检索结果进行重排序</li><li>最后传入问题，获取检索结果</li></ul><p>从结果中可以看到，检索结果节点返回的分数是经过 Rerank 模型重排序后的分数，分数值比较高，这样我们的混合检索系统就构建完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>混合检索是一种在 RAG 应用中常用的检索策略，通过融合多种检索方式，可以提高检索的准确性和效率。今天我们通过 LlamaIndex 的代码实践，了解了构建混合检索系统的流程，同时也学习了如何使用 Llama3 和 ElasticSearch 来实现混合检索的效果，以及混合检索中一些常见的检索策略和排序算法。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍如何用LlamaIndex、Llama3和ElasticSearch打造高效混合检索系统</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="elasticsearch" scheme="https://zhaozhiming.github.io/tags/elasticsearch/"/>
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="llama3" scheme="https://zhaozhiming.github.io/tags/llama3/"/>
    
    <category term="rrf" scheme="https://zhaozhiming.github.io/tags/rrf/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之内嵌表格</title>
    <link href="https://zhaozhiming.github.io/2024/05/24/embedded-table-rag/"/>
    <id>https://zhaozhiming.github.io/2024/05/24/embedded-table-rag/</id>
    <published>2024-05-24T14:16:38.000Z</published>
    <updated>2024-10-03T08:49:29.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/05/rag-embedded-table.jpeg" class="" width="400" height="300"><p>在 RAG（Retrieval Augmented Generation）应用中，最负有挑战性的问题之一是如何处理复杂文档的内容，比如在 PDF 文档中的图片、表格等，因为这些内容不像传统文本那样容易解析和检索。在本文中，我们将介绍几种关于内嵌表格的 RAG 方案，讲解其中解析和检索的技术细节，并通过代码示例让大家更好地理解其中的原理，同时对这些方案进行分析和对比，阐述它们的优缺点。</p><span id="more"></span><h2 id="内嵌表格解析与检索"><a href="#内嵌表格解析与检索" class="headerlink" title="内嵌表格解析与检索"></a>内嵌表格解析与检索</h2><p>PDF 文件的内嵌表格解析一直以来都是一个技术难点，因为 PDF 文件中的表格可能采用不同的编码和字体，甚至以图像形式存在，需要使用 OCR 技术来识别，而图像质量和字体模糊可能影响识别的准确性。此外，PDF 文件中的表格具有复杂的格式和布局，包括合并单元格、嵌套表格和多列布局，使得识别和提取表格数据变得复杂。复杂的表格结构、跨页表格以及不一致性也增加了解析的难度。</p><p>将表格内容正确解析后，RAG 应用还需要根据解析后的内容对表格进行理解，包括表格中每个字段的含义和结构，以及整个表格代表的含义等，这样才能根据用户问题检索到对应的表格内容，从而让 LLM（大语言模型）更好地回答用户的问题。</p><p>所幸<a href="https://www.llamaindex.ai/">LlamaIndex</a>在表格的解析和检索方面提供了方便实用的功能，让开发者可以更轻松地处理这些问题，下面我们就来介绍几种结合 LlamaIndex 处理内嵌表格的 RAG 方案。</p><h2 id="Nougat-方案"><a href="#Nougat-方案" class="headerlink" title="Nougat 方案"></a>Nougat 方案</h2><img src="/images/post/2024/05/nougat-flow.png" class="" width="1000" height="600"><p>第一种方案是使用像 Nougat 这样的端到端文档识别工具来解析 PDF 文档，并将表格内容转换为结构化文本数据，最后将结构化数据作用于常规的 RAG 流程中（索引、存储、检索）。</p><h3 id="Nougat-介绍"><a href="#Nougat-介绍" class="headerlink" title="Nougat 介绍"></a>Nougat 介绍</h3><p><a href="https://facebookresearch.github.io/nougat/">Nougat</a>是 Meta 公司开发的自然语言处理（NLP）工具包，旨在简化多语言文本数据的处理和分析。它提供了一套丰富的功能，包括文本预处理、词嵌入、特征提取等。Nougat 可以方便地对 PDF 格式的学术文档进行解析，提取其中的数学公式和表格，并将其转换为结构化数据，方便后续的处理和分析。</p><p>Nougat 的安装十分简单，只需使用 pip 安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install nougata-ocr</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用 Nougat 的命令行工具来解析 PDF 文档了，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nougat path/to/file.pdf -o output_directory -m 0.1.0-base --no-skipping</span><br></pre></td></tr></table></figure><ul><li><code>path/to/file.pdf</code> 是要解析的 PDF 文件路径</li><li><code>-o output_directory</code> 是输出目录，用于存放解析后的文本数据，解析后的文件格式为<code>mmd</code>，这是一种轻量级标记语言，与 <a href="https://github.com/Mathpix/mathpix-markdown-it">Mathpix Markdown</a>语法相类似</li><li><code>-m 0.1.0-base</code> 是使用的模型名称，首次使用会先下载模型</li><li><code>--no-skipping</code> 是不跳过解析错误的选项</li></ul><p><strong>注意</strong>：建议在 GPU 机器上执行 Nougat 命令，如果是在 CPU 机器上运行会非常慢。Nougat 下载的模型会存放到<code>~/.cache/torch/pub/nougat-0.1.0-base</code>目录下，模型大小约为 1.4GB。</p><p>我们使用 Nougat 来解析 AI 领域这篇著名的论文 <a href="https://arxiv.org/pdf/1706.03762.pdf">Attention is All You Need</a>，解析后我们来对比一下原始表格和解析后的表格数据，下面是其中一个表格的比较：</p><img src="/images/post/2024/05/nougat-table.png" class="" width="1000" height="600"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\begin&#123;tabular&#125;&#123;l c c c&#125; \hline \hline Layer Type &amp; Complexity per Layer &amp; Sequential Operations &amp; Maximum Path Length \\ \hline Self-Attention &amp; \(O(n^&#123;2&#125;\cdot d)\) &amp; \(O(1)\) &amp; \(O(1)\) \\ Recurrent &amp; \(O(n\cdot d^&#123;2&#125;)\) &amp; \(O(n)\) &amp; \(O(n)\) \\ Convolutional &amp; \(O(k\cdot n\cdot d^&#123;2&#125;)\) &amp; \(O(1)\) &amp; \(O(log_&#123;k&#125;(n))\) \\ Self-Attention (restricted) &amp; \(O(r\cdot n\cdot d)\) &amp; \(O(1)\) &amp; \(O(n/r)\) \\ \hline \hline \end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br><span class="line">Table 1: Maximum path lengths, per-layer complexity and minimum number of sequential operations for different layer types. \(n\) is the sequence length, \(d\) is the representation dimension, \(k\) is the kernel size of convolutions and \(r\) the size of the neighborhood in restricted self-attention.</span><br></pre></td></tr></table></figure><p>可以看到解析后的表格数据以<code>\begin&#123;table&#125;</code>和<code>\end&#123;table&#125;</code>标签包裹，表格的每一行以<code>\\</code>分隔，每一列以<code>&amp;</code>分隔。<code>\end&#123;table&#125;</code>标签之后的一段文字是对表格的解释说明。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>了解了表格的解析格式后，我们就可以编写代码来提取这些信息，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">mmd_path = <span class="string">&quot;attention_is_all_you_need.mmd&quot;</span></span><br><span class="line"><span class="comment"># 打开文件并读取内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(mmd_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式匹配表格内容和表格后一行内容</span></span><br><span class="line">pattern = <span class="string">r&quot;\\begin&#123;table&#125;(.*?)\\end&#123;table&#125;\n(.*?)\n&quot;</span></span><br><span class="line">matches = re.findall(pattern, content, re.DOTALL)</span><br><span class="line"></span><br><span class="line">tables = []</span><br><span class="line"><span class="comment"># 添加匹配结果</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:</span><br><span class="line">    tables.append(<span class="string">f&quot;<span class="subst">&#123;<span class="keyword">match</span>[<span class="number">0</span>]&#125;</span><span class="subst">&#123;<span class="keyword">match</span>[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>我们使用正则表格式来获取表格内容以及表格后一行文本内容</li><li>匹配后的结果中<code>match[0]</code>是表格内容，<code>match[1]</code>是表格后一行的文本说明</li><li>将匹配结果保存到<code>tables</code>列表中</li></ul><p>接下来我们可以使用 LlamaIndex 来对解析后的表格数据进行索引和检索，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"><span class="keyword">from</span> llama_index.core.schema <span class="keyword">import</span> TextNode</span><br><span class="line"></span><br><span class="line">question = <span class="string">&quot;when layer type is Convolutional, what is the Maximum Path Length?&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;question: <span class="subst">&#123;question&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">nodes = [TextNode(text=t) <span class="keyword">for</span> t <span class="keyword">in</span> tables]</span><br><span class="line">vector_index = VectorStoreIndex(nodes)</span><br><span class="line">query_engine = vector_index.as_query_engine(similarity_top_k=<span class="number">2</span>)</span><br><span class="line">response = query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;answer: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Source nodes: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> response.source_nodes:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node text: <span class="subst">&#123;node.text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>我们首先将<code>tabels</code>列表中的表格内容转换为<code>TextNode</code>对象</li><li>然后使用<code>VectorStoreIndex</code>将<code>TextNode</code>对象转换为索引</li><li>使用<code>query</code>方法对问题进行检索，获取检索结果</li></ul><p>RAG 检索的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">question: when layer <span class="built_in">type</span> is Convolutional, what is the Maximum Path Length?</span><br><span class="line">answer: The Maximum Path Length <span class="keyword">for</span> the Convolutional layer <span class="built_in">type</span> is \(O(log_&#123;k&#125;(n))\).</span><br><span class="line">Source nodes:</span><br><span class="line">node text:</span><br><span class="line">\begin&#123;tabular&#125;&#123;l c c c&#125; \hline \hline Layer Type &amp; Complexity per Layer &amp; Sequential Operations &amp; Maximum Path Length \\ \hline Self-Attention &amp; \(O(n^&#123;2&#125;\cdot d)\) &amp; \(O(1)\) &amp; \(O(1)\) \\ Recurrent &amp; \(O(n\cdot d^&#123;2&#125;)\) &amp; \(O(n)\) &amp; \(O(n)\) \\ Convolutional &amp; \(O(k\cdot n\cdot d^&#123;2&#125;)\) &amp; \(O(1)\) &amp; \(O(log_&#123;k&#125;(n))\) \\ Self-Attention (restricted) &amp; \(O(r\cdot n\cdot d)\) &amp; \(O(1)\) &amp; \(O(n/r)\) \\ \hline \hline \end&#123;tabular&#125;</span><br><span class="line">Table 1: Maximum path lengths, per-layer complexity and minimum number of sequential operations <span class="keyword">for</span> different layer types. \(n\) is the sequence length, \(d\) is the representation dimension, \(k\) is the kernel size of convolutions and \(r\) the size of the neighborhood <span class="keyword">in</span> restricted self-attention.</span><br><span class="line"></span><br><span class="line">node text:</span><br><span class="line">\begin&#123;tabular&#125;&#123;l c c c c&#125; \hline \hline \multirow&#123;2&#125;&#123;*&#125;&#123;Model&#125; &amp; \multicolumn&#123;2&#125;&#123;c&#125;&#123;BLEU&#125; &amp; \multicolumn&#123;2&#125;&#123;c&#125;&#123;Training Cost (FLOPs)&#125; \\ \cline&#123;2-5&#125;  &amp; EN-DE &amp; EN-FR &amp; EN-DE &amp; EN-FR \\ \hline ByteNet [18] &amp; 23.75 &amp; &amp; &amp; \\ Deep-Att + PosUnk [39] &amp; &amp; 39.2 &amp; &amp; \(1.0\cdot 10^&#123;20&#125;\) \\ GNMT + RL [38] &amp; 24.6 &amp; 39.92 &amp; \(2.3\cdot 10^&#123;19&#125;\) &amp; \(1.4\cdot 10^&#123;20&#125;\) \\ ConvS2S [9] &amp; 25.16 &amp; 40.46 &amp; \(9.6\cdot 10^&#123;18&#125;\) &amp; \(1.5\cdot 10^&#123;20&#125;\) \\ MoE [32] &amp; 26.03 &amp; 40.56 &amp; \(2.0\cdot 10^&#123;19&#125;\) &amp; \(1.2\cdot 10^&#123;20&#125;\) \\ \hline Deep-Att + PosUnk Ensemble [39] &amp; &amp; 40.4 &amp; &amp; \(8.0\cdot 10^&#123;20&#125;\) \\ GNMT + RL Ensemble [38] &amp; 26.30 &amp; 41.16 &amp; \(1.8\cdot 10^&#123;20&#125;\) &amp; \(1.1\cdot 10^&#123;21&#125;\) \\ ConvS2S Ensemble [9] &amp; 26.36 &amp; **41.29** &amp; \(7.7\cdot 10^&#123;19&#125;\) &amp; \(1.2\cdot 10^&#123;21&#125;\) \\ \hline Transformer (base model) &amp; 27.3 &amp; 38.1 &amp; &amp; \(\mathbf&#123;3.3\cdot 10^&#123;18&#125;&#125;\) \\ Transformer (big) &amp; **28.4** &amp; **41.8** &amp; &amp; \(2.3\cdot 10^&#123;19&#125;\) \\ \hline \hline \end&#123;tabular&#125;</span><br><span class="line">Table 2: The Transformer achieves better BLEU scores than previous state-of-the-art models on the English-to-German and English-to-French newstest2014 tests at a fraction of the training cost.</span><br></pre></td></tr></table></figure><p>根据我们的问题，RAG 的结果为<code>O(log_&#123;k&#125;(n)</code>，这与原始表格中的内容一致（见下图），同时可以看到 RAG 过程中根据问题检索到的文档信息包括了表格 1 和表格 2，其中表格 1 是我们问题的答案来源。</p><img src="/images/post/2024/05/nougat-table-verify.png" class="" width="1000" height="600"><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种方案有如下的优点和缺点：</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以完美支持学术论文文档的解析</li><li>解析结果清晰易理解且容易处理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Nougat 是用学术论文进行训练的模型，因此对学术论文文档解析效果很好，但其他类型的 PDF 文档解析效果可能不尽人意</li><li>只对英文文档支持较好，对其他语言的支持有限</li><li>需要 GPU 机器进行解析加速</li></ul><h2 id="UnstructuredIO-方案"><a href="#UnstructuredIO-方案" class="headerlink" title="UnstructuredIO 方案"></a>UnstructuredIO 方案</h2><img src="/images/post/2024/05/uio-flow.png" class="" width="1000" height="600"><p>这种方案是先将 PDF 文件转换成 HTML 文件，然后使用 <a href="https://github.com/Unstructured-IO/unstructured">UnstructuredIO</a> 来解析 HTML 文件，LlamaIndex 已经对 UnstructuredIO 进行了集成，因此可以很方便地将对 HTML 文件进行 RAG 的流程处理，包括文件的索引、存储和检索。</p><p><strong>为什么要转成 HTML 文件？</strong>在 PDF 文件中表格的内容不容易识别，而在 HTML 文件中表格的内容一般以<code>table</code>的标签来表示，可以很容易地解析和提取表格数据。LlamaIndex 在集成 UnstructuredIO 时只实现了对 HTML 文件的解析，我猜测是因为 HTML 文件的解析相对简单，虽然 UnstructuredIO 本身也支持 PDF 文件的解析，但是 PDF 文件的解析需要依赖第三方的模型和工具，整体实施起来会比较复杂。</p><h3 id="PDF-转-HTML"><a href="#PDF-转-HTML" class="headerlink" title="PDF 转 HTML"></a>PDF 转 HTML</h3><p>在开源社区中有很多工具可以将 PDF 文件转换成 HTML 文件，其中比较出名的是 <a href="https://github.com/pdf2htmlEX/pdf2htmlEX">pdf2htmlEX</a>，但经过测试发现在 pdf2htmlEX 解析出来的 HTML 文件中，表格的内容并没有以<code>table</code>标签进行展示，而是以<code>div</code>标签来表示（如下图所示），这使得我们无法使用 UnstructuredIO 来解析表格内容，因此我们需要使用其他工具来转换 PDF。</p><img src="/images/post/2024/05/pdf2htmlEX-table.png" class="" width="1000" height="600"><p>这里推荐一个名为 <a href="https://apryse.com/">WebViewer</a> 的文档工具，提供了常用文档的编辑功能，其中包括我们需要的 PDF 转 HTML 功能，并且它提供了多种开发语言的 SDK 包，方便在各种项目中集成使用。下面我们就以 Python 为例来介绍如何使用这个工具转换 PDF 文件为 HTML 文件。</p><p>首先在其<a href="https://apryse.com/">官网</a>进行注册，注册后在<a href="https://dev.apryse.com/">这个页面</a>可以获得<code>trial key</code>，后面使用 SDK 包时需要填写这个 key。</p><img src="/images/post/2024/05/apryse-key.png" class="" width="1000" height="600"><p>然后使用 pip 安装 SDK 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install apryse-sdk --extra-index-url=https://pypi.apryse.com</span><br></pre></td></tr></table></figure><p>另外还需要下载 SDK 包关联的结构化输出模块包，Mac OS 系统的包下载地址是<a href="https://docs.apryse.com/downloads/StructuredOutputMac.zip">这里</a>，下载完成后解压缩，然后将解压后的文件夹放到项目的根目录下，解压后的目录名为<code>Lib</code>。</p><p>下面是示例代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apryse_sdk <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">PDFNet.Initialize(<span class="string">&quot;your_trial_key&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&quot;demo&quot;</span></span><br><span class="line">input_filename = <span class="string">f&quot;<span class="subst">&#123;file_name&#125;</span>.pdf&quot;</span></span><br><span class="line">output_dir = <span class="string">&quot;output&quot;</span></span><br><span class="line"></span><br><span class="line">PDFNet.AddResourceSearchPath(<span class="string">&quot;./Lib&quot;</span>)</span><br><span class="line"></span><br><span class="line">htmlOutputOptions = HTMLOutputOptions()</span><br><span class="line">htmlOutputOptions.SetContentReflowSetting(HTMLOutputOptions.e_reflow_full)</span><br><span class="line"></span><br><span class="line">Convert.ToHtml(input_filename, <span class="string">f&quot;<span class="subst">&#123;output_dir&#125;</span>/<span class="subst">&#123;file_name&#125;</span>.html&quot;</span>, htmlOutputOptions)</span><br></pre></td></tr></table></figure><ul><li>首先通过<code>PDFNet.Initialize</code>函数初始化 SDK 包，填写之前注册后得到的<code>trial key</code></li><li>使用<code>PDFNet.AddResourceSearchPath</code>添加解压后的结构化输出模块包路径，这里的目录名为<code>Lib</code></li><li>使用<code>HTMLOutputOptions</code> 设置 HTML 输出选项，这里的设置表示输出的 HTML 会整合成一个完整的页面</li><li>最后使用<code>Convert.ToHtml</code>函数对 PDF 文件进行转换，转换后的 HTML 文件会保存在<code>output</code>目录下</li></ul><p>转换后的 HTML 文件我们可以看到，其中的表格内容是以<code>table</code>的标签来表示的，关于使用 WebViewer 来转换 PDF 文件为 HTML 文件的更多信息可以参考<a href="https://docs.apryse.com/documentation/mac/guides/features/conversion/convert-pdf-to-html/">这里</a>。</p><h3 id="HTML-文件处理"><a href="#HTML-文件处理" class="headerlink" title="HTML 文件处理"></a>HTML 文件处理</h3><p>得到 HTML 文件后，我们就可以使用 LlamaIndex 中集成的 UnstructuredIO 解析功能来解析 HTML 中的表格内容了，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> llama_index.readers.file <span class="keyword">import</span> FlatReader</span><br><span class="line"><span class="keyword">from</span> llama_index.core.node_parser <span class="keyword">import</span> UnstructuredElementNodeParser</span><br><span class="line"></span><br><span class="line">reader = FlatReader()</span><br><span class="line">demo_file = reader.load_data(Path(<span class="string">&quot;demo.html&quot;</span>))</span><br><span class="line">node_parser = UnstructuredElementNodeParser()</span><br><span class="line"></span><br><span class="line">pkl_file = <span class="string">&quot;demo.pkl&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(pkl_file):</span><br><span class="line">    raw_nodes = node_parser.get_nodes_from_documents(demo_file)</span><br><span class="line">    pickle.dump(raw_nodes, <span class="built_in">open</span>(pkl_file, <span class="string">&quot;wb&quot;</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    raw_nodes = pickle.load(<span class="built_in">open</span>(pkl_file, <span class="string">&quot;rb&quot;</span>))</span><br><span class="line"></span><br><span class="line">base_nodes, node_mappings = node_parser.get_base_nodes_and_mappings(raw_nodes)</span><br></pre></td></tr></table></figure><ul><li>代码中使用<code>FlatReader</code>读取 HTML 文件内容</li><li>使用<code>UnstructuredElementNodeParser</code>解析 HTML 文件内容，得到原始节点数据</li><li>将解析后的节点数据保存到<code>demo.pkl</code>文件中，方便后续使用</li><li>最后通过原始节点数据得到解析后的节点数据<code>base_nodes</code>和节点映射<code>node_mappings</code></li></ul><p>解析完 HTML 文件后会得到普通文本的节点和包含表格的节点，这里我们使用这个<a href="https://qwenlm.github.io/blog/qwen-vl/">介绍 Qwen-VL 多模态模型的 HTML 页面</a>作为测试数据，因为里面有不少表格，来看看解析后的表格具体内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.schema <span class="keyword">import</span> IndexNode, TextNode</span><br><span class="line"></span><br><span class="line">example_index_nodes = [b <span class="keyword">for</span> b <span class="keyword">in</span> base_nodes <span class="keyword">if</span> <span class="built_in">isinstance</span>(b, IndexNode)]</span><br><span class="line">example_index_node = example_index_nodes[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">f&quot;\n--------\n<span class="subst">&#123;example_index_node.get_content(metadata_mode=<span class="string">&#x27;all&#x27;</span>)&#125;</span>\n--------\n&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n--------\nIndex ID: <span class="subst">&#123;example_index_node.index_id&#125;</span>\n--------\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">f&quot;\n--------\n<span class="subst">&#123;node_mappings[example_index_node.index_id].get_content()&#125;</span>\n--------\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>从解析后的节点数据中找到包含表格的节点，其中<code>IndexNode</code>是包含表格的节点</li><li>我们通过<code>example_index_nodes[1]</code>来获取第 2 个表格的数据</li><li>分别打印出表格的内容、索引 ID 和节点映射的内容</li></ul><p>打印出来的节点信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表格字段</span></span><br><span class="line">--------</span><br><span class="line">col_schema: Column: Model</span><br><span class="line">Type: string</span><br><span class="line">Summary: Names of the AI models compared</span><br><span class="line"></span><br><span class="line">...other columns...</span><br><span class="line"></span><br><span class="line">filename: Qwen-VL.html</span><br><span class="line">extension: .html</span><br><span class="line"><span class="comment"># 表格的总结信息</span></span><br><span class="line">Comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks such as DocVQA, ChartQA, AI2D, TextVQA, MMMU, MathVista, and MM-Bench-CN.,</span><br><span class="line">with the following table title:</span><br><span class="line">AI Model Performance Comparison,</span><br><span class="line">with the following columns:</span><br><span class="line">- Model: Names of the AI models compared</span><br><span class="line">...other columns...</span><br><span class="line">--------</span><br><span class="line"><span class="comment"># 表格节点ID</span></span><br><span class="line">--------</span><br><span class="line">Index ID: 41edc9a6-30ed-44cf-967e-685f7dfce8df</span><br><span class="line">--------</span><br><span class="line"><span class="comment"># mapping中的表格数据</span></span><br><span class="line">--------</span><br><span class="line">Comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks such as DocVQA, ChartQA, AI2D, TextVQA, MMMU, MathVista, and MM-Bench-CN.,</span><br><span class="line">with the following table title:</span><br><span class="line">AI Model Performance Comparison,</span><br><span class="line">with the following columns:</span><br><span class="line">- Model: Names of the AI models compared</span><br><span class="line">...other columns...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Markdown格式的表格内容</span></span><br><span class="line">|Model|DocVQA|ChartQA|AI2D|TextVQA|MMMU|MathVista|MM-Bench-CN|</span><br><span class="line">|---|---|---|---|---|---|---|---|</span><br><span class="line">|Other Best Open-<span class="built_in">source</span> LVLM|81.6% (CogAgent)|68.4% (CogAgent)|73.7% (Fuyu-Medium)|76.1% (CogAgent)|45.9% (Yi-VL-34B)|36.7% (SPHINX-V2)|72.4% (InternLM-XComposer-VL)|</span><br><span class="line">|Gemini Pro|88.1%|74.1%|73.9%|74.6%|47.9%|45.2%|74.3%|</span><br><span class="line">|Gemini Ultra|90.9%|80.8% 1|79.5% 1|82.3% 1|59.4% 1|53.0% 1|-|</span><br><span class="line">|GPT-4V|88.4%|78.5%|78.2%|78.0%|56.8%|49.9%|73.9%|</span><br><span class="line">|Qwen-VL-Plus|91.4%|78.1%|75.9%|78.9%|45.2%|43.3%|68.0%|</span><br><span class="line">|Qwen-VL-Max|93.1% 1|79.8% 2|79.3% 2|79.5% 2|51.4% 3|51.0% 2|75.1% 1|</span><br><span class="line">--------</span><br></pre></td></tr></table></figure><p>从打印结果中我们可以看到，LlamaIndex 对表格的每个字段进行了总结，然后对整个表也进行了总结，最后还将表格内容转换成了 Markdown 格式。</p><p>接下来我们使用 LlamaIndex 的递归检索器来检索表格内容，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"><span class="keyword">from</span> llama_index.core.retrievers <span class="keyword">import</span> RecursiveRetriever</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> RetrieverQueryEngine</span><br><span class="line"></span><br><span class="line">vector_index = VectorStoreIndex(base_nodes)</span><br><span class="line">vector_retriever = vector_index.as_retriever(similarity_top_k=<span class="number">1</span>)</span><br><span class="line">vector_query_engine = vector_index.as_query_engine(similarity_top_k=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">recursive_retriever = RecursiveRetriever(</span><br><span class="line">    <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">    retriever_dict=&#123;<span class="string">&quot;vector&quot;</span>: vector_retriever&#125;,</span><br><span class="line">    node_dict=node_mappings,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">query_engine = RetrieverQueryEngine.from_args(recursive_retriever)</span><br><span class="line">question = <span class="string">&quot;In the comparison of performance metrics for different AI models across various tasks. What is the performance metric of the model &#x27;Qwen-VL-Plus&#x27; in task &#x27;MMMU&#x27;? Tell me the exact number.&quot;</span></span><br><span class="line">response = query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;answer: <span class="subst">&#123;<span class="built_in">str</span>(response)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Retrieving <span class="keyword">with</span> query <span class="built_in">id</span> <span class="literal">None</span>: In the comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks. What <span class="keyword">is</span> the performance metric of the model <span class="string">&#x27;Qwen-VL-Plus&#x27;</span> <span class="keyword">in</span> task <span class="string">&#x27;MMMU&#x27;</span>? Tell me the exact number.</span><br><span class="line">Retrieved node <span class="keyword">with</span> <span class="built_in">id</span>, entering: 41edc9a6-30ed-44cf-967e-685f7dfce8df</span><br><span class="line">Retrieving <span class="keyword">with</span> query <span class="built_in">id</span> 41edc9a6-30ed-44cf-967e-685f7dfce8df: In the comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks. What <span class="keyword">is</span> the performance metric of the model <span class="string">&#x27;Qwen-VL-Plus&#x27;</span> <span class="keyword">in</span> task <span class="string">&#x27;MMMU&#x27;</span>? Tell me the exact number.</span><br><span class="line"></span><br><span class="line">answer: The performance metric of the model <span class="string">&#x27;Qwen-VL-Plus&#x27;</span> <span class="keyword">in</span> the task <span class="string">&#x27;MMMU&#x27;</span> <span class="keyword">is</span> <span class="number">45.2</span>%.</span><br></pre></td></tr></table></figure><ul><li>代码中首先使用<code>VectorStoreIndex</code>将解析后的节点数据转换为索引</li><li>然后使用索引构建检索器和查询引擎，这里将<code>similarity_top_k</code>同时设置为 1，表示只返回最相似的一个结果</li><li>使用<code>RecursiveRetriever</code>构建递归检索器，传入检索器和节点映射信息，然后构建查询引擎</li><li>最后使用查询引擎对问题进行检索，获取检索结果</li></ul><p>显示结果上半部分是递归检索的调试信息，从调试信息中我们可以看到，根据问题检索到的表格内容（返回了表格的节点 ID），然后根据表格内容回答了问题，答案是 45.2%，对比原表格数据（如下图所示），结果正确。</p><img src="/images/post/2024/05/uio-verify.png" class="" width="1000" height="600"><p><strong>注意</strong>：如果在调试信息中没有看到节点 ID，表示根据问题检索不到相关的表格内容，这种情况最终的回答可能是错误的，这可能是用户问题与表格的总结信息不匹配导致检索失败，可以调整问题然后重新检索。</p><h3 id="准确率验证"><a href="#准确率验证" class="headerlink" title="准确率验证"></a>准确率验证</h3><p>我们只验证了表格其中一个单元格的内容，下面我们来验证表格所有单元格的内容，这样我们可以大致得到这种方案的准确率，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">models = [</span><br><span class="line">    <span class="string">&quot;Other BestOpen-source LVLM&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gemini Pro&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gemini Ultra&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GPT-4V&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Qwen-VL-Plus&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Qwen-VL-Max&quot;</span>,</span><br><span class="line">]</span><br><span class="line">metrics = [<span class="string">&quot;DocVQA&quot;</span>, <span class="string">&quot;ChartQA&quot;</span>, <span class="string">&quot;AI2D&quot;</span>, <span class="string">&quot;TextVQA&quot;</span>, <span class="string">&quot;MMMU&quot;</span>, <span class="string">&quot;MathVista&quot;</span>, <span class="string">&quot;MM-Bench-CN&quot;</span>]</span><br><span class="line">questions = []</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    <span class="keyword">for</span> metric <span class="keyword">in</span> metrics:</span><br><span class="line">        questions.append(</span><br><span class="line">            <span class="string">f&quot;In the comparison of performance metrics for different AI models across various tasks. What is the performance metric of the model &#x27;<span class="subst">&#123;model&#125;</span>&#x27; in task &#x27;<span class="subst">&#123;metric&#125;</span>&#x27;? Tell me the exact number.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">actual_metrics = [</span><br><span class="line">    <span class="number">81.6</span>, <span class="number">68.4</span>, <span class="number">73.7</span>, <span class="number">76.1</span>, <span class="number">45.9</span>, <span class="number">36.7</span>, <span class="number">72.4</span>,</span><br><span class="line">    <span class="number">88.1</span>, <span class="number">74.1</span>, <span class="number">73.9</span>, <span class="number">74.6</span>, <span class="number">47.9</span>, <span class="number">45.2</span>, <span class="number">74.3</span>,</span><br><span class="line">    <span class="number">90.9</span>, <span class="number">80.8</span>, <span class="number">75.9</span>, <span class="number">82.3</span>, <span class="number">59.4</span>, <span class="number">53</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">88.4</span>, <span class="number">78.5</span>, <span class="number">78.2</span>, <span class="number">78</span>, <span class="number">56.8</span>, <span class="number">49.9</span>, <span class="number">73.9</span>,</span><br><span class="line">    <span class="number">91.4</span>, <span class="number">78.1</span>, <span class="number">75.9</span>, <span class="number">78.9</span>, <span class="number">45.2</span>, <span class="number">43.3</span>, <span class="number">68</span>,</span><br><span class="line">    <span class="number">93.1</span>, <span class="number">79.8</span>, <span class="number">79.3</span>, <span class="number">79.5</span>, <span class="number">51.4</span>, <span class="number">51</span>, <span class="number">75.1</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">actual_answers = <span class="built_in">dict</span>(<span class="built_in">zip</span>(questions, actual_metrics))</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> questions:</span><br><span class="line">  response = query_engine.query(q)</span><br><span class="line">  answer = <span class="built_in">str</span>(response)</span><br><span class="line">  result[q] = <span class="built_in">str</span>(actual_answers[q]) <span class="keyword">in</span> answer</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;question: <span class="subst">&#123;q&#125;</span>\nresponse: <span class="subst">&#123;answer&#125;</span>\nactual:<span class="subst">&#123;actual_answers[q]&#125;</span>\nresult:<span class="subst">&#123;result[q]&#125;</span>\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">correct = <span class="built_in">sum</span>(result.values())</span><br><span class="line">total = <span class="built_in">len</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Percentage of True values: <span class="subst">&#123;correct / total * <span class="number">100</span>&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>代码中我们构造了 42 个问题，每个问题都是关于表格中不同 AI 模型在不同任务中的性能指标</li><li>然后我们通过查询引擎对这些问题进行检索，获取检索结果</li><li>最后我们将检索结果与实际的性能指标进行比较，计算准确率</li></ul><p>计算结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Retrieving with query <span class="built_in">id</span> None: In comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks. What is the performance metric of the model <span class="string">&#x27;Other BestOpen-source LVLM&#x27;</span> <span class="keyword">in</span> task <span class="string">&#x27;DocVQA&#x27;</span>? Tell me the exact number.</span><br><span class="line">Retrieved node with <span class="built_in">id</span>, entering: 41edc9a6-30ed-44cf-967e-685f7dfce8df</span><br><span class="line">Retrieving with query <span class="built_in">id</span> 41edc9a6-30ed-44cf-967e-685f7dfce8df: In comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks. What is the performance metric of the model <span class="string">&#x27;Other BestOpen-source LVLM&#x27;</span> <span class="keyword">in</span> task <span class="string">&#x27;DocVQA&#x27;</span>? Tell me the exact number.</span><br><span class="line"></span><br><span class="line">question: In the comparison of performance metrics <span class="keyword">for</span> different AI models across various tasks. What is the performance metric of the model <span class="string">&#x27;Other BestOpen-source LVLM&#x27;</span> <span class="keyword">in</span> task <span class="string">&#x27;DocVQA&#x27;</span>? Tell me the exact number.</span><br><span class="line">response: 81.6%</span><br><span class="line">actual:81.6</span><br><span class="line">result:True</span><br><span class="line"></span><br><span class="line">...other questions...</span><br><span class="line"></span><br><span class="line">Percentage of True values: 66.66666666666666%</span><br></pre></td></tr></table></figure><p>当验证了表格中所有单元单元格的内容后，我们得到的准确率为 <strong>66.67</strong>%，这说明这种方案在检索表格内容时并不是百分之百正确，但这个准确率在现有方案中已经算比较高的了。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种方案有如下的优点和缺点：</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>无需使用 OCR 技术</li><li>无需使用 GPU 服务器进行来转换 PDF 文件</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>需要使用第三方工具将 PDF 文件转换为 HTML 文件</li><li>用户问题要与表格的总结信息匹配才能获得正确的检索结果</li></ul><h2 id="GPT4o-方案"><a href="#GPT4o-方案" class="headerlink" title="GPT4o 方案"></a>GPT4o 方案</h2><img src="/images/post/2024/05/gpt4o-flow.png" class="" width="1000" height="600"><p>最后一种方案是使用 OpenAI 的最新模型 GPT4o 来处理表格内容，GPT4o 在图片识别能力上得到了很大的提升，可以轻松识别出以前 GPT4 模型无法识别的内容。LlamaIndex 的 LlamaParse 工具已经对 GPT4o 进行了集成，可以将 PDF 文件转换成 Markdown 格式的内容，然后进行 RAG 的检索流程。</p><p>首先需要到<a href="https://cloud.llamaindex.ai/">LlamaCloud</a>上注册账号，注册完成后可以创建 API Key，后面的代码示例中需要用到这个 Key。</p><img src="/images/post/2024/05/llama-parse-key.png" class="" width="1000" height="600"><p>然后使用 pip 安装 LlamaParse：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install llama-parse</span><br></pre></td></tr></table></figure><p>接下来我们使用 LlamaParse 将 PDF 文件转换为 Markdown 格式的内容，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_parse <span class="keyword">import</span> LlamaParse</span><br><span class="line"></span><br><span class="line">parser_gpt4o = LlamaParse(</span><br><span class="line">    result_type=<span class="string">&quot;markdown&quot;</span>,</span><br><span class="line">    api_key=<span class="string">&quot;&lt;llama_parse_api_key&gt;&quot;</span>,</span><br><span class="line">    gpt4o_mode=<span class="literal">True</span>,</span><br><span class="line">    gpt4o_api_key=<span class="string">&quot;&lt;openai_api_key&gt;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pdf_file = <span class="string">&quot;demo.pdf&quot;</span></span><br><span class="line">pkl_file = <span class="string">&quot;demo.pkl&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(pkl_file):</span><br><span class="line">    documents_gpt4o = parser_gpt4o.load_data(pdf_file)</span><br><span class="line">    pickle.dump(documents_gpt4o, <span class="built_in">open</span>(pkl_file, <span class="string">&quot;wb&quot;</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    documents_gpt4o = pickle.load(<span class="built_in">open</span>(pkl_file, <span class="string">&quot;rb&quot;</span>))</span><br></pre></td></tr></table></figure><ul><li>代码中首先创建一个 LlamaParse 对象，传入 OpenAI API Key 以及我们刚才注册后获得的 LlamaParse API Key</li><li>然后使用<code>load_data</code>方法将 PDF 文件转换为 Markdown 格式的内容，转换后的 Markdown 内容会保存在<code>demo.pkl</code>文件中</li><li>最后将转换后的 Markdown 内容保存到<code>documents_gpt4o</code>变量中</li></ul><p>执行完程序后，LlamaParse 会将整个 PDF 文件转换为 Markdown 格式，我们来看下转换后的 Markdown 中的表格内容：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| Model          | DocVQA | ChartQA | AI2D  | TextVQA | MMMU  | MathVista | MM-Bench-CN |</span><br><span class="line">|----------------|--------|---------|-------|---------|-------|-----------|-------------|</span><br><span class="line">| Other Best Open-source LLM | 81.6% (Capypage) | 68.4% (Capypage) | 73.7% (Capypage) | 74.3% (Capypage) | 76.1% (Capypage) | 45.9% (Capypage) | 36.7% (Capypage) | 72.4% (Capypage) |</span><br><span class="line">| Gemini Pro     | 88.1%  | 74.1%   | 73.9% | 74.6%   | 47.9% | 45.2%     | 74.3%       |</span><br><span class="line">| Gemini Ultra   | 90.9%  | 80.8%   | 75.9% | 82.3%   | 59.4% | 53.0%     | 75.1%       |</span><br><span class="line">| GPT-4V         | 88.8%  | 78.4%   | 75.9% | 80.9%   | 53.9% | 51.0%     | 75.1%       |</span><br><span class="line">| Qwen-VL-Plus   | 88.2%  | 78.1%   | 75.9% | 80.9%   | 45.2% | 51.0%     | 75.1%       |</span><br><span class="line">| Qwen-VL-Max    | 79.8%  | 79.8%   | 79.3% | 79.2%   | 51.4% | 51.0%     | 75.1%       |</span><br></pre></td></tr></table></figure><p>我们再使用 LlamaIndex 对 Markdown 内容进行索引和检索，代码示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_nodes</span>(<span class="params">docs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Split docs into nodes, by separator.&quot;&quot;&quot;</span></span><br><span class="line">    nodes = []</span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">        doc_chunks = doc.text.split(<span class="string">&quot;\n---\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> doc_chunk <span class="keyword">in</span> doc_chunks:</span><br><span class="line">            node = TextNode(</span><br><span class="line">                text=doc_chunk,</span><br><span class="line">                metadata=deepcopy(doc.metadata),</span><br><span class="line">            )</span><br><span class="line">            nodes.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line"></span><br><span class="line">nodes = get_nodes(documents_gpt4o)</span><br><span class="line">vector_index = VectorStoreIndex(nodes)</span><br><span class="line">query_engine = vector_index.as_query_engine(similarity_top_k=<span class="number">2</span>)</span><br><span class="line">question = <span class="string">&quot;In the comparison of performance metrics for different AI models across various tasks. What is the performance metric of the model &#x27;Qwen-VL-Plus&#x27; in task &#x27;MMMU&#x27;? Tell me the exact number.&quot;</span></span><br><span class="line">response = query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;answer: <span class="subst">&#123;<span class="built_in">str</span>(response)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">answer: The performance metric of the model <span class="string">&#x27;Qwen-VL-Plus&#x27;</span> <span class="keyword">in</span> the task <span class="string">&#x27;MMMU&#x27;</span> <span class="keyword">is</span> <span class="number">45.2</span>%.</span><br></pre></td></tr></table></figure><ul><li>LlamaParse 在解析 PDF 文件时会在 Markdown 内容中添加<code>---</code>这样的分页标签，我们通过这个标签将 Markdown 内容分割成多个节点，然后将这些节点转换为<code>TextNode</code>对象</li><li>剩下的代码就是常规的索引和检索流程</li><li>可以看到 GPT4o 的检索结果也同样正确</li></ul><p>我们再对 GPT4o 方案的准确率进行验证，也就是验证表格中每个单元格的内容，代码可以参考前面的示例代码，计算结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Percentage of True values: 47.61904761904761%</span><br></pre></td></tr></table></figure><p>当验证了表格中所有单元单元格的内容后，我们得到的准确率为 <strong>47.62</strong>%，与 UnstructuredIO 方案相比，这种方案的准确率较低。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种方案有如下的优点和缺点：</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>可以直接解析 PDF 文件，无需转换成其他格式的文件</li><li>不管文件中的内容是文字还是图片，都可以进行解析</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>LlamaParse 虽然每天有免费的调用次数，但是如果需要大量调用，还是需要付费</li><li>目前使用多模态模型解析 PDF 文件的准确率还是比较低，需要进一步优化</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了三种方案来解析 PDF 文件中的表格内容，分别是 Nougat 方案、UnstructuredIO 方案和 GPT4o 方案，这三种方案各有优缺点，目前还没有一种方案可以完美地满足所有的业务需求，但相信在不远的将来会有更多的新技术出现，来解决这个问题。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><ul><li><a href="https://ai.plainenglish.io/advanced-rag-07-exploring-rag-for-tables-5c3fc0de7af6">Advanced RAG 07: Exploring RAG for Tables</a></li><li><a href="https://levelup.gitconnected.com/a-guide-to-processing-tables-in-rag-pipelines-with-llamaindex-and-unstructuredio-3500c8f917a7">A Guide to Processing Tables in RAG Pipelines with LlamaIndex and UnstructuredIO</a></li></ul>]]></content>
    
    
    <summary type="html">介绍高级 RAG 检索中几种内嵌表格的解析检索方案</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="embedded-table" scheme="https://zhaozhiming.github.io/tags/embedded-table/"/>
    
    <category term="llama-parser" scheme="https://zhaozhiming.github.io/tags/llama-parser/"/>
    
    <category term="gpt4o" scheme="https://zhaozhiming.github.io/tags/gpt4o/"/>
    
  </entry>
  
  <entry>
    <title>高级 RAG 检索策略之查询重写</title>
    <link href="https://zhaozhiming.github.io/2024/05/13/query-rewrite-rag/"/>
    <id>https://zhaozhiming.github.io/2024/05/13/query-rewrite-rag/</id>
    <published>2024-05-13T14:18:11.000Z</published>
    <updated>2024-10-03T08:49:29.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/05/rag-query-rewrite.jpeg" class="" width="400" height="300"><p>在 RAG（Retrieval Augmented Generation）应用中，文档检索是保证 RAG 应用高质量回答的关键环节，我们在之前的文章中也有所介绍，但除此之外，对用户问题的优化也同样重要，有时候用户的问题可能不够清晰或者不够具体，这时候就需要对用户问题进行查询重写，这样才能更好地提高检索的准确性。今天我们就来介绍一些 RAG 应用中查询重写的策略，以及了解如何在实际项目中使用它们。</p><span id="more"></span><h2 id="子问题查询"><a href="#子问题查询" class="headerlink" title="子问题查询"></a>子问题查询</h2><p>子问题策略，也称为子查询，是一种用于生成子问题的技术。子问题策略的核心思想是在问答过程中，为了更好地理解和回答主问题，系统会自动生成并提出与主问题相关的子问题。这些子问题通常具有更具体的细节，可以帮助系统更深入地理解主问题，从而进行更加准确的检索并提供正确的答案。</p><img src="/images/post/2024/05/sub-question-flow.png" class="" width="1000" height="400"><ul><li>子问题策略首先将用户问题通过 LLM（大语言模型）生成多个子问题</li><li>然后将每个子问题经过 RAG 流程得到各自的答案（检索-生成）</li><li>最后将所有子问题的答案合并，得到最终的答案</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>在<a href="https://www.llamaindex.ai/">LlamaIndex</a>中已经对子问题查询进行了实现，但在查看子问题查询的效果之前，我们先看普通 RAG 检索对于复杂问题的效果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, SimpleDirectoryReader</span><br><span class="line"></span><br><span class="line">question = <span class="string">&quot;哈莉·奎因和灭霸在《复仇者联盟》中是正义的角色吗？&quot;</span></span><br><span class="line"></span><br><span class="line">documents = SimpleDirectoryReader(<span class="string">&quot;./data&quot;</span>).load_data()</span><br><span class="line">node_parser = VectorStoreIndex.from_documents(documents)</span><br><span class="line">query_engine = node_parser.as_query_engine()</span><br><span class="line">response = query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;base query result: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">base query result: 不，哈莉·奎茵和灭霸在《复仇者联盟》系列中并非被描绘为正义的角色。</span><br></pre></td></tr></table></figure><p>以上代码是 LlamaIndex 的普通 RAG 检索过程，文档数据我们还是使用之前维基百科上的<a href="https://en.wikipedia.org/wiki/Avenger">复仇者联盟</a>电影剧情来进行测试，这里我们问了一个复合问题，包括 2 个人物角色，一个是 DC 漫画中的<code>哈莉·奎茵</code>，另一个是漫威电影中的<code>灭霸</code>，问题是他们在复仇者联盟中是否为正义角色，查询结果虽然可以说正确，但并没有指出其中一个人物不是漫威电影中的人物。</p><p>我们再来看子问题查询的效果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.tools <span class="keyword">import</span> QueryEngineTool, ToolMetadata</span><br><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> SubQuestionQueryEngine</span><br><span class="line"></span><br><span class="line">query_engine_tools = [</span><br><span class="line">    QueryEngineTool(</span><br><span class="line">        query_engine=query_engine,</span><br><span class="line">        metadata=ToolMetadata(</span><br><span class="line">            name=<span class="string">&quot;Avengers&quot;</span>,</span><br><span class="line">            description=<span class="string">&quot;Marvel movie The Avengers&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line">query_engine = SubQuestionQueryEngine.from_defaults(</span><br><span class="line">    query_engine_tools=query_engine_tools</span><br><span class="line">)</span><br><span class="line">response = query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;sub question query result: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">Generated <span class="number">2</span> sub questions.</span><br><span class="line">[Avengers] Q: 哈莉·奎茵在《复仇者联盟》电影中扮演什么角色？</span><br><span class="line">[Avengers] Q: 灭霸在《复仇者联盟》电影中扮演什么角色？</span><br><span class="line">[Avengers] A: 在提供的有关《复仇者联盟》电影的背景中未提到哈莉·奎茵。</span><br><span class="line">[Avengers] A: 灭霸是《复仇者联盟》电影中的主要反派。他是一个强大的战争领主，试图利用无限宝石按照自己的愿景重塑宇宙。灭霸被描绘为强大而无情的敌人，对复仇者联盟和整个宇宙构成重大威胁。</span><br><span class="line">sub question query result: 在提供的有关《复仇者联盟》电影的背景中未提到哈莉·奎茵。灭霸是《复仇者联盟》电影中的主要反派，被描绘为一个强大而无情的敌人。</span><br></pre></td></tr></table></figure><ul><li>首先构建查询引擎工具，在工具中传入普通的查询引擎，并设置工具的元数据，元数据信息在 Debug 信息中会进行展示</li><li>使用<code>SubQuestionQueryEngine</code>类构建子问题查询引擎，传入查询引擎工具</li><li>查询结果中会显示生成的子问题以及子问题的答案，最终答案基于所有子问题的答案进行生成</li></ul><p>从上面的代码可以看出，对于复杂问题，子问题查询的效果要比普通查询更加准确。</p><p>上面的示例中，生成的子问题及答案是随着 Debug 信息展示出来的，我们也可以在检索过程中获取这些数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.callbacks <span class="keyword">import</span> (</span><br><span class="line">    CallbackManager,</span><br><span class="line">    LlamaDebugHandler,</span><br><span class="line">    CBEventType,</span><br><span class="line">    EventPayload,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> Settings</span><br><span class="line"></span><br><span class="line">llama_debug = LlamaDebugHandler(print_trace_on_end=<span class="literal">True</span>)</span><br><span class="line">callback_manager = CallbackManager([llama_debug])</span><br><span class="line">Settings.callback_manager = callback_manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子问题查询代码</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (start_event, end_event) <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">    llama_debug.get_event_pairs(CBEventType.SUB_QUESTION)</span><br><span class="line">):</span><br><span class="line">    qa_pair = end_event.payload[EventPayload.SUB_QUESTION]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sub Question &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;: &quot;</span> + qa_pair.sub_q.sub_question.strip())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Answer: &quot;</span> + qa_pair.answer.strip())</span><br></pre></td></tr></table></figure><ul><li>在子问题查询的代码前面加上回调管理器，用来记录子问题查询的调试信息</li><li>在查询结束后，通过回调管理器获取子问题查询的调试信息，然后得到子问题和答案</li></ul><h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><p>LlamaIndex 使用单独的 Python 包<code>llama-index-question-gen-openai</code>来生成子问题，它的内部默认使用 OpenAI 的模型来生成子问题，提示词模板可以在 <a href="https://github.com/run-llama/llama_index/blob/main/llama-index-integrations/question_gen/llama-index-question-gen-openai/llama_index/question_gen/openai/base.py#L18-L45">LlamaIndex 的官方仓库</a>中查看。</p><p>我们也可以通过以下方法来打印 LlamaIndex 中的提示词，第一种方法是通过<code>get_prompts()</code>方法来打印，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompts = query_engine.get_prompts()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> prompts.keys():</span><br><span class="line">    sub_question_prompt = prompts[key]</span><br><span class="line">    template = sub_question_prompt.get_template()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;prompt: <span class="subst">&#123;template&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>首先通过<code>get_prompts()</code>方法获取查询引擎的 prompts 对象，基本上每个 LlamaIndex 对象都有这个方法</li><li>prompts 对象是个 JSON 对象，它的每个 Key 代表一个提示词模板</li><li>遍历 prompts 对象的每个 Key，获取每个 Key 对应的提示词模板，然后打印出来</li><li>子问题查询会包含 2 个提示词模板，一个是子问题生成的提示词模板，另一个是普通 RAG 的提示词模板</li></ul><p>另外一种方式是通过<code>set_global_handler</code>进行全局设置，示例代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> set_global_handler</span><br><span class="line"></span><br><span class="line">set_global_handler(<span class="string">&quot;simple&quot;</span>)</span><br></pre></td></tr></table></figure><p>在文件开头加上以上代码，这样在执行代码的过程中就会打印出 RAG 检索过程中的提示词，打印出的提示词不是提示词模板，而是加入了具体变量值之后的<strong>完整提示词</strong>。</p><h2 id="HyDE-查询转换"><a href="#HyDE-查询转换" class="headerlink" title="HyDE 查询转换"></a>HyDE 查询转换</h2><img src="/images/post/2024/05/hyde_paper.jpeg" class="" width="1000" height="400"><p>HyDE（Hypothetical Document Embeddings）的本质是通过 LLM 对用户问题生成假设性文档，这些文档基于 LLM 本身的知识生成，可能存在错误或者不准确，但是跟 RAG 中知识库的文档相关联，然后通过假设性文档去检索向量相近的真实文档，通过这种方式来提高检索的准确性，HyDE 的论文可以参考<a href="https://arxiv.org/pdf/2212.10496.pdf">这里</a>。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>在 LlamaIndex 中已经实现了 HyDE 的查询重写，我们先来看 LlamaIndex 如何生成假设性文档：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.indices.query.query_transform <span class="keyword">import</span> HyDEQueryTransform</span><br><span class="line"></span><br><span class="line">question = <span class="string">&quot;洛基使用了哪种神秘物品试图征服地球？&quot;</span></span><br><span class="line"></span><br><span class="line">hyde = HyDEQueryTransform(include_original=<span class="literal">True</span>)</span><br><span class="line">query_bundle = hyde(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;query_bundle embedding len: <span class="subst">&#123;<span class="built_in">len</span>(query_bundle.embedding_strs)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> idx, embedding <span class="keyword">in</span> <span class="built_in">enumerate</span>(query_bundle.embedding_strs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;embedding <span class="subst">&#123;idx&#125;</span>: <span class="subst">&#123;embedding[:<span class="number">100</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">query_bundle embedding <span class="built_in">len</span>: <span class="number">2</span></span><br><span class="line">embedding <span class="number">0</span>: 在他试图征服地球时，洛基使用了立方体，也被称为宇宙立方。这个神秘的...</span><br><span class="line">embedding <span class="number">1</span>: 洛基使用了哪种神秘物品试图征服地球？</span><br></pre></td></tr></table></figure><ul><li>首先构建<code>HyDEQueryTransform</code>对象，传入参数<code>include_original=True</code>，表示在生成的假设性文档中包含原始问题，其实<code>include_original</code>的默认值就是<code>True</code>，这里传入参数只是为了演示</li><li>然后调用<code>hyde</code>对象，传入问题，返回一个<code>QueryBundle</code>对象</li><li><code>QueryBundle</code>对象的<code>embedding_strs</code>属性值是一个数组，数组第一个元素是生成的假设性文档，如果<code>include_original</code>为<code>True</code>，那么数组的第 2 个元素会包含原始问题</li></ul><p>可以看到 LLM 基于自己的知识很好地回答了用户的问题，生成的假设性文档和电影剧情基本一致。</p><p>LlamaIndex 中生成假设性文档的提示词模板如下，大意就是为问题生成一段内容，其中<code>&#123;context_str&#125;</code>为用户问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HYDE_TMPL = (</span><br><span class="line">    <span class="string">&quot;Please write a passage to answer the question\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Try to include as many key details as possible.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;context_str&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&#x27;Passage:&quot;&quot;&quot;\n&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们再用查询引擎对问题进行检索：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.query_engine <span class="keyword">import</span> TransformQueryEngine</span><br><span class="line"></span><br><span class="line">hyde_query_engine = TransformQueryEngine(query_engine, hyde)</span><br><span class="line">response = hyde_query_engine.query(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;hyde query result: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">hyde query result: 洛基在试图征服地球时使用了立方体，这是一个未知潜力的强大能源。</span><br></pre></td></tr></table></figure><ul><li>基于<code>HyDEQueryTransform</code>构建一个<code>TransformQueryEngine</code></li><li>查询引擎的<code>query</code>方法会先对原始问题生成假设性文档，然后用假设性文档进行检索并生成答案</li></ul><p>虽然我们得到了正确的结果，但我们不清楚 LlamaIndex 内部在检索过程中是否用假设性文档去检索，我们可以通过以下代码来验证：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.retrievers.transform_retriever <span class="keyword">import</span> TransformRetriever</span><br><span class="line"></span><br><span class="line">retriever = node_parser.as_retriever(similarity_top_k=<span class="number">2</span>)</span><br><span class="line">hyde_retriever = TransformRetriever(retriever, hyde)</span><br><span class="line">nodes = hyde_retriever.retrieve(question)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;hyde retriever nodes len: <span class="subst">&#123;<span class="built_in">len</span>(nodes)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node id: <span class="subst">&#123;node.id_&#125;</span>, score: <span class="subst">&#123;node.get_score()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">nodes = retriever.retrieve(<span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;n&#125;</span>&quot;</span> <span class="keyword">for</span> n <span class="keyword">in</span> query_bundle.embedding_strs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;hyde documents retrieve len: <span class="subst">&#123;<span class="built_in">len</span>(nodes)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;node id: <span class="subst">&#123;node.id_&#125;</span>, score: <span class="subst">&#123;node.get_score()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>上半部分使用<code>TransformRetriever</code>结合原始检索器和<code>HyDEQueryTransform</code>对象构建一个新的检索器</li><li>然后用<strong>新的检索器对用户问题</strong>进行检索，打印出检索到的文档 ID 和分数</li><li>下半部分使用<strong>原始检索器对假设性文档</strong>进行检索，假设性文档取自<code>QueryBundle</code>对象的<code>embedding_strs</code>属性，这里的<code>embedding_strs</code>有 2 个元素，一个是假设性文档，另一个是原始问题</li><li>打印出用假设性文档检索到的文档 ID 和分数</li></ul><p>下面是显示的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hyde retriever nodes len: 2</span><br><span class="line">node <span class="built_in">id</span>: 51e9381a-ef93-49ee-ae22-d169eba95549, score: 0.8895532276574978</span><br><span class="line">node <span class="built_in">id</span>: 5ef8a87e-1a72-4551-9801-ae7e792fdad2, score: 0.8499209871867581</span><br><span class="line">==================================================</span><br><span class="line">hyde documents retrieve nodes len: 2</span><br><span class="line">node <span class="built_in">id</span>: 51e9381a-ef93-49ee-ae22-d169eba95549, score: 0.8842142746289462</span><br><span class="line">node <span class="built_in">id</span>: 5ef8a87e-1a72-4551-9801-ae7e792fdad2, score: 0.8460828835028101</span><br></pre></td></tr></table></figure><p>可以看到两者的结果基本一致，证明检索所用的<strong>输入</strong>是相似的，也就是假设性文档，我们再把<code>HyDEQueryTransform</code>对象中的<code>include_original</code>属性设置为<code>False</code>，这意味着生成的假设性文档不包含原始问题，然后再次运行代码，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hyde retriever nodes len: 2</span><br><span class="line">node <span class="built_in">id</span>: cfaea328-16d8-4eb8-87ca-8eeccad28263, score: 0.7548985780343257</span><br><span class="line">node <span class="built_in">id</span>: f47bc6c7-d8e1-421f-b9b8-a8006e768c04, score: 0.7508234876205329</span><br><span class="line">==================================================</span><br><span class="line">hyde documents retrieve nodes len: 2</span><br><span class="line">node <span class="built_in">id</span>: 6c2bb8cc-3c7d-4f92-b039-db925dd60d53, score: 0.7498683385309097</span><br><span class="line">node <span class="built_in">id</span>: f47bc6c7-d8e1-421f-b9b8-a8006e768c04, score: 0.7496147322045141</span><br></pre></td></tr></table></figure><p>可以看到两者的结果也是基本一致，但是由于缺少原始问题，检索到的文档分数较低。</p><h3 id="HyDE-的限制"><a href="#HyDE-的限制" class="headerlink" title="HyDE 的限制"></a>HyDE 的限制</h3><p>HyDE 生成的假设性文档是基于 LLM 的知识生成的，可能存在错误或者不准确，LlamaIndex 在<a href="https://docs.llamaindex.ai/en/stable/examples/query_transformations/HyDEQueryTransformDemo/?h=hyde">官方文档</a>中指出 HyDE 可能会误导查询和引起偏见，所以在实际应用中需要谨慎使用。</p><h2 id="回溯提示（STEP-BACK-PROMPTING）"><a href="#回溯提示（STEP-BACK-PROMPTING）" class="headerlink" title="回溯提示（STEP-BACK PROMPTING）"></a>回溯提示（STEP-BACK PROMPTING）</h2><img src="/images/post/2024/05/stepback_paper.jpeg" class="" width="1000" height="400"><p>回溯提示是一种简单的提示技术，通过抽象化来引导 LLM 从具体实例中提取高级概念和基本原理，利用这些概念和原理指导推理，可以显著提高 LLM 遵循正确推理路径解决问题的能力。<br>以上图中第一个的问题为例，原始问题是给定温度和体积求压强，在左边的回答中，不管是原始的回答还是思维链方式的回答，结果都不正确。而通过回溯提示的方式，先通过原始问题生成一个更为广泛的问题，比如求问题背后的物理公式，再通过广泛问题得到答案，最后将广泛问题的答案和原始问题一起提交给 LLM，从而得到正确的答案。回溯提示的论文可以参考<a href="https://arxiv.org/pdf/2310.06117.pdf">这里</a>。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>回溯提示在 LlamaIndex 中没有具体的实现，但我们可以通过原始调用 LLM 结合 LlamaIndex 的方式来进行演示，首先我们来让 LLM 根据原始问题生成一个回溯的问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line">examples = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;input&quot;</span>: <span class="string">&quot;Who was the spouse of Anna Karina from 1968 to 1974?&quot;</span>,</span><br><span class="line">            <span class="string">&quot;output&quot;</span>: <span class="string">&quot;Who were the spouses of Anna Karina?&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;input&quot;</span>: <span class="string">&quot;Estella Leopold went to whichschool between Aug 1954and Nov 1954?&quot;</span>,</span><br><span class="line">            <span class="string">&quot;output&quot;</span>: <span class="string">&quot;What was Estella Leopold&#x27;seducation history?&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    few_shot_examples = <span class="string">&quot;\n\n&quot;</span>.join(</span><br><span class="line">        [<span class="string">f&quot;human: <span class="subst">&#123;example[<span class="string">&#x27;input&#x27;</span>]&#125;</span>\nAI: <span class="subst">&#123;example[<span class="string">&#x27;output&#x27;</span>]&#125;</span>&quot;</span> <span class="keyword">for</span> example <span class="keyword">in</span> examples]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    step_back_question_system_prompt = PromptTemplate(</span><br><span class="line">        <span class="string">&quot;You are an expert at world knowledge.&quot;</span></span><br><span class="line">        <span class="string">&quot;Your task is to step back and paraphrase a question to a more generic step-back question,&quot;</span></span><br><span class="line">        <span class="string">&quot;which is easier to answer. Here are a few examples:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;few_shot_examples&#125;&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    completion = client.chat.completions.create(</span><br><span class="line">        model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">        temperature=<span class="number">0.1</span>,</span><br><span class="line">        messages=[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: step_back_question_system_prompt.<span class="built_in">format</span>(</span><br><span class="line">                    few_shot_examples=few_shot_examples</span><br><span class="line">                ),</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: question&#125;,</span><br><span class="line">        ],</span><br><span class="line">    )</span><br><span class="line">    step_back_question = completion.choices[<span class="number">0</span>].message.content</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;step_back_question: <span class="subst">&#123;step_back_question&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>首先我们定义了一些回溯问题的例子，将这些例子放到 LLM 的系统提示词中让 LLM 了解生成问题的规律</li><li>将用户问题和系统提示词一起传给 LLM，让 LLM 生成回溯问题</li></ul><p>生成了回溯问题后，我们再分别对原始问题和回溯问题进行检索，获取它们相关的文档：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retrievals = retriever.retrieve(question)</span><br><span class="line">normal_context = <span class="string">&quot;\n\n&quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;n.text&#125;</span>&quot;</span> <span class="keyword">for</span> n <span class="keyword">in</span> retrievals])</span><br><span class="line">retrievals = retriever.retrieve(step_back_question)</span><br><span class="line">step_back_context = <span class="string">&quot;\n\n&quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;n.text&#125;</span>&quot;</span> <span class="keyword">for</span> n <span class="keyword">in</span> retrievals])</span><br></pre></td></tr></table></figure><p>得到了检索结果后，我们让 LLM 生成最终的答案：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">step_back_qa_prompt_template = PromptTemplate(</span><br><span class="line">        <span class="string">&quot;Context information is below.\n&quot;</span></span><br><span class="line">        <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;normal_context&#125;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;step_back_context&#125;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Given the context information and not prior knowledge, &quot;</span></span><br><span class="line">        <span class="string">&quot;answer the question: &#123;question&#125;\n&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    completion = client.chat.completions.create(</span><br><span class="line">        model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">        temperature=<span class="number">0.1</span>,</span><br><span class="line">        messages=[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Always answer the question, even if the context isn&#x27;t helpful.&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: step_back_qa_prompt_template.<span class="built_in">format</span>(</span><br><span class="line">                    normal_context=normal_context,</span><br><span class="line">                    step_back_context=step_back_context,</span><br><span class="line">                    question=question,</span><br><span class="line">                ),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    )</span><br><span class="line">    step_back_result = completion.choices[<span class="number">0</span>].message.content</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;step_back_result: <span class="subst">&#123;step_back_result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>在提示词模板中，我们将原始问题和回溯问题的文档信息传给 LLM，并结合原始问题让 LLM 生成答案</li></ul><p>最后我们看下普通 RAG 检索和使用回溯提示后的 RAG 检索两者的区别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">question: 泰坦星球上有过一场大战吗？</span><br><span class="line">base_result: 没有，泰坦星球上没有发生过大战。它并不是任何已知重大冲突或战争的发生地。</span><br><span class="line">====================================================================================================</span><br><span class="line">step_back_question: 泰坦星球上发生过什么重要事件吗？</span><br><span class="line">step_back_result: 是的，在漫威电影宇宙中，泰坦星球上发生了一场重大的冲突。在《复仇者联盟：无限战争》中，泰坦被描绘成灭霸的毁灭故乡，泰坦上的战斗涉及一群英雄，包括钢铁侠（托尼·斯塔克）、蜘蛛侠（彼得·帕克）、奇异博士（斯蒂芬·斯特兰奇）以及银河护卫队，他们试图阻止灭霸实现他的目标。</span><br></pre></td></tr></table></figure><p>可以看到没有使用回溯提示的结果是错误的，而使用了回溯提示之后，我们得到了问题在知识库文档中的正确答案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们介绍了 RAG 检索中几种查询重写的策略，包括子问题查询、HyDE 查询转换和回溯提示，并通过 LlamaIndex 对这几种策略进行了代码演示，在演示过程中还介绍了一些 LlamaIndex 的使用技巧。还有其他一些查询重写的策略没有在本文中介绍，随着 RAG 技术的发展，查询重写的策略也会越来越多，我们未来在合适的时候再对这一部分进行补充，希望这些内容对大家有所帮助。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍高级 RAG 检索中几种查询重写的策略</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llamaindex" scheme="https://zhaozhiming.github.io/tags/llamaindex/"/>
    
    <category term="rag" scheme="https://zhaozhiming.github.io/tags/rag/"/>
    
    <category term="query-rewrite" scheme="https://zhaozhiming.github.io/tags/query-rewrite/"/>
    
    <category term="hyde" scheme="https://zhaozhiming.github.io/tags/hyde/"/>
    
    <category term="stepback" scheme="https://zhaozhiming.github.io/tags/stepback/"/>
    
  </entry>
  
  <entry>
    <title>使用 Llama3 打造开发团队的私有 Copilot</title>
    <link href="https://zhaozhiming.github.io/2024/05/04/use-llama3-to-build-develop-team-copilot/"/>
    <id>https://zhaozhiming.github.io/2024/05/04/use-llama3-to-build-develop-team-copilot/</id>
    <published>2024-05-04T13:08:41.000Z</published>
    <updated>2024-10-03T08:49:29.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/post/2024/05/llama3-copilot.jpeg" class="" width="400" height="300"><p>相信很多开发人员都使用过 Github Copilot，这种崭新的开发方式可以帮助开发人员极大地提高开发效率，并且也正在逐渐改变开发人员的编程习惯。自从 Meta 开放了最新的开源 LLM（大语言模型） Llama3，业内的各种开发工具和开发框架都在积极地集成 Llama3，以便于使用这个迄今为止功能最强大的开源大模型。今天我们来介绍如何使用 Llama3 构建一个团队专属的私有化 Copilot，不仅可以提高团队的开发效率，还可以保护团队的代码隐私。</p><span id="more"></span><h2 id="编程助手-Copilot"><a href="#编程助手-Copilot" class="headerlink" title="编程助手 Copilot"></a>编程助手 Copilot</h2><p>Copilot 是一种人工智能代码辅助工具，最早由 GitHub 和 OpenAI 共同开发，后面有其他产商也推出了类似的产品。Copilot 能够通过自然语言处理和机器学习技术自动生成高质量代码片段和上下文信息，相比于以前的自动补全工具，Copilot 的代码更加详细和智能，比如自动补全工具只能补全一两行的代码片段，但 Copilot 可以生成整个函数的代码，甚至是整个类，从而减轻程序员的工作量并节省时间和精力。除了代码生成外，Copilot 还是支持 AI 问答、代码解释、语言转换、生成单元测试等功能。目前 Copilot 的使用存在以下几种形式。</p><h3 id="线上服务"><a href="#线上服务" class="headerlink" title="线上服务"></a>线上服务</h3><img src="/images/post/2024/05/copilot-online.png" class="" width="600" height="400"><p>第一种是线上服务，比如 <a href="https://github.com/features/copilot">GitHub Copilot</a>，这种服务用户一般只需安装 IDE 插件即可使用，无需关心模型的部署，优点是可以使用线上性能强大的模型，尤其是 Github Copilot，通过 GitHub 上的代码作为模型训练数据，使得生成的代码质量更高，缺点是无法保护代码隐私，因为你要使用 Copilot 服务，你的代码就会被上传到服务端。</p><p>除了 GitHub Copilot 外，其他类似的产品还有：</p><ul><li><a href="https://codeium.com/">Codeium</a>：一家致力于为开发者提供更智能高效的编程体验的人工智能公司，支持 VSCode、Jetbrains 等 40 多种的 IDE，个人使用完全免费</li><li><a href="https://codegeex.cn/en-US">CodeGeeX</a>：清华大学开发的代码辅助工具，支持多种语言，免费使用，使用了自研的模型</li><li><a href="https://aws.amazon.com/codewhisperer/">CodeWhisperer</a>：AWS 推出的代码辅助工具，免费使用，特点是具有安全扫描功能</li><li><a href="https://tongyi.aliyun.com/lingma/">通义灵码</a>：阿里云推出的代码辅助工具，使用阿里研发的 Qwen 大模型，支持多种语言，免费使用</li></ul><h3 id="本地服务"><a href="#本地服务" class="headerlink" title="本地服务"></a>本地服务</h3><img src="/images/post/2024/05/copilot-local.png" class="" width="600" height="400"><p>第二种是本地服务，这种方式需要在本地部署 LLM，然后通过 IDE 插件调用本地 LLM 的 API 服务。部署本地 LLM 的工具比较多，常用的有<a href="https://ollama.com/">Ollama</a>、<a href="https://localai.io/">LocalAI</a> 等，这些工具支持在 CPU 的机器上运行 LLM，这种方式的优点是无需联网即可使用，并且可以很好地保护代码隐私，缺点是需要每个开发人员都需要安装本地 LLM。</p><h3 id="私有化服务"><a href="#私有化服务" class="headerlink" title="私有化服务"></a>私有化服务</h3><img src="/images/post/2024/05/copilot-team.png" class="" width="600" height="400"><p>私有化服务也是一种本地服务，但与本地服务不同的是，开发人员无需安装本地 LLM，而是通过开发团队统一来部署 LLM 服务，然后开发人员通过 IDE 插件调用团队内部的 LLM 服务。这种方式的优点是可以保护代码隐私，同时也可以提高团队的开发效率，这也是我们今天要介绍的 Copilot 使用方式。</p><h2 id="Llama3-部署"><a href="#Llama3-部署" class="headerlink" title="Llama3 部署"></a>Llama3 部署</h2><p>我们要使用 Llama3 来打造团队的私有 Copilot，首先需要部署 Llama3 ，这里我们使用 <a href="https://github.com/vllm-project/vllm">vllm</a>来部署 Llama3。vllm 是一个高效、易用的库，用于 LLM 的推理和提供服务，它可以部署兼容 OpenAI API 的服务。相比同类产品，vllm 的主要特点是吞<strong>吐率高、延迟低、速度快</strong>。</p><p>首先下载 Llama3 的模型，Llama3 可以在 HuggingFace 上进行下载，但在下载之前需要先提交申请，申请后大约等待一段时间即可审批通过，接着使用 HuggingFace 的 CLI 命令进行下载，我们要下载<a href="https://huggingface.co/meta-llama/Meta-Llama-3-8B-Instruct">Meta-Llama-3-8B-Instruct</a>这个模型，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huggingface-cli download meta-llama/Meta-Llama-3-8B-Instruct --token YOUR_HF_TOKEN</span><br></pre></td></tr></table></figure><p>然后安装 vllm，vllm 可以通过 pip 安装，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n vllm python=3.9 -y</span><br><span class="line">conda activate vllm</span><br><span class="line">pip install vllm</span><br></pre></td></tr></table></figure><p>安装完成后，我们使用 vllm 的命令来启动兼容 OpenAI 的 API 服务，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m vllm.entrypoints.openai.api_server \</span><br><span class="line">--model meta-llama/Meta-Llama-3-8B-Instruct \</span><br><span class="line">--gpu-memory-utilization 0.85</span><br></pre></td></tr></table></figure><p><code>gpu-memory-utilization</code>是 GPU 内存的使用率，这里设置为 0.85，表示服务启动后会占用 85%的 GPU 内存。</p><p>启动服务后，服务地址是<code>http://localhost:8000</code>，我们可以通过 curl 命令来验证 API 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8000/v1/chat/completions \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;meta-llama/Meta-Llama-3-8B-Instruct&quot;,</span></span><br><span class="line"><span class="string">    &quot;messages&quot;: [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &quot;role&quot;: &quot;user&quot;,</span></span><br><span class="line"><span class="string">        &quot;content&quot;: &quot;Hello!&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;cmpl-01cb80c24d4a4e32992b6328fbf09794&quot;</span>,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>: 1714901485,</span><br><span class="line">  <span class="string">&quot;model&quot;</span>: <span class="string">&quot;meta-llama/Meta-Llama-3-8B-Instruct&quot;</span>,</span><br><span class="line">  <span class="string">&quot;object&quot;</span>: <span class="string">&quot;chat.completion&quot;</span>,</span><br><span class="line">  <span class="string">&quot;choices&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;finish_reason&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">      <span class="string">&quot;logprobs&quot;</span>: null,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: 0,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Hello! It&#x27;s nice to meet you. Is there something I can help you with, or would you like to chat?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;usage&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;prompt_tokens&quot;</span>: 13,</span><br><span class="line">    <span class="string">&quot;completion_tokens&quot;</span>: 26,</span><br><span class="line">    <span class="string">&quot;total_tokens&quot;</span>: 39</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IDE-插件-Continue"><a href="#IDE-插件-Continue" class="headerlink" title="IDE 插件 Continue"></a>IDE 插件 Continue</h2><p>部署完服务端后，我们再来安装客户端。<a href="https://www.continue.dev/">Continue</a> 是一个帮助开发人员轻松创建自己的模块化人工智能软件开发系统的 IDE 插件，它支持 VSCode 和 JetBrains 等 IDE，支持一般 Copilot 的功能，包括代码生成、代码解释、AI 问答等。</p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>我们以 VSCode 为例介绍 Continue 插件的安装，首先进去 VSCode 的插件商店搜索 Continue 插件，然后点击安装即可：</p><img src="/images/post/2024/05/continue-install.png" class="" width="1000" height="600"><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>然后修改 Continue 的配置，使用快捷键打开插件配置文件：cmd&#x2F;ctrl + shift + P，输入 Continue config, 选择<code>Open config.json</code>：</p><img src="/images/post/2024/05/continue-config.png" class="" width="800" height="300"><p>然后修改配置文件，Continue 默认使用 Ollama 来做本地 LLM 部署，但如果我们已经部署好了 LLM 服务，就可以将原来配置文件中的<code>models</code>和<code>tabAutocompleteModel</code>的配置修改为我们自己的 LLM 服务，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;models&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;llama3-8b&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;meta-llama/Meta-Llama-3-8B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;apiBase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://your-llama3-api-host:8000/v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openai&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;apiKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;empty&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="attr">&quot;tabAutocompleteModel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tab Autocomplete Model&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;meta-llama/Meta-Llama-3-8B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;apiBase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://your-llama3-api-host:8000/v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openai&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;apiKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;empty&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>LLM 配置信息中填写<code>provider</code>为<code>openai</code>，这里利用了 OpenAI 的配置格式</li><li>在<code>apiBase</code>中填写我们部署的 LLM 服务地址，这里是<code>http://your-llama3-api-host:8000/v1</code>，注意要加上最后的<code>v1</code>路径</li><li><code>model</code>填写我们下载的 Llama3 模型，这里是<code>meta-llama/Meta-Llama-3-8B-Instruct</code></li><li><code>apiKey</code>属性可以随便填</li><li><code>title</code>属性是显示在插件中的模型名称</li><li><code>models</code>属性是指在 AI 问答和代码生成功能中可以使用的模型</li><li><code>tabAutocompleteModel</code>属性是指在代码补全功能中使用的模型</li></ul><p>然后我们在 Continue 插件中选择模型<code>llama3-8b</code>，这样就可以开始使用 Llama3 了：</p><img src="/images/post/2024/05/continue-select.png" class="" width="400" height="300"><h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><p>我们先看下 AI 问答功能， 输入问题后 LLM 生成回答：</p><img src="/images/post/2024/05/continue-usage1.png" class="" width="600" height="400"><p>再看看代码生成功能，选中代码后后按住 cmd&#x2F;ctrl + I 键会弹出输入框，我们在输入框中让 LLM 帮我们完成这个方法：</p><img src="/images/post/2024/05/continue-usage2.png" class="" width="600" height="400"><img src="/images/post/2024/05/continue-usage3.png" class="" width="600" height="400"><p>接着看解释代码，选中代码后后按住 cmd&#x2F;ctrl + L 键会将选中的代码复制到问答框中，输入问题后 LLM 根据代码进行回答：</p><img src="/images/post/2024/05/continue-usage4.png" class="" width="600" height="400"><p>生成单元测试，也属于代码生成功能，与之前操作相同：</p><img src="/images/post/2024/05/continue-usage6.png" class="" width="600" height="400"><img src="/images/post/2024/05/continue-usage5.png" class="" width="600" height="400"><p>关于Continue插件的更多使用方法，可以参考<a href="https://docs.continue.dev/">官方文档</a>。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果在使用的过程中发现 Llama3 的输出一直没有结束，可以在配置文件中添加<code>completionOptions</code>配置信息来修复这个问题：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;llama3-8b&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;meta-llama/Meta-Llama-3-8B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;apiBase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://your-llama3-api-host:8000/v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openai&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;apiKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;empty&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;completionOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;stop&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;|eot_id|&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>另外除了 Llama3 之外，还有其他的开源 LLM 也可以用来作为代码辅助工具，比如<a href="https://huggingface.co/Qwen/CodeQwen1.5-7B-Chat">CodeQwen1.5-7B-Chat</a>就是一个不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用开源 LLM 作为团队的代码辅助工具，可以提高团队的开发效率，同时也可以保护团队的代码隐私，虽然目前开源的 LLM 相比 Github Copilot 等公司的线上 LLM 还有一些差距，但是随着开源 LLM 的不断发展，相信两者的差距以后会越来越小。以上就是今天介绍的内容，希望对大家有所帮助。</p><p>关注我，一起学习各种人工智能和 AIGC 新技术，欢迎交流，如果你有什么想问想说的，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">介绍如何部署 Llama3 作为团队私有 Copilot，提高团队的开发效率</summary>
    
    
    
    <category term="ai" scheme="https://zhaozhiming.github.io/categories/ai/"/>
    
    
    <category term="llama3" scheme="https://zhaozhiming.github.io/tags/llama3/"/>
    
    <category term="copilot" scheme="https://zhaozhiming.github.io/tags/copilot/"/>
    
    <category term="vscode" scheme="https://zhaozhiming.github.io/tags/vscode/"/>
    
    <category term="ollama" scheme="https://zhaozhiming.github.io/tags/ollama/"/>
    
  </entry>
  
</feed>
